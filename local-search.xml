<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2023/05/18/Kafka/"/>
    <url>/2023/05/18/Kafka/</url>
    
    <content type="html"><![CDATA[<h3 id="1、术语"><a href="#1、术语" class="headerlink" title="1、术语"></a>1、术语</h3><h4 id="（1）kafka三层消息架构"><a href="#（1）kafka三层消息架构" class="headerlink" title="（1）kafka三层消息架构"></a>（1）kafka三层消息架构</h4><blockquote><ul><li><p>第一层是主题层，每个主题可以配置多个分区，每个分区可以配置多个副本；</p></li><li><p>第二层是分区层，每个分区的N个副本中，只有领导者副本可以对外提供服务，其他N-1个副本是追随者副本，只能供数据冗余备份；</p></li><li><p>第三层为消息层，分区中有若干条消息，消息位移从0开始递增；</p><img src="/2023/05/18/Kafka/1.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）Broke数据持久化"><a href="#（2）Broke数据持久化" class="headerlink" title="（2）Broke数据持久化"></a>（2）Broke数据持久化</h4><blockquote><ul><li><p>消息日志：使用消息日志保存数据，一个消息日志就是磁盘上一个只能追加写的物理文件，采用顺序IO，是实现高吞吐量的重要手段；</p></li><li><p>日志索引：存储<strong>消息的偏移量</strong>和<strong>消息在消息日志分段中的位置</strong>的映射关系，磁盘和内存各有一份，以支持高效的消息读取和消费；</p></li><li><p>位移索引：存储<strong>消息偏移量</strong>和<strong>消息在消息日志中的分段位置</strong>之间映射关系，磁盘和内存各一份；</p></li><li><p>消息日志被分为多个日志段（Log Segmenet），消息数据追加导最新的日志段，日志段写满后会关闭，并创建一个新的日志段；</p></li><li><p>Kafka后台的定时任务，会根据保留策略，删除一些旧的日志段；</p><img src="/2023/05/18/Kafka/2.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（3）其他术语"><a href="#（3）其他术语" class="headerlink" title="（3）其他术语"></a>（3）其他术语</h4><blockquote><ul><li>消息位移：每个分区中，消息存储的位移，是单调递增且不变的值；</li><li>消费者位移：表示消费者消费的进度，每个消费者有自己的消费位移；</li><li>重平衡：消费组内某个消费者挂了，其他消费者自动分配订阅主题的过程；</li></ul></blockquote><h3 id="2、集群参数配置"><a href="#2、集群参数配置" class="headerlink" title="2、集群参数配置"></a>2、集群参数配置</h3><h4 id="（1）存储信息参数"><a href="#（1）存储信息参数" class="headerlink" title="（1）存储信息参数"></a>（1）存储信息参数</h4><blockquote><ul><li>log.dirs：指定Broke存储数据的若干各文件路径，没有默认值，需要开发者指定；</li><li>log.dir：指定Broke存储数据的单个文件路径；</li><li>只需指定上述其中一个参数即可（最好指定第一个），多个路径最好挂载到不同磁盘上，多块磁盘可以同时读写数据，有更高的吞吐量，多块磁盘还能实现故障转移；</li></ul></blockquote><h4 id="（2）与zookeeper相关参数"><a href="#（2）与zookeeper相关参数" class="headerlink" title="（2）与zookeeper相关参数"></a>（2）与zookeeper相关参数</h4><blockquote><ul><li>zookeeper.connect：用于指定kafka与zookeeper的链接信息；</li><li>Zookeeper用于协调和管理kafka集群的各个组件，kafka通过zookeeper实现集群的之间的协调工作，包括消费者组的管理等；</li></ul></blockquote><h4 id="（3）与Broke相关参数"><a href="#（3）与Broke相关参数" class="headerlink" title="（3）与Broke相关参数"></a>（3）与Broke相关参数</h4><blockquote><ul><li>listeners：监听器，监听指定网络的接口和端口，从而接收生产者和消费者的请求，并进行相应处理；格式为：<listeners>:&#x2F;&#x2F;<host>:<port>，listeners为协议，host为主机名或ip地址，port为端口；</li><li>advertised.listeners：用于告知生产者和消费者连接到kafka的有效网络地址；</li></ul></blockquote><h4 id="（4）与Topic相关参数"><a href="#（4）与Topic相关参数" class="headerlink" title="（4）与Topic相关参数"></a>（4）与Topic相关参数</h4><blockquote><ul><li>auto.create.topics.enable：是否允许自动创建topic，最好将其关闭，应为当我们将主题名称拼错时，若开启此参数，kafka会自动创建topic主题，导致服务器中大量主题存在；</li><li>unclean.leader.election.enable：默认为false，是否允许数据少的副本竞争leader，最好不要开启此参数，因为数据存储少的副本竞选为leader后，认为自己的数据才是权威数据，会导致数据丢失；</li><li>auto.leader.rebalance.enable：是否允许定期选举leader，最好关闭，更换一次leader代价大；</li></ul></blockquote><h4 id="（5）与数据保存相关参数"><a href="#（5）与数据保存相关参数" class="headerlink" title="（5）与数据保存相关参数"></a>（5）与数据保存相关参数</h4><blockquote><ul><li>log.retention.{hour|minutes|ms}：控制一条消息数据保存的时间；</li><li>log.retention.bytes：指定Broke为消息保存的总磁盘大小，-1表示可以使用全部磁盘容量保存；</li><li>message.max.bytes：指定Broke能够接收最大消息大小；</li></ul></blockquote><h4 id="（6）Topic级别参数配置"><a href="#（6）Topic级别参数配置" class="headerlink" title="（6）Topic级别参数配置"></a>（6）Topic级别参数配置</h4><blockquote><ul><li>retention.ms：指定topic保存消息的时间，默认为7天；</li><li>retention.bytes：指定topic可以使用磁盘多少空间，-1为可以无限使用磁盘大小；</li></ul></blockquote><h3 id="3、生产者分区原理"><a href="#3、生产者分区原理" class="headerlink" title="3、生产者分区原理"></a>3、生产者分区原理</h3><h4 id="（1）分区原因"><a href="#（1）分区原因" class="headerlink" title="（1）分区原因"></a>（1）分区原因</h4><blockquote><p>提供负载均衡，提高系统伸缩性，不同的分区可以部署在不同的节点上，而数据的读写也是在针对分区而进行的，每个节点机器上的分区，可以独立执行请求的读写操作，并且可以通过增加节点提高系统的吞吐量；</p></blockquote><h4 id="（2）分区策略"><a href="#（2）分区策略" class="headerlink" title="（2）分区策略"></a>（2）分区策略</h4><h5 id="①轮询策略"><a href="#①轮询策略" class="headerlink" title="①轮询策略"></a>①轮询策略</h5><blockquote><ul><li><p>按顺序分配，将消息依次分配到不同分区上；</p></li><li><p>能够最大限度上保证消息被均匀的分配到各个分区上；</p><img src="/2023/05/18/Kafka/3.jpg" class="" title="Kafka"></li></ul></blockquote><h5 id="②随机策略"><a href="#②随机策略" class="headerlink" title="②随机策略"></a>②随机策略</h5><blockquote><p>计算所有分区的数量，随机返回一个小于他的数量，将消息发送到该随机数对应的分区；</p><img src="/2023/05/18/Kafka/4.jpg" class="" title="Kafka"></blockquote><h5 id="③按消息键保存策略"><a href="#③按消息键保存策略" class="headerlink" title="③按消息键保存策略"></a>③按消息键保存策略</h5><blockquote><ul><li><p>每条消息携带一个消息键（key），是一个明确业务含义的字符串；</p></li><li><p>根据这个key进行计算，进入不同的分区，同一个key的消息进入的分区相同；</p><img src="/2023/05/18/Kafka/5.jpg" class="" title="Kafka"></li></ul></blockquote><h3 id="4、生产者压缩算法"><a href="#4、生产者压缩算法" class="headerlink" title="4、生产者压缩算法"></a>4、生产者压缩算法</h3><blockquote><ul><li><p>kafka消息存储在消息日志中，消息日志由一系列消息集合组成，一个消息集合包含多个日志项，一个日志项是对一条消息的封装；</p></li><li><p>在生产者指定压缩算法，则生成者启动后，每个消息集合都是经过压缩后才发送到Broke服务器；</p></li><li><p>生成者压缩的消息发送到Broke后，大部分是直接保存而不会修改，但也会有Broke需要重压缩的情况：</p></li><li><ul><li>生产者和Broke指定的压缩算法不一样，这样会导致Broke收到压缩的消息集合后，会进行解压，压缩，导致CPU飙升；（没有指定Broke的压缩算法，Broke是尊重生产者的压缩算法）</li><li>Broke接收的数据发生格式转换，如新版本数据转换为老版本数据，会发生解压。压缩，同时会丧失零拷贝（数据格式转换需要内核拷贝到用户空间进行）；</li></ul></li><li><p>在消费者端进行解压缩，当有数据格式发生变化，Broke端也会进行解压缩；</p><img src="/2023/05/18/Kafka/6.jpg" class="" title="Kafka"></li></ul></blockquote><h3 id="5、消息可靠性"><a href="#5、消息可靠性" class="headerlink" title="5、消息可靠性"></a>5、消息可靠性</h3><blockquote><ul><li>kafka对“已提交”的消息保证最大限度的不丢失（至少需要有一台Broke服务器还在运行）；</li><li>“已提交”消息：生产者将消息发送到kafka的若干个Broke中，并写入消息日志，则为已提交消息；</li><li>我们可以指定生成者将消息发送到一个Broke中就算“已提交”，也可以指定生成者将消息发送到多个Broke才算“已提交”；</li></ul></blockquote><h4 id="（1）生成者数据丢失"><a href="#（1）生成者数据丢失" class="headerlink" title="（1）生成者数据丢失"></a>（1）生成者数据丢失</h4><blockquote><ul><li><p>生成者发送的数据不合法，或者传输过程中导致数据丢失；</p></li><li><p>生成者发送消息，应使用带有回调函数的API，他能告诉生成者消息发送是否成功，若发生错误可以进行相应的处理；</p></li><li><p>Broke服务器宕机，导致消息接收失败；</p><img src="/2023/05/18/Kafka/7.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）消费者数据丢失"><a href="#（2）消费者数据丢失" class="headerlink" title="（2）消费者数据丢失"></a>（2）消费者数据丢失</h4><blockquote><ul><li><p>消费者消费消息时，会维护一个“位移”，表示消费位置，若先更新“位移”,再消费数据，如果中途停止消费，下一次消费会从“位移”位置开始，导致之前还没消费完的数据丢失；</p></li><li><p>采用先更新数据，在更新“位移”，可以最大限度保证消息不丢失，但可能会造成消息重复消费；</p></li><li><p>多线程消费消息，当线程消费消息后，会自动更新“位移”，当有一个线程消费失败，而消费者自动更新位移，会导致消息丢失；</p></li><li><p>采用关闭消费者自动提交”位移“，采用手动更新”位移“，但在多线程情况下，消息位移很难正确更新，也会导致消息被重复消费；</p><img src="/2023/05/18/Kafka/8.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（3）解决方案"><a href="#（3）解决方案" class="headerlink" title="（3）解决方案"></a>（3）解决方案</h4><blockquote><ul><li>生成者发送消息时，使用带有callback回调方法的API；</li><li>消费者中enable.auto.commit设置为false，关闭自动提交位移，只有消费者消费成功才手动提交位移；</li><li>设置min.insync.replicas &gt; 1，控制消息写入多少副本，才算”已提交“，设置大于1可以提升持久性；</li></ul></blockquote><h3 id="6、Kafka生成者使用TCP连接"><a href="#6、Kafka生成者使用TCP连接" class="headerlink" title="6、Kafka生成者使用TCP连接"></a>6、Kafka生成者使用TCP连接</h3><h4 id="（1）使用TCP连接原因"><a href="#（1）使用TCP连接原因" class="headerlink" title="（1）使用TCP连接原因"></a>（1）使用TCP连接原因</h4><blockquote><ul><li>TCP可以提供可靠性和顺序性，消息队列中，保持消息顺序性和处理顺序十分重要，而HTTP无法保证顺序性；</li><li>TCP可以建立一个可靠的双向数据通道，确保客户端和服务端之间的稳定连接，而HTTP是请求-响应模式，每次都会建立连接，发送请求，等待响应，会造成延迟；</li><li>TCP还提供流量控制，跨网络支持等；</li></ul></blockquote><h4 id="（2）建立TCP连接"><a href="#（2）建立TCP连接" class="headerlink" title="（2）建立TCP连接"></a>（2）建立TCP连接</h4><blockquote><ul><li>创建生产者实例时，会同时创建一个后台线程，线程运行时会与指定的bootstrap.servers创建TCP连接；</li><li>发送消息时，若生产者与发送的的目标Broke尚未建立连接，此时也会建立TCP连接；</li><li>生产者给一个不存在的主题发送消息，Broke会告知生产者主题不存在，生成者会发送一个metadata信息给kafka集群，获取信息，此时也会建立TCP连接；</li><li>生产者每隔5分钟会发送一个metadata信息，更新kafka集群信息，此时也会建立TCP连接；</li></ul></blockquote><h4 id="（3）关闭TCP连接"><a href="#（3）关闭TCP连接" class="headerlink" title="（3）关闭TCP连接"></a>（3）关闭TCP连接</h4><blockquote><ul><li>用户主动关闭，使用命令kill -9 主动杀掉；</li><li>Kafka 关闭，这与 Producer 端参数 connections.max.idle.ms 的值有关，默认为9分钟，若将值设置为-1，则会保持长连接</li></ul></blockquote><h3 id="7、幂等性"><a href="#7、幂等性" class="headerlink" title="7、幂等性"></a>7、幂等性</h3><h4 id="（1）幂等性Producer"><a href="#（1）幂等性Producer" class="headerlink" title="（1）幂等性Producer"></a>（1）幂等性Producer</h4><blockquote><ul><li>设置enable.idempotence 参数为true，kafka可以主动帮我们去重，采用空间换时间的思路，即在Broke中保存额外字段，若生产者发送相同字段到Broke，会被丢弃掉；</li><li>只能保证一个分区的消息不会被重复消费，且只能为同一个会话，即如果重新启动kafka，相当于重新创建了一个会话；</li></ul></blockquote><h4 id="（2）事务型Producer"><a href="#（2）事务型Producer" class="headerlink" title="（2）事务型Producer"></a>（2）事务型Producer</h4><blockquote><ul><li><p>一个事务的消息要吗都发送成功，要么都发送失败，重启也可以保证消息精确性；</p></li><li><p>设置enable.idempotence 参数为true，同时设置参数transaction.id；</p></li><li><p>事务中的消息即使写入失败，kafka同样会写入底层日志中，consumer可以看到这些消息，consumer需要设置参数 isolation.level ：</p></li><li><ul><li>read_uncommitted：默认值，consumer可以读取到未提交的消息，使用事务型Producer就不要使用该值；</li><li>read_committed：consumer只能读取到已经提交事务的消息；</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">producer.initTransactions();<span class="hljs-comment">//事务初始化</span><br><span class="hljs-keyword">try</span> &#123;<br>    producer.beginTransaction();<span class="hljs-comment">//事务开始</span><br>    producer.send(msg1);<br>    ........<br>    producer.commitTransaction();<span class="hljs-comment">//事务提交</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    producer.abortTransaction();<span class="hljs-comment">//事务终止</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、消费者组"><a href="#8、消费者组" class="headerlink" title="8、消费者组"></a>8、消费者组</h3><blockquote><ul><li><p>一个消费者组包含一个或多个消费者，消费者可以是一个单独的进程，也可以是同一进程下的线程；</p></li><li><p>Group Id的表示一个消费者组的唯一标识，是一个字符串；</p></li><li><p>一个消费者组订阅一个主题的单分区，该分区的每条消息只能分配给消费者组中的一个消费者消费；</p></li><li><p>理想状态下，消费者组中的消费者数量&#x3D;&#x3D;订阅主题的总分区数；如一个消费者组定于2个主题A和B，A主题有2个分区，B主题有4个分区，消费者组设置6个消费者最好；若设置3个消费者，平均一个消费者需要消费2个分区；若设置8个消费者，会有2个消费者不会被分配分区，浪费资源；</p><img src="/2023/05/18/Kafka/9.jpg" class="" title="Kafka"></li></ul></blockquote><blockquote><p><strong>重平衡（Rebalance）</strong></p><ul><li><p>规定消费者组下，所有消费者如何分配订阅主题的分区；</p></li><li><p>触发重平衡条件：消费者组消费者数量发生变化、订阅主题数发生变化、订阅主题中的分区数发生变化；</p></li><li><p>Rebalance性能极差，发生Rebalance时，会停止所有消费者消费，同时所有分区会重新分配，导连接不可复用，所以尽量避免发生Rebalance最好；</p></li><li><p>避免Rebalance：</p><ul><li><ul><li>避免因未能及时发送心跳，导致consumer被踢出，设置session.time.ms&#x3D;6s ,heartbeat.interval.ms&#x3D;2s,即在判定为死亡之前，至少发送3次心跳检查；</li><li>设置参数max.poll.interval.ms，可以将该参数设置比业务处理时间大一点，避免因消费时间过长导致Rebanlance；</li></ul></li></ul></li></ul></blockquote><h3 id="9、位移"><a href="#9、位移" class="headerlink" title="9、位移"></a>9、位移</h3><h4 id="（1）位移主题"><a href="#（1）位移主题" class="headerlink" title="（1）位移主题"></a>（1）位移主题</h4><blockquote><ul><li><p>__consumer_offsets：主要用于保存消费者位移信息，若写入的信息不符合kafka规定格式，会导致broke崩溃；</p></li><li><p>位移主题的消息格式为：</p></li><li><ul><li>kv，key主要保存groupId+主题名+分区号，value主要保存位移值，时间戳等；</li><li>用于保存消费组的信息；</li><li>用于删除消费组组的信息，当消费组所有消费组都停止，且位移数据已被删除，则会触发；</li></ul></li><li><p>kafka默认会自动创建位移主题，该猪头分区数为50个，副本数为3；</p></li><li><p>消费组消费消息时，会提交位移，往该主题写入位移消息，提交位移分为手动提交和自动提交，如果采用自动提交位移，只要消费组一直启动着，就会不断往该主题写入消息（会撑爆磁盘）；</p></li><li><p>kafka后台会启用一个Log Cleaner线程，用于清理过期消息（如同一个key的消息由多条，只会保存最新的一条）</p><img src="/2023/05/18/Kafka/10.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）位移提交"><a href="#（2）位移提交" class="headerlink" title="（2）位移提交"></a>（2）位移提交</h4><blockquote><ul><li>自动提交（默认）：kafka默认每5秒提交一次位移，消费组在执行此处逻辑之前，先提交上一批位移，后执行逻辑，因此可以保证消息不丢失，但可能出现消息重复消费；</li></ul><p>如：kafka每5秒提交一次位移，假设提交位移后3s发生Rebalance（消费者重新分配分区），消费者从上一次提交位移开始消费，但位移是3s前的位移，所以会导致重复消费3s前的消息；</p><img src="/2023/05/18/Kafka/11.jpg" class="" title="Kafka"></blockquote><blockquote><ul><li><p>手动提交：</p></li><li><ul><li>commitSync：同步提交，采用该提交方式，会阻塞消费者端，直到Broke返回提交成功，消费者才能继续往下执行，可以通过调整提交间隔时间，减少阻塞，但时间越大，重复消费的消息会越多；提交失败会自动重试；</li><li>commitAsync：异步提交，采用该提交方式，会立即返回，不会阻塞，会提供回调函数，在回调函数中可以实现提交后的逻辑；提交失败后不会自动重试</li></ul></li><li><p>可以采用异步提交和同步提交相互结合，在阶段性提交可以采用commitAsync（）提交，在消费者关闭前采用同步commitSync（）提交，最后一次提交保证位移的正确性；</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="hljs-number">1</span>));<br>         <span class="hljs-comment">// 处理消息</span><br>        commitAysnc(); <span class="hljs-comment">// 使用异步提交规避阻塞</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>     <span class="hljs-comment">// 处理异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consumer.commitSync(); <span class="hljs-comment">// 最后一次提交使用同步阻塞式提交</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        consumer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）位移提交异常CommitFailedException"><a href="#（3）位移提交异常CommitFailedException" class="headerlink" title="（3）位移提交异常CommitFailedException"></a>（3）位移提交异常<strong>CommitFailedException</strong></h4><blockquote><ul><li><p>位移提交异常：消费者在消费完数据后，进行位移提交，但提交失败，原因是发生Rebalance，并且将提交位移的分区分配给另外一个消费者；（发生Rebalance原因：两次poll调用时间超过max.poll.interval.ms设置时间）</p></li><li><p>消息处理时间超过max.poll.interval.ms导致异常解决方法：</p></li><li><ul><li>缩短单条消息的处理时间；</li><li>增大参数max.poll.interval.ms，提升两次poll的间隔时间；</li><li>减少一次消费者处理的消息数，通过设置max.poll.records参数；</li><li>使用多线程来进行消息消费；</li></ul></li><li><p>消费组和独立消费者的groupId相等时，位移提交时，也会报提交错误；</p></li></ul></blockquote><h3 id="10、多线程消费者"><a href="#10、多线程消费者" class="headerlink" title="10、多线程消费者"></a>10、多线程消费者</h3><h4 id="（1）多线程-多消费者实例"><a href="#（1）多线程-多消费者实例" class="headerlink" title="（1）多线程+多消费者实例"></a>（1）多线程+多消费者实例</h4><blockquote><ul><li><p>启动多个线程，每一个线程维护一个消费者实例，负载消息的接收、消息处理；</p></li><li><p>多线程之间没有任何交互，是线程安全；每个分区保证被一个线程处理，可以实现消息消费的顺序性；</p></li><li><p>每个线程维护一个消费者，会占用大量内存资源；每个线程完整的执行消息处理逻辑，一旦消息处理逻辑过长，会引发Rebalance；线程数受分区数的影响，不能高于分区数，扩展性有局限；</p><img src="/2023/05/18/Kafka/12.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）单线程-单消费者实例-多线程处理"><a href="#（2）单线程-单消费者实例-多线程处理" class="headerlink" title="（2）单线程+单消费者实例+多线程处理"></a>（2）单线程+单消费者实例+多线程处理</h4><blockquote><ul><li><p>消费者使用单个或多个线程获取消息，每个线程维护一个消费者实例，消费者中的消息处理交给线程池中的线程处理；</p></li><li><p>可以扩展消费者线程数和处理消息的线程数，伸缩性好；</p></li><li><p>消息获取顺序可以保证，但由于消息处理交给线程池处理（不是在获取消息线程中处理），所以消息处理顺序无法保证；消息处理链路过长，导致移位提交困难，容易出现消息重复；</p><img src="/2023/05/18/Kafka/13.jpg" class="" title="Kafka"></li></ul></blockquote><h3 id="11、Kafka消费者管理TCP连接"><a href="#11、Kafka消费者管理TCP连接" class="headerlink" title="11、Kafka消费者管理TCP连接"></a>11、Kafka消费者管理TCP连接</h3><h4 id="（1）建立TCP连接"><a href="#（1）建立TCP连接" class="headerlink" title="（1）建立TCP连接"></a>（1）建立TCP连接</h4><blockquote><ul><li>消费者创建TCP的时机是在消费者调用poll（）方法，即获取消息时创建；</li><li>发送FindCoordinator请求时，向Broke集群中负载最小的一台机器发送请求，建立TCP连接，从而获取协调者所在broke机器；</li><li>连接协调者，与协调者的broke机器建立TCP连接；</li><li>消费数据时也会建立TCP连接，如消费者消费数据的分区分布在不同的Broke上，则需要建立TCP连接；</li></ul></blockquote><h4 id="（2）关闭TCP连接"><a href="#（2）关闭TCP连接" class="headerlink" title="（2）关闭TCP连接"></a>（2）关闭TCP连接</h4><blockquote><ul><li>可以手动关闭TCP连接，使用kill命令；也可以kafka自动关闭TCP连接，默认9分钟没有任何请求过来，则会关闭连接；</li><li>有与消费者会循环调用poll（）方法获取消息，所以连接上总是会有请求发送，因此可以保持长连接；</li></ul></blockquote><h3 id="12、副本机制"><a href="#12、副本机制" class="headerlink" title="12、副本机制"></a>12、副本机制</h3><h4 id="（1）副本定义"><a href="#（1）副本定义" class="headerlink" title="（1）副本定义"></a>（1）副本定义</h4><blockquote><ul><li><p>副本本质上是一个可以追加消息的提交日志；</p></li><li><p>同一个分区下的副本保存相同的消息，这些副本分散在不同的Broke机器上，从而避免Broke宕机带来的数据不可用；</p></li><li><p>每台Broke上，都有可能保存同一主题下不同分区的不同副本；</p><img src="/2023/05/18/Kafka/14.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）副本角色"><a href="#（2）副本角色" class="headerlink" title="（2）副本角色"></a>（2）副本角色</h4><blockquote><ul><li><p>副本分为领导者副本和追随者副本，只有一个领导者副本；</p></li><li><p>领导者副本才能对外进行服务，追随者副本只会将领导者副本中的消息拉去到自己的提交日志中；</p></li><li><p>领导者副本挂了后，追随者副本会选举一个副本当领导者副本，老领导副本恢复后，变为追随者副本；</p></li><li><p>追随者副本不提供服务好处：</p></li><li><ul><li><p>提高系统实时性，如果启用追随者副本对外提供服务，由于拉去消息是异步进行，会出现追随者副本延迟处理消息；</p></li><li><p>方便实现单调读，即不会出现消息一会在，一会不在的情况；如副本1异步拉去了领导者副本数据，而副本2未拉取，消费者先从副本1读，再取副本2读，此时副本2读取不到；</p><img src="/2023/05/18/Kafka/15.jpg" class="" title="Kafka"></li></ul></li></ul></blockquote><h4 id="（3）ISR集合"><a href="#（3）ISR集合" class="headerlink" title="（3）ISR集合"></a>（3）ISR集合</h4><blockquote><ul><li>存储领导者副本和与领导者副本同步的追随者副本；</li><li>判断追随者副本与领导者副本是否同步，右参数 replica.lag.time.max.ms决定，默认为10s，即只要追随者副本落后领导者副本时间不超过10s，就认为是同步的；</li><li>ISR集合会检测集合中追随者副本是否同步，不同步踢出集合，将同步的追随者副本加入集合；</li><li>若ISP为空，说明领导者副本也挂了，此时可以通过参数<strong>unclean.leader.election.enable</strong>判断是否需要进行Unclean领导选举，该选举会选举未同步的追随者副本，将其变为领导者副本，会导致数据丢失，不建议开启；</li></ul></blockquote><h3 id="13、请求处理"><a href="#13、请求处理" class="headerlink" title="13、请求处理"></a>13、请求处理</h3><blockquote><ul><li>Accepto线程用于请求分发，不用于处理请求逻辑；</li><li>Acceptor会将请求交给网络线程池中的线程进行处理，可以通过设置Broke参数num.network.threads调整线程数量，默认为3个线程；</li></ul><img src="/2023/05/18/Kafka/16.jpg" class="" title="Kafka"><ul><li><p>网络线程池收到请求后，并不会执行请求处理，而是将请求放入请求队列中；</p></li><li><p>IO线程池，负责处理请求队列中的请求逻辑，默认为8个线程，可以设置参数num.io.threads指定线程数；</p></li><li><p>处理完请求后，会将对应的响应结果返回到对应的网络线程的响应队列中，并由对应网络线程返回给客户端；</p></li><li><p>Purgatory：延迟请求队列，存储需要被延迟处理的请求，一旦请求可以处理，则由IO线程处理请求，并响应结果返回网络线程的响应队列中；如acks&#x3D;all的produce请求，需要等待所有副本接收到消息才能返回；</p><img src="/2023/05/18/Kafka/17.jpg" class="" title="Kafka"></li></ul></blockquote><h3 id="14、Rebalance流程"><a href="#14、Rebalance流程" class="headerlink" title="14、Rebalance流程"></a>14、Rebalance流程</h3><h4 id="（1）JoinGroup请求"><a href="#（1）JoinGroup请求" class="headerlink" title="（1）JoinGroup请求"></a>（1）JoinGroup请求</h4><blockquote><ul><li><p>消费者组中每一个消费者发送一个joinGroup请求给协调者，告诉协调者自己订阅的主题信息；</p></li><li><p>协调者会手机所有订阅信息，协调者会选择一个消费者做为领导者，并将订阅响应信息发送给领导者；由领导者统一做出分配方案；</p><img src="/2023/05/18/Kafka/18.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）SyncGroup请求"><a href="#（2）SyncGroup请求" class="headerlink" title="（2）SyncGroup请求"></a>（2）SyncGroup请求</h4><blockquote><ul><li><p>领导者发送刚刚指定的分配方案（SyncGroup请求）给协调者；</p></li><li><p>其他消费者也会发送SyncGroup请求，该请求不携带任何数据；</p></li><li><p>协调者收到方案后，通过SyncGroup响应返回给每一个消费者；</p><img src="/2023/05/18/Kafka/19.jpg" class="" title="Kafka"></li></ul></blockquote><h3 id="15、高水位"><a href="#15、高水位" class="headerlink" title="15、高水位"></a>15、高水位</h3><h4 id="（1）高水位作用"><a href="#（1）高水位作用" class="headerlink" title="（1）高水位作用"></a>（1）高水位作用</h4><blockquote><ul><li><p>高水位：定义消息可见性，用于标识分区下哪些消费者可以被消费；</p></li><li><p>位移值处于高水位或高水位以上，属于未提交的消息，不能进行消费；</p></li><li><p>Log And Offset（日志末端位移）：表示下一条消息写入的位移位置；</p></li><li><p>Log Stable Offset：判断事务型消费者的可见性；</p><img src="/2023/05/18/Kafka/20.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）高水位更新机制"><a href="#（2）高水位更新机制" class="headerlink" title="（2）高水位更新机制"></a>（2）高水位更新机制</h4><blockquote><ul><li>发送消息：生产者发送消息到Kafka，消息会写入到领导者副本的日志中；</li><li>副本复制：领导者副本收到消息后，追随者副本会到领导者副本拉去消息，所有追随者副本一旦消息写入到自己的日志中，会向领导者副本发送确认消息；</li><li>确认消息：领导者副本接收到足够数量的追随者副本的确认，就会更新高水位；</li></ul></blockquote><h3 id="16、消费者重设位移"><a href="#16、消费者重设位移" class="headerlink" title="16、消费者重设位移"></a>16、消费者重设位移</h3><h4 id="（1）位移维度"><a href="#（1）位移维度" class="headerlink" title="（1）位移维度"></a>（1）位移维度</h4><blockquote><ul><li>Earliest：将位移设置为主题当前最早的位移处，最找位移不一定是0，kafka会有策略删除很久远的消息，该策略适合需要重复消费主题所有消息；</li><li>Lastest：将位移调整到末端，该策略适合需要跳过所有历史消息，打算从最新的消息处开始消费；</li><li>Current：将位移移动到当前提交位移的位置；如位移5s提交一次，我们修改消费者代码，消费3s时，我们发现消费者逻辑错误，需要回滚，此时消费者消费的3秒数据需要重新消费，可以使用该模式将位移移动回位移提交的位置，重新消费消息；</li><li>Specific-Offset：将位移设置为我们指定的位移位置，当有消费者消费某条消息出错时，我们可以通过手动设置位移，跳过失败位置；</li><li>Shift-By-N：将当前位移，往前&#x2F;往后移动我们指定的位移数；</li></ul></blockquote><h4 id="（2）时间维度"><a href="#（2）时间维度" class="headerlink" title="（2）时间维度"></a>（2）时间维度</h4><blockquote><ul><li>DateTime：指定某个时间，位移设置为该时间后的最早位移处，如我们需要重新消费昨天数据，可以设置为0点；</li><li>Duration：指定一个时间间隔，将位移设置到当前时间间隔位移处，格式为PnDTnHnMnS，n为数值，D、H、M、S代表天、小时、分钟、秒；如设置10分钟前PT0H10M0S；</li></ul></blockquote><h3 id="17、AdminClient"><a href="#17、AdminClient" class="headerlink" title="17、AdminClient"></a>17、AdminClient</h3><h4 id="（1）工作原理"><a href="#（1）工作原理" class="headerlink" title="（1）工作原理"></a>（1）工作原理</h4><blockquote><ul><li><p>双线程设计，分为前端主线程和后台IO线程；</p></li><li><p>前端主线程构建请求，将其加入新请求队列后，可以直接返回（不阻塞），继续处理后续请求；</p></li><li><p>新请求队列由monitor保证线程安全，为了避免阻塞后端IO线程会将新请求队列拉取到待发送队列，然后发送给kafka集群处理；</p></li><li><p>请求处理完毕后，会调用call请求回调逻辑，通知前端线程获取结果；</p><img src="/2023/05/18/Kafka/21.jpg" class="" title="Kafka"></li></ul></blockquote><h4 id="（2）使用"><a href="#（2）使用" class="headerlink" title="（2）使用"></a>（2）使用</h4><blockquote><ul><li>createTopics（）：创建主题；</li><li>listConsumerGroupOffsets（）：获取消费位移</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建主题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdminClient</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;localhost:9092&quot;</span>);<br>    props.put(<span class="hljs-string">&quot;request.timeout.ms&quot;</span>, <span class="hljs-number">600000</span>);<br><br>    String topic=<span class="hljs-string">&quot;newTopic&quot;</span>;<br>    <span class="hljs-keyword">try</span> (AdminClient client=AdminClient.create(props))&#123;<br>        <span class="hljs-type">NewTopic</span> <span class="hljs-variable">newTopic</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewTopic</span>(topic, <span class="hljs-number">10</span>, (<span class="hljs-type">short</span>) <span class="hljs-number">1</span>);<br>        <span class="hljs-type">CreateTopicsResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> client.createTopics(Arrays.asList(newTopic));<br>        result.all().get(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity</title>
    <link href="/2023/05/11/SpringSecurity/"/>
    <url>/2023/05/11/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<h3 id="1、功能体系"><a href="#1、功能体系" class="headerlink" title="1、功能体系"></a>1、功能体系</h3><h4 id="（1）SpringSecurity与单体应用"><a href="#（1）SpringSecurity与单体应用" class="headerlink" title="（1）SpringSecurity与单体应用"></a>（1）SpringSecurity与单体应用</h4><blockquote><ul><li><p>认证：对于每一次请求访问认证，系统会校验该请求访问者是否具有合法身份；</p></li><li><p>授权：用户通过认证后，可以访问服务器资源，但服务器资源某些资源可能需要更加高级用户才能访问，因此需要对访问的权限进行验证；</p><img src="/2023/05/11/SpringSecurity/1.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（2）SpringSecurity与微服务应用"><a href="#（2）SpringSecurity与微服务应用" class="headerlink" title="（2）SpringSecurity与微服务应用"></a>（2）SpringSecurity与微服务应用</h4><blockquote><ul><li><p>微服务中，每个服务消费者是客户端，而服务提供者是资源服务器，所以各服务既可以是客户端，也可以为资源服务器；</p></li><li><p>微服务应用中添加了授权中心，授权中心会获取用户请求身份凭证，返回token信息；</p></li><li><p>用户请求通过token访问服务，服务对token进行认证授权，访问对应端点资源；</p><img src="/2023/05/11/SpringSecurity/2.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h3 id="2、认证"><a href="#2、认证" class="headerlink" title="2、认证"></a>2、认证</h3><h4 id="（1）SpringSecurity用户对象"><a href="#（1）SpringSecurity用户对象" class="headerlink" title="（1）SpringSecurity用户对象"></a>（1）SpringSecurity用户对象</h4><blockquote><ul><li><p>UserDetails：SpringSecurity用户对象；</p></li><li><p>GrantedAuthority：定义用户操作权限；</p></li><li><p>UserDetailsService：定义了对UserDetail的查询操作；</p></li><li><p>UserDetailsManager：扩展UserDetailsService，添加了创建用户，修改用户密码等；</p><img src="/2023/05/11/SpringSecurity/3.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（2）认证对象"><a href="#（2）认证对象" class="headerlink" title="（2）认证对象"></a>（2）认证对象</h4><blockquote><ul><li><p>Authentication：认证的请求本身，认证过程交由相应组件AuthenticationProvider完成；</p></li><li><p>SpringSecurity是使用AuthenticationManager接口来代理AuthenticationProvider实现认证，如JdbcUserDetailsManager：</p><img src="/2023/05/11/SpringSecurity/4.jpg" class="" title="SpringSecurity"></li><li><p>UsernamePasswordAuthenticationToken是实现Authentication接口的实现类，用于存储用户认证所需的用户名和密码；</p></li></ul></blockquote><h4 id="（3）定制化认证"><a href="#（3）定制化认证" class="headerlink" title="（3）定制化认证"></a>（3）定制化认证</h4><blockquote><ul><li><p>实现UserDetails接口，该实现类可以自定义我们需要的对应数据库字段；</p></li><li><p>实现UserDetailsService接口，该实现类主重写方法loadUserByUsername（），可以根据用户名到数据库中查找；</p></li><li><p>实现AuthenticationProvider接口，重写authenticate（）和supports（）方法，authenticate（）方法执行逻辑如下：</p></li><li><p>继承WebSecurityConfiurateAdapter，重写configurate（）方法，添加自定义的AuthenticationProvider和UserDetailsService</p><img src="/2023/05/11/SpringSecurity/5.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（4）PassWordEncoder"><a href="#（4）PassWordEncoder" class="headerlink" title="（4）PassWordEncoder"></a>（4）PassWordEncoder</h4><blockquote><p>加密器：</p><ul><li>NoOpPasswordEncoder：不对密码进行加密。</li><li>StandardPasswordEncoder：使用 SHA-256 算法对密码执行哈希操作，该算法通过获取盐和明文密码最终生成密文密码，加盐是指在密码加密中，往原密码中加入附加数据，然后再加密；</li><li>BCryptPasswordEncoder：使用 bcrypt 强哈希算法对密码执行哈希操作。</li><li>Pbkdf2PasswordEncoder：使用 PBKDF2 算法对密码执行哈希操作。</li></ul><p>DelegatingPasswordEncoder：</p><ul><li><p>起到代理组件的角色，通过器代理，可以将密码分配到对应的密码加密器加密和解密；</p></li><li><p>默认实现的加密器为BCryptPasswordEncoder，通过PasswordEncoderFactories创建该代理类；</p></li><li><p>数据库存储密文密码格式为：{id}password</p><img src="/2023/05/11/SpringSecurity/6.jpg" class="" title="SpringSecurity"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DelegatingPasswordEncoder.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DelegatingPasswordEncoder</span><span class="hljs-params">(String idForEncode,</span><br><span class="hljs-params">                                 Map&lt;String, PasswordEncoder&gt; idToPasswordEncoder)</span> &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-built_in">this</span>.idForEncode = idForEncode;<br>    <span class="hljs-comment">//对应加密器</span><br>    <span class="hljs-built_in">this</span>.passwordEncoderForEncode = idToPasswordEncoder.get(idForEncode);<br>    <span class="hljs-comment">//key：前缀，value：加密器类</span><br>    <span class="hljs-built_in">this</span>.idToPasswordEncoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(idToPasswordEncoder);<br>&#125;<br><span class="hljs-comment">//PasswordEncoderFactories.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title function_">createDelegatingPasswordEncoder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">encodingId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bcrypt&quot;</span>;<br>    Map&lt;String, PasswordEncoder&gt; encoders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    encoders.put(encodingId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>());<br>    encoders.put(<span class="hljs-string">&quot;ldap&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.LdapShaPasswordEncoder());<br>    encoders.put(<span class="hljs-string">&quot;MD4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.Md4PasswordEncoder());<br>    encoders.put(<span class="hljs-string">&quot;MD5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">&quot;MD5&quot;</span>));<br>    encoders.put(<span class="hljs-string">&quot;noop&quot;</span>, org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());<br>    encoders.put(<span class="hljs-string">&quot;pbkdf2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pbkdf2PasswordEncoder</span>());<br>    encoders.put(<span class="hljs-string">&quot;scrypt&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SCryptPasswordEncoder</span>());<br>    encoders.put(<span class="hljs-string">&quot;SHA-1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">&quot;SHA-1&quot;</span>));<br>    encoders.put(<span class="hljs-string">&quot;SHA-256&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">&quot;SHA-256&quot;</span>));<br>    encoders.put(<span class="hljs-string">&quot;sha256&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.springframework.security.crypto.password.StandardPasswordEncoder());<br>    encoders.put(<span class="hljs-string">&quot;argon2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Argon2PasswordEncoder</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingPasswordEncoder</span>(encodingId, encoders);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、授权"><a href="#3、授权" class="headerlink" title="3、授权"></a>3、授权</h3><h4 id="（1）基于权限进行访问控制"><a href="#（1）基于权限进行访问控制" class="headerlink" title="（1）基于权限进行访问控制"></a>（1）基于权限进行访问控制</h4><blockquote><ul><li>需要在WebSecurityConfigurerAdapter中的configure（）方法，进行权限配置；</li><li>hasAuthority（String role）：允许具有特定权限访问；</li><li>hasAnyAuthority（String role）：允许具有任一权限进行访问；</li><li>acess（）：根据表达式，确定所需权限；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//具有CREATE权限可以访问</span><br>http.authorizeRequests().anyRequest().access(<span class="hljs-string">&quot;hasAuthority(&#x27;CREATE&#x27;)&quot;</span>);<br><span class="hljs-comment">//具有user权限可以访问</span><br>http.authorizeRequests().anyRequest().hasAuthority(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-comment">//具有user，admin权限其中一个，就可以访问</span><br>http.authorizeRequests().anyRequest().hasAnyAuthority(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="（2）基于角色进行访问控制"><a href="#（2）基于角色进行访问控制" class="headerlink" title="（2）基于角色进行访问控制"></a>（2）基于角色进行访问控制</h4><blockquote><ul><li>将角色看出为拥有多个权限的载体，以”ROLE_“为前缀的GrantedAuthority，就代表一种角色；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//具有ROLE_ADMIN权限的用户才能访问</span><br>http.authorizeRequests().anyRequest().hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>);<br><span class="hljs-comment">//具有ROLE_ADMIN或者ROLE_USER的用户才能访问</span><br>http.authorizeRequests().anyRequest().hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>,<span class="hljs-string">&quot;USER&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="（3）使用配置方法控制访问权限"><a href="#（3）使用配置方法控制访问权限" class="headerlink" title="（3）使用配置方法控制访问权限"></a>（3）使用配置方法控制访问权限</h4><blockquote><ul><li>MVC匹配器：使用mvcMatchers（），根据方法的请求路径进行权限匹配；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  /hello路径下的请求，需要具有ADMIN权限才能进行访问，其他路径以直接访问</span><br>http.authorizeRequests().mvcMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>).anyRequest().permijtAll();<br><span class="hljs-comment">//  /hello路径下的请求，需要具有ADMIN权限才能进行访问，其他路径需要认证后才可以访问</span><br>http.authorizeRequests().mvcMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>).anyRequest().authenticate();<br><span class="hljs-comment">// /hello路径请求下，且请求方式为GET，需要认证才能访问，其他请求可以直接访问</span><br>http.authorizeRequests().mvcMatchers(HttpMethod.GET,<span class="hljs-string">&quot;/hello&quot;</span>).authenticated()<br>.anyRequest().permijtAll();<br></code></pre></td></tr></table></figure><blockquote><ul><li>ANT匹配器：使用antMatchers（）匹配，与MVC匹配器类似，但访问的请求后需要加”&#x2F;“，否则匹配不到；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">http://localhost/hello/  可以请求到</span><br><span class="hljs-comment">http://localhost/hello   匹配失败</span><br><span class="hljs-comment">*/</span><br>http.authorizeRequests().antMatchers(HttpMethod.GET,<span class="hljs-string">&quot;/hello&quot;</span>).authenticated();<br></code></pre></td></tr></table></figure><blockquote><ul><li>正则匹配器：使用regexMatchers进行匹配，基于正则表达式实现；</li></ul></blockquote><h4 id="（4）授权工作流程"><a href="#（4）授权工作流程" class="headerlink" title="（4）授权工作流程"></a>（4）授权工作流程</h4><blockquote><ul><li><p>基于过滤器链进行请求拦截，从而实现对访问权限的控制；</p></li><li><p>拦截请求：FIlterSecurityInterceptor：整个请求过滤器的末端，对权限控制进行拦截，以此判断能否到HTTP端点；</p></li><li><p>获取权限配置：请求拦截后，获取请求访问资源，以及对应资源的权限信息，通过SecurtiyMetadataSource获取，最终将配置信息转换为ConfigAttribute；</p></li><li><p>执行授权决策：获取到配置信息后，根据配置信息决定HTTP是否有权限进行访问，该操作由AccessDecisionManager接口完成，会委派给AccessDecisionVoter完成；</p><img src="/2023/05/11/SpringSecurity/7.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h5 id="①拦截请求"><a href="#①拦截请求" class="headerlink" title="①拦截请求"></a>①拦截请求</h5><blockquote><ul><li>FilterSecurityInterceptor实现了Filter接口，请求访问时，会先调用过滤器doFIlter（）方法；</li><li>FIlterSecurityInterceptor只是获取HTTP请求，权限校验委托给其父类AbstractSecurityInterceptor执行；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FilterSecurityInterceptor.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span><br><span class="hljs-params">                     FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">FilterInvocation</span> <span class="hljs-variable">fi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterInvocation</span>(request, response, chain);<br>    invoke(fi);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(FilterInvocation fi)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 代码忽略。。。。。</span><br>        <span class="hljs-type">InterceptorStatusToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.beforeInvocation(fi);<span class="hljs-comment">//核心方法</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());<span class="hljs-comment">//请求继续往下执行</span><br>        &#125;<br>        <span class="hljs-comment">//代码忽略......</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//AbstractSecurityInterceptor.class</span><br><span class="hljs-keyword">protected</span> InterceptorStatusToken <span class="hljs-title function_">beforeInvocation</span><span class="hljs-params">(Object object)</span> &#123;<br><span class="hljs-comment">//代码忽略。。。。</span><br><span class="hljs-comment">//获取ConfigAttribute集合</span><br>    Collection&lt;ConfigAttribute&gt; attributes = <span class="hljs-built_in">this</span>.obtainSecurityMetadataSource()<br>            .getAttributes(object);<br><br>    <span class="hljs-comment">//代码忽略。。。。</span><br><span class="hljs-comment">//获取认证信息</span><br>    <span class="hljs-type">Authentication</span> <span class="hljs-variable">authenticated</span> <span class="hljs-operator">=</span> authenticateIfRequired();<br><br>    <span class="hljs-comment">// 授权</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);<br>    &#125;<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②获取权限配置"><a href="#②获取权限配置" class="headerlink" title="②获取权限配置"></a>②获取权限配置</h5><blockquote><ul><li>http.authorizedRequests()和http.hasAuthoried()返回的是一个ExpressionInterceptUrlRegistry对象，http.anyRequests()方法返回的一个AuthoriedUrl对象；</li><li>FIlterSecurtiyInterceptor对象由AbstractInterceptorUrl进行创建；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractInterceptorUrl.class</span><br><span class="hljs-keyword">private</span> FilterSecurityInterceptor <span class="hljs-title function_">createFilterSecurityInterceptor</span><span class="hljs-params">(H http,</span><br><span class="hljs-params">                            FilterInvocationSecurityMetadataSource metadataSource,</span><br><span class="hljs-params">                     AuthenticationManager authenticationManager)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">FilterSecurityInterceptor</span> <span class="hljs-variable">securityInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterSecurityInterceptor</span>();<br>    securityInterceptor.setSecurityMetadataSource(metadataSource);<br>    securityInterceptor.setAccessDecisionManager(getAccessDecisionManager(http));<br>    securityInterceptor.setAuthenticationManager(authenticationManager);<br>    securityInterceptor.afterPropertiesSet();<br>    <span class="hljs-keyword">return</span> securityInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>FIlterInvocationInvocationSecurityMetadataSource</strong>：</p><ul><li>即MetadataSource，资源配置其，存放url和权限的映射关系；</li><li>AbstractInterceptorUrl提供抽象创建方法，由子类ExpressionUrlAuthorizationConfigurer进行创建；</li><li>REGISTRY:类型为ExpressionInterceptUrlRegistry，http.authorizedRequests()返回该类型；</li><li>createRequestMap（）方法：将请求与权限资源的urlMapping存储到REGISTRY中；</li><li>urlMapping是由ExpressionUrlAuthorizationConfigurer.AuthorizedUrl中的acess方法创建；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ExpressionUrlAuthorizationConfigurer.class</span><br>ExpressionBasedFilterInvocationSecurityMetadataSource <span class="hljs-title function_">createMetadataSource</span><span class="hljs-params">( H http)</span> &#123;<br>    LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = <br>REGISTRY.createRequestMap();<span class="hljs-comment">//创建映射关系</span><br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressionBasedFilterInvocationSecurityMetadataSource</span>(requestMap,getExpressionHandler(http));<br>&#125;<br><span class="hljs-comment">//ExceptionInterceptUrlRegistery.class</span><br><span class="hljs-keyword">final</span> LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; <span class="hljs-title function_">createRequestMap</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//代码忽略</span><br>    LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (UrlMapping mapping : getUrlMappings()) &#123;<br>        <span class="hljs-type">RequestMatcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> mapping.getRequestMatcher();<br>        Collection&lt;ConfigAttribute&gt; configAttrs = mapping.getConfigAttrs();<br>        requestMap.put(matcher, configAttrs);<br>    &#125;<br>    <span class="hljs-keyword">return</span> requestMap;<br>&#125;<br><span class="hljs-comment">//ExpressionUrlAuthorizationConfigurer.AuthorizedUrl.class</span><br><span class="hljs-keyword">public</span> ExpressionInterceptUrlRegistry <span class="hljs-title function_">access</span><span class="hljs-params">(String attribute)</span> &#123;<br>    <span class="hljs-keyword">if</span> (not) &#123;<br>        attribute = <span class="hljs-string">&quot;!&quot;</span> + attribute;<br>    &#125;<br>    interceptUrl(requestMatchers, SecurityConfig.createList(attribute));<br>    <span class="hljs-keyword">return</span> ExpressionUrlAuthorizationConfigurer.<span class="hljs-built_in">this</span>.REGISTRY;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interceptUrl</span><span class="hljs-params">(Iterable&lt;? extends RequestMatcher&gt; requestMatchers,</span><br><span class="hljs-params">        Collection&lt;ConfigAttribute&gt; configAttributes)</span> &#123;<br>    <span class="hljs-keyword">for</span> (RequestMatcher requestMatcher : requestMatchers) &#123;<br>        REGISTRY.addMapping(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractConfigAttributeRequestMatcherRegistry</span>.UrlMapping(<br>                requestMatcher, configAttributes));<span class="hljs-comment">//创建UrlMapping</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③执行授权决策"><a href="#③执行授权决策" class="headerlink" title="③执行授权决策"></a>③执行授权决策</h5><blockquote><p><strong>authenticateIfRequired（）</strong></p><ul><li>进行认证，获取认证信息；</li><li>判断认证信息是否存在上下文环境中，存在直接返回；</li><li>不存在，调用AuthenticationManager来的authticate（）方法进行认证，该方法最终会调用AuthenticationProvider.authticate()方法，若我们有自定义实现该接口，会执行我们指定的认证逻辑，否则采用默认逻辑；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Authentication</span> <span class="hljs-variable">authenticated</span> <span class="hljs-operator">=</span> authenticateIfRequired();<br><span class="hljs-keyword">private</span> Authentication <span class="hljs-title function_">authenticateIfRequired</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext() .getAuthentication();<br><span class="hljs-comment">//认证信息存在</span><br>    <span class="hljs-keyword">if</span> (authentication.isAuthenticated() &amp;&amp; !alwaysReauthenticate) &#123;<br>        <span class="hljs-comment">//代码忽略。。。。</span><br>        <span class="hljs-keyword">return</span> authentication;<br>    &#125;<br>    authentication = authenticationManager.authenticate(authentication);<span class="hljs-comment">//开始认证</span><br>    <span class="hljs-comment">//代码忽略。。</span><br>    SecurityContextHolder.getContext().setAuthentication(authentication);<span class="hljs-comment">//认证信息存储</span><br>    <span class="hljs-keyword">return</span> authentication;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>decide（）：</strong></p><ul><li>AccessDecisionManager，默认会创建一个 AffirmativeBased 实例；</li><li>将授权委托给一组AccessDecisionVoter，只要其中一组没有通过，授权就失败；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);<span class="hljs-comment">//执行授权</span><br><span class="hljs-comment">//AffirmativeBased.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="hljs-keyword">throws</span> AccessDeniedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">deny</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> voter.vote(authentication, object, configAttributes);<br>        <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-keyword">switch</span> (result) &#123;<br>            <span class="hljs-keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:<span class="hljs-comment">//授权未通过</span><br>                deny++;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (deny &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//授权失败，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessDeniedException</span>(messages.getMessage(<br>            <span class="hljs-string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="hljs-string">&quot;Access is denied&quot;</span>));<br>    &#125;<br>    checkAllowIfAllAbstainDecisions();<br>&#125;<br><span class="hljs-comment">//WebExpressionVoter.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vote</span><span class="hljs-params">(Authentication authentication, FilterInvocation fi,</span><br><span class="hljs-params">                Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-comment">//查找授权表达式信息</span><br>    <span class="hljs-type">WebExpressionConfigAttribute</span> <span class="hljs-variable">weca</span> <span class="hljs-operator">=</span> findConfigAttribute(attributes);<br>    <span class="hljs-keyword">if</span> (weca == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ACCESS_ABSTAIN;<span class="hljs-comment">//放弃匹配，交由其他授权决策权继续处理</span><br>    &#125;<br><br>    <span class="hljs-type">EvaluationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> expressionHandler.createEvaluationContext(authentication,                                                               fi);<br>    ctx = weca.postProcess(ctx, fi);<br>    <span class="hljs-comment">//授权匹配</span><br>    <span class="hljs-keyword">return</span> ExpressionUtils.evaluateAsBoolean(weca.getAuthorizeExpression(), ctx) ? <br>    ACCESS_GRANTED: ACCESS_DENIED;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、SpringSecurity过滤器"><a href="#4、SpringSecurity过滤器" class="headerlink" title="4、SpringSecurity过滤器"></a>4、SpringSecurity过滤器</h3><h4 id="（1）过滤器链"><a href="#（1）过滤器链" class="headerlink" title="（1）过滤器链"></a>（1）过滤器链</h4><blockquote><ul><li><p>servlet过滤器链原理：<a href="https://swttws.github.io/2022/04/07/Tomcat/#5%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B">过滤器链调用</a></p></li><li><p>SpringSecurity过滤器链都直接或间接实现了Filter接口；</p></li><li><p>UserPasswordAuthenticationFIlter：用于验证用户名和密码是否正确，并将结果传递到下一个过滤器链，该过滤器（attemptAuthentication）是由其父类过滤器AbstractAuthenticationProcessingFIlter中的doFIlter（）方法调用；</p></li><li><p>BasicAuthenticationFIilter：用于验证用户身份，该类的核心方法为doFilterInternal（），由其父类OncePreRequestFilter中的doFIlter（）方法调用；</p></li><li><p>该过滤器链的最后一个过滤器为FilterSecurityInterceptor，该过滤器实现了权限的控制；</p><img src="/2023/05/11/SpringSecurity/8.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（2）自定义过滤器链"><a href="#（2）自定义过滤器链" class="headerlink" title="（2）自定义过滤器链"></a>（2）自定义过滤器链</h4><blockquote><ul><li><p>过滤器链中是按照顺序执行的，添加过滤器链应根据实际业务顺序添加；</p></li><li><p>添加过滤方法有</p></li><li><ul><li>addFIlterBefore(Filter1，Filter2)：Filter1添加在Filter2之前；</li><li>addFilterAfter(Filter1，Filter2)：Filter1添加在Filter2之后；</li></ul></li><li><p>示例：我们自定义HeaderFilter（检查请求头是否有指定标志），LoggFIlter（打印请求日志），前面讲到的BasicAuthenticationFilter是验证用户身份凭证过滤器，这三个过滤器顺序如下图：</p><img src="/2023/05/11/SpringSecurity/9.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（3）常见过滤器"><a href="#（3）常见过滤器" class="headerlink" title="（3）常见过滤器"></a>（3）常见过滤器</h4><table><thead><tr><th>顺序</th><th>过滤器</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>ChannelProcessingFilter</td><td>根据配置进行协议重定向</td></tr><tr><td>2</td><td>SecurityContextPersistenceFilter</td><td>针对web请求，结束时将SecurityContext请求保存到session</td></tr><tr><td>3</td><td>ConcurrentSeesionFilter</td><td>刷新session最后更新时间，并判断session是否过期</td></tr><tr><td>4</td><td>UsernamePasswordAuthenticationFIlterBasicAuthenticationFilter、……</td><td>一组认证过滤器</td></tr><tr><td>5</td><td>SecurityContextHolderAwareRequestFilter</td><td>安全上下文过滤器</td></tr><tr><td>6</td><td>JassApiIntegrationFilter</td><td>Jass相关过滤器</td></tr><tr><td>7</td><td>RemeberMeAuthenticationFilter</td><td>提供”记住我“功能过滤器</td></tr><tr><td>8</td><td>AnonymousAuthenticationFIlter</td><td>匿名授权过滤器</td></tr><tr><td>9</td><td>ExceptionTransactionFilter</td><td>异常捕获和处理过滤器</td></tr><tr><td>10</td><td>FilterSecurityInterceptor</td><td>权限控制过滤器</td></tr></tbody></table><blockquote><p><strong>UsernamePasswordAuthenticationFilter执行逻辑如下图：</strong></p><img src="/2023/05/11/SpringSecurity/10.jpg" class="" title="SpringSecurity"></blockquote><h3 id="5、CSRF和CROS"><a href="#5、CSRF和CROS" class="headerlink" title="5、CSRF和CROS"></a>5、CSRF和CROS</h3><h4 id="（1）CSRF"><a href="#（1）CSRF" class="headerlink" title="（1）CSRF"></a>（1）CSRF</h4><blockquote><ul><li><p>CSRF：伪造者恶意请求盗用用户身份凭证（不是获取cookie中的crsf），通过用户身份凭证访问合法网站，进行恶意攻击；</p></li><li><p>普通用户向合法网站发送请求，服务器进行身份验证；</p></li><li><p>服务器身份验证通过，将身份凭证保存到普通用户的cookies中；</p></li><li><p>普通用户点击恶意链接，恶意链接获取到普通用户访问合法网站的身份信息；</p></li><li><p>恶意链接利用普通用户身份信息伪造请求，访问合法网站；</p></li><li><p>合法网站校验成功，恶意请求开始执行；</p><img src="/2023/05/11/SpringSecurity/11.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（2）防止CRSF攻击"><a href="#（2）防止CRSF攻击" class="headerlink" title="（2）防止CRSF攻击"></a>（2）防止CRSF攻击</h4><blockquote><p><strong>CrsFilter：</strong></p><ul><li>允许使用head，get等请求直接访问（不会拦截），针对post，put，delete等可能修改请求，则会进行拦截，检查Cookie中的crsf和请求头的crsf是否一致，不一致，拒绝访问；</li><li>拦截请求，并获取请求中的crsf令牌，若请求中不存在，则添加一个crsf到请求头的cookie中（第一次请求肯定不存在crsf，添加后crsf到请求头的cookie中和request请求属性中，，可以保证请求能够继续往后执行，在后面过滤器中再进行身份验证）；</li><li>判断请求头中的crsf和cookie中的crsf是否一样，伪造者盗用的用户身份凭证请求中，请求头通常不会有正确的crsf，与cookie中的crsf比较后，不一致，则拒绝访问；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//CrsFilter.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                HttpServletResponse response, FilterChain filterChain)</span><span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    request.setAttribute(HttpServletResponse.class.getName(), response);<br><span class="hljs-comment">//请求中获取crsf_token</span><br>    <span class="hljs-type">CsrfToken</span> <span class="hljs-variable">csrfToken</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tokenRepository.loadToken(request);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">missingToken</span> <span class="hljs-operator">=</span> csrfToken == <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (missingToken) &#123;<span class="hljs-comment">//crsf_token不存在，添加到cookie中</span><br>        csrfToken = <span class="hljs-built_in">this</span>.tokenRepository.generateToken(request);<br>        <span class="hljs-built_in">this</span>.tokenRepository.saveToken(csrfToken, request, response);<br>    &#125;<br>    request.setAttribute(CsrfToken.class.getName(), csrfToken);<br>    request.setAttribute(csrfToken.getParameterName(), csrfToken);<span class="hljs-comment">//设置token</span><br><span class="hljs-comment">//请求不需要过滤，放行</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.requireCsrfProtectionMatcher.matches(request)) &#123;<br>        filterChain.doFilter(request, response);<span class="hljs-comment">//过滤器放行，执行下一个过滤器</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//获取实际请求头中的crsr_token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">actualToken</span> <span class="hljs-operator">=</span> request.getHeader(csrfToken.getHeaderName());<br>    <span class="hljs-keyword">if</span> (actualToken == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//为空，参数获取</span><br>        actualToken = request.getParameter(csrfToken.getParameterName());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!csrfToken.getToken().equals(actualToken)) &#123;<span class="hljs-comment">//携带的token不一样，过滤掉</span><br>        <span class="hljs-comment">//代码忽略。。。。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//过滤去放行，执行下一个过滤器</span><br>    filterChain.doFilter(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>定制化CSRF保护：</strong></p><ul><li>可以通过实现CsrfTokenRepository接口，重写三个方法；</li><li>generateToken（）：生成csrf令牌；</li><li>saveToken（）：保存csrf令牌，CsrFilter使用的是保存在cookie中；</li><li>loadToken（）：加载csrf令牌；</li><li>同时还开启配置，实现自定义功能；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCrsToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CsrfTokenRepository</span>&#123;<br>    <span class="hljs-keyword">static</span> Map&lt;String,CsrfToken&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<span class="hljs-comment">//保存username，csrf映射</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title function_">generateToken</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        String token=UUID.randomUUID().toString();<br>        System.out.println(<span class="hljs-string">&quot;生成csrf_token为：&quot;</span>+token);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultCsrfToken</span>(<span class="hljs-string">&quot;X-CSRF-TOKEN&quot;</span>, <span class="hljs-string">&quot;_csrf&quot;</span>, token);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveToken</span><span class="hljs-params">(CsrfToken token, HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-comment">//获取用户名参数（模拟唯一标识）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">//将生成的token保存到map中</span><br>        map.put(username,token);<br>        System.out.println(map);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title function_">loadToken</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.get(request.getParameter(<span class="hljs-string">&quot;username&quot;</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringSecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests().mvcMatchers(<span class="hljs-string">&quot;/**&quot;</span>).permitAll();<br>        http.csrf(csrf-&gt;&#123;<br>            csrf.csrfTokenRepository(myCrsToken());<span class="hljs-comment">//开启定制化CSRF</span><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyCrsToken <span class="hljs-title function_">myCrsToken</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCrsToken</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）CORS"><a href="#（3）CORS" class="headerlink" title="（3）CORS"></a>（3）CORS</h4><blockquote><ul><li>CORS：浏览器为了安全，当我们从域名”a.com“发起请求，浏览器不允许我们访问”api.a.com“；</li><li>跨域问题仅仅只是浏览器问题，当浏览器进行跨域请求时，会和服务端进行一次握手，响应后可以获得如下参数：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定哪些客户端的域名允许访问这个资源</span><br>Access-Control-Allow-Origin <br><span class="hljs-comment">//服务器支持的 HTTP 方法</span><br>Access-Control-Allow-Methods <br><span class="hljs-comment">//需要在正式请求中加入的 HTTP 消息头</span><br>Access-Control-Allow-Headers <br><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//配置中设置跨域</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringSecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.cors(c -&gt; &#123;<br>            <span class="hljs-type">CorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> request -&gt; &#123;<br>                <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>                config.setAllowedOrigins(Arrays.asList(<span class="hljs-string">&quot;*&quot;</span>));<span class="hljs-comment">//允许所有请求跨域</span><br>                config.setAllowedMethods(Arrays.asList(<span class="hljs-string">&quot;*&quot;</span>));<br>                <span class="hljs-keyword">return</span> config;<br><br>            &#125;;<br>            c.configurationSource(source);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、OAuth2协议"><a href="#6、OAuth2协议" class="headerlink" title="6、OAuth2协议"></a>6、OAuth2协议</h3><h4 id="（1）应用场景"><a href="#（1）应用场景" class="headerlink" title="（1）应用场景"></a>（1）应用场景</h4><blockquote><ul><li>OAuth2解决的是授权问题，不解决认证问题；</li><li>OAuth2中，用户信息由用户自己保管，授权具有明确的范围和期限；</li><li>用户修改了密码信息，只需要重新授权即可，不会影响第三方应用程序</li></ul></blockquote><h4 id="（2）协议角色"><a href="#（2）协议角色" class="headerlink" title="（2）协议角色"></a>（2）协议角色</h4><blockquote><ul><li><p>资源：需要访问的接口或服务就是资源，每个资源都有一个拥有者，即图中的用户；</p></li><li><p>客户端：需要访问其他服务的第三方服务，即途中的工单系统，需要访问订单系统；</p></li><li><p>授权服务器：用户授权后，颁发一个token；</p></li><li><p>资源服务器：存储用户资源</p><img src="/2023/05/11/SpringSecurity/12.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（3）OAuth2的Token"><a href="#（3）OAuth2的Token" class="headerlink" title="（3）OAuth2的Token"></a>（3）OAuth2的Token</h4><blockquote><ul><li>token是用户的身份凭证，具有资源的访问权限和有效期；</li><li>access_token：代表OAuth2的令牌，用户访问资源时需要携带该令牌，以便校验是否可以访问；</li><li>token_type：token类型，bearer类型最为常用，请求中的请求头携带Authorization头部字段，值为bearer<token>，客户端不需要提供额外的凭据和签名，服务器主要通过该令牌进行身份校验；</li><li>refresh_token：在access_token过期后，颁发的下一个令牌；</li><li>expires_in：token过期时间；</li><li>scope：指定可以访问权限；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Token格式</span><br>&#123;<br>    <span class="hljs-string">&quot;access_token&quot;</span>: <span class="hljs-string">&quot;0efa61be-32ab-4351-9dga-8ab668ababae&quot;</span>,<br>    <span class="hljs-string">&quot;token_type&quot;</span>: <span class="hljs-string">&quot;bearer&quot;</span>,<br>    <span class="hljs-string">&quot;refresh_token&quot;</span>: <span class="hljs-string">&quot;738c42f6-79a6-457d-8d5a-f9eab0c7cc5e&quot;</span>,<br>    <span class="hljs-string">&quot;expires_in&quot;</span>: <span class="hljs-number">10000</span>,<br>    <span class="hljs-string">&quot;scope&quot;</span>: <span class="hljs-string">&quot;webclient&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>令牌授权模式：</strong></p><blockquote><ul><li><p>客户端向用户请求授权，请求中包括请求资源路径；</p></li><li><p>用户同意请求，将权限返回给客户端，客户端获取用户授权信息；</p></li><li><p>客户端向授权服务器请求令牌，授权服务器颁发令牌给客户端；</p></li><li><p>客户端携带令牌访问资源服务器，资源服务器校验令牌的权限以及有效期，并向客户端开放权限；</p><img src="/2023/05/11/SpringSecurity/13.jpg" class="" title="SpringSecurity"></li></ul></blockquote><h4 id="（4）OAuth2授权模式"><a href="#（4）OAuth2授权模式" class="headerlink" title="（4）OAuth2授权模式"></a>（4）OAuth2授权模式</h4><h5 id="①授权码模式"><a href="#①授权码模式" class="headerlink" title="①授权码模式"></a>①授权码模式</h5><blockquote><ul><li>用户访问客户端，客户端将请求导向授权服务器；</li><li>此时用户可以选择是否同意授权，若用户同意授权，授权服务器会调用客户端提供回调地址，并携带授权码返回客户端；</li><li>客户端收到授权码后，向授权服务器申请令牌，授权服务器向客户端发放令牌；</li></ul><p><strong>通过授权码向授权服务器申请令牌由系统自动完成，不需要用户完成，用户只需决定是否同意授权；</strong></p><img src="/2023/05/11/SpringSecurity/14.jpg" class="" title="SpringSecurity"></blockquote><h5 id="②密码模式"><a href="#②密码模式" class="headerlink" title="②密码模式"></a>②密码模式</h5><blockquote><ul><li><p>用户提供密码和用户名，访问客户端；</p></li><li><p>客户端基于用户信息向授权服务器申请令牌，授权服务器执行用户认证后会颁发令牌；</p><img src="/2023/05/11/SpringSecurity/15.jpg" class="" title="SpringSecurity"></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2023/04/10/Netty/"/>
    <url>/2023/04/10/Netty/</url>
    
    <content type="html"><![CDATA[<h3 id="1、I-x2F-O模型"><a href="#1、I-x2F-O模型" class="headerlink" title="1、I&#x2F;O模型"></a>1、I&#x2F;O模型</h3><h4 id="（1）同步阻塞I-x2F-O（BIO）"><a href="#（1）同步阻塞I-x2F-O（BIO）" class="headerlink" title="（1）同步阻塞I&#x2F;O（BIO）"></a>（1）同步阻塞I&#x2F;O（BIO）</h4><blockquote><ol><li><p>应用进程向内核发起I&#x2F;O请求，发起调用后一直等待内核数据返回；</p></li><li><p>一次请求对应一个线程，创建过多线程会增加线程切换开销；</p></li><li><p>BIO在异步操作下，只能使用多线程模型；</p><img src="/2023/04/10/Netty/1.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（2）同步非阻塞（NIO）"><a href="#（2）同步非阻塞（NIO）" class="headerlink" title="（2）同步非阻塞（NIO）"></a>（2）同步非阻塞（NIO）</h4><blockquote><ol><li><p>应用进程向内核发起请求后，不会同步等待结果，而是立即返回，通过轮询获取请求结果；</p></li><li><p>轮询过程中会导致大量的性能开销，单独使用NIO性能不高；</p></li><li><p>并发量大的情况下，存在严重的IO性能浪费；</p><img src="/2023/04/10/Netty/2.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（3）IO多路复用"><a href="#（3）IO多路复用" class="headerlink" title="（3）IO多路复用"></a>（3）IO多路复用</h4><blockquote><ol><li><p>多路指多个数据通道，一个或多个固定线程来处理每一个socket链接；</p></li><li><p>线程一次select可以获取内核中多个数据通道的数据状态；</p><img src="/2023/04/10/Netty/3.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（4）异步IO（AIO）"><a href="#（4）异步IO（AIO）" class="headerlink" title="（4）异步IO（AIO）"></a>（4）异步IO（AIO）</h4><blockquote><p>由内核缓冲区拷贝到用户缓冲区是由系统异步完成的，应用进程只需在指定的数组中引用数据即可；</p><img src="/2023/04/10/Netty/4.jpg" class="" title="Netty"></blockquote><h4 id="（5）Netty-IO模型"><a href="#（5）Netty-IO模型" class="headerlink" title="（5）Netty IO模型"></a>（5）Netty IO模型</h4><blockquote><ol><li><p>所有I&#x2F;O事件都注册到一个Selector上，当I&#x2F;O事件就绪后，有一个事件分发处理器，负责将读写请求分发给对应的读写事件处理器；</p></li><li><p>该线程模型避免了同步问题和线程切换带来的开销问题，实现高性能，低延迟；</p></li><li><p>可定制化线程模型，可扩展事件驱动模型；</p><img src="/2023/04/10/Netty/5.jpg" class="" title="Netty"></li></ol></blockquote><h3 id="2、Netty逻辑架构"><a href="#2、Netty逻辑架构" class="headerlink" title="2、Netty逻辑架构"></a>2、Netty逻辑架构</h3><img src="/2023/04/10/Netty/6.jpg" class="" title="Netty"><h4 id="（1）网络通信层"><a href="#（1）网络通信层" class="headerlink" title="（1）网络通信层"></a>（1）网络通信层</h4><blockquote><ul><li>网络通信层支持多种网络协议和I&#x2F;O操作连接，当网络数据读取到内核缓冲区后，会触发各种网络事件，网络事件会分发事件调度层处理；</li><li>三大核心组件为Bootstrap、ServerBootstrap、Channel；</li><li>Bootstrap用于客户端启动引导，可用户连接远端服务器，只绑定一个EventLoopGroup；</li><li>ServerBootstrap用于服务端启动引导，绑定本地端口，绑定两个EventLoopGroup，一个用于接收请求转发，另一个用于请求事件处理；</li><li>Channel为网络通信的载体，channel有多种状态，如连接建立、连接注册、数据读写、连接销毁，随着状态变化，Channel处于不同的生命周期，会绑定不同的回调事件；</li></ul></blockquote><h4 id="（2）事件调度层"><a href="#（2）事件调度层" class="headerlink" title="（2）事件调度层"></a>（2）事件调度层</h4><blockquote><ul><li>通过Reactor线程模型对各类事件进行聚合处理，通过Selector主循环线程集成多种事件，实际相关业务由服务编排层中相应的Handler进行处理；</li><li>事件调度层核心组件为EventLoopGroup和EventLoop，EventLoopGroup本质是一个线程池，负责接收I&#x2F;O请求，并分配线程执行请求；</li><li>EventLoop、EventLoopGroup、Channel关系：</li></ul><ol><li><ol><li><p>一个EvntLoopGroup中包含多个EventLoop，EventLoop负责处理Channel生命周期内所有的I&#x2F;O事件；</p></li><li><p>EventLoop同一时间会绑定一个线程，负责处理多个Channel；</p></li><li><p>每一个新建的Channel，EventLoopGroup会选择一个EventLoop与其绑定，Channel生命周期内可以多次对EventLoop进行解绑和绑定；</p><img src="/2023/04/10/Netty/7.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><h4 id="（3）服务编排层"><a href="#（3）服务编排层" class="headerlink" title="（3）服务编排层"></a>（3）服务编排层</h4><blockquote><ul><li>负责组装各类服务，是Netty的核心处理链，用于实现网络的动态编排和有序传播；</li><li>ChannelPipeline</li></ul><ol><li><ol><li><p>负责组装各类ChannelHandler，实际数据的编码以及数据加工处理都是由ChannelHandler执行的；</p></li><li><p>是ChannelHandler实例列表，通过双向链表将不同ChannelHandler连接起来，当I&#x2F;O事件触发时，ChannelPipeline会依次调用ChannelHandler列表对Channel数据依次处理；</p></li><li><p>ChannelPipeline是线程安全的，<strong>一个EventLoop对应一个Channel</strong>，一个EventLoop绑定一个线程；</p></li><li><p>ChannelPipeline包含入站ChannelInboundHandler和出站ChannelOutboundHandler处理器，服务端和客户端依次完整的数据请求响应：客户端出战（请求数据）-&gt;服务端入站（服务端业务处理）-&gt;服务端出站（响应结果）；</p><img src="/2023/04/10/Netty/8.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><blockquote><ul><li>ChannelHandler和ChannelHandlerContext：</li></ul><ol><li><ol><li><p>每创建一个Channel，会绑定一个CHannelPipeline；</p></li><li><p>ChannelPipeline每加入一个ChannelHandler都会绑定一个ChannelHandlerContext；</p></li><li><p>ChannelHandlerContext保存了ChannelHandler上下文（即运行环境），ChannelHandlerContext包含ChannelHandler生命周期所有事件（减少代码冗余）；</p><img src="/2023/04/10/Netty/9.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><h4 id="（4）组件协作协作流程"><a href="#（4）组件协作协作流程" class="headerlink" title="（4）组件协作协作流程"></a>（4）组件协作协作流程</h4><blockquote><ol><li><p>服务启动时，创建Boss EventLoopGroup和Work EventLoopGroup，Boss负责监听网络事件，当有连接到达时，会将channel注册到work中；</p></li><li><p>work分配一个EventLoop负责处理Channel读写事件，每隔EventLoop是单线程，通过selector进行事件循环；</p></li><li><p>当客户端发起I&#x2F;O读写事件时，EventLoop会读取客户端数据，然后通过pipeLine触发各种监听器进行数据处理；</p></li><li><p>客户端数据被传入到ChannelPipeline的第一个ChannelInBoundHandler进行处理，然后传递给下一个；</p></li><li><p>服务端响应数据，通过ChannelOutBoundHandler传播，最终到达客户端；</p><img src="/2023/04/10/Netty/10.jpg" class="" title="Netty"></li></ol></blockquote><h3 id="3、Netty启动流程"><a href="#3、Netty启动流程" class="headerlink" title="3、Netty启动流程"></a>3、Netty启动流程</h3><h4 id="（1）配置线程池"><a href="#（1）配置线程池" class="headerlink" title="（1）配置线程池"></a>（1）配置线程池</h4><blockquote><ul><li>单线程模式：配置时，指定NioEventLoopGroup参数为1，只有一个线程完成；</li><li>多线程模型：采用多个线程处理请求，NioEventLoopGroup参数不指定，线程数默认为CPU核数*2；</li><li>主从多线程模型：采用两个NioEventLoopGroup，主Reactor负责接收请求，将Channel主从到从Reactor中，从Reactor负责处理Channel生命周期内的所有I&#x2F;O事件；</li></ul></blockquote><h4 id="（2）Channel初始化"><a href="#（2）Channel初始化" class="headerlink" title="（2）Channel初始化"></a>（2）Channel初始化</h4><blockquote><ul><li>设置Channel类型，服务端推荐NioServerSocketChannel；</li><li>注册ChannelHandler，通过设置ServerBootstrap的childHandler参数。ChannelInitalizer是实现ChannelHandler的内部匿名类，主要用于初始化和注册各ChannelHandler；</li><li>设置Channel参数，option和childOption，option参数设置Boss线程组，childOption设置Worker线程组，具体设置参数如下：</li></ul></blockquote><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>SO_KEEPALIVE</td><td>TCP主动探测状态，连接保活</td></tr><tr><td>SO_BACKLOG</td><td>已完成三次握手的最大长度，同一时刻可能处理多个连接，歌颂并发下该参数应该调大</td></tr><tr><td>CONNECT_TIMEOUT_MILLIS</td><td>建立连接的超时时间</td></tr></tbody></table><h4 id="（3）端口绑定"><a href="#（3）端口绑定" class="headerlink" title="（3）端口绑定"></a>（3）端口绑定</h4><blockquote><p>serverGroup.bind(端口).sync()，bind真正触发启动，sync会阻塞，直至整个启动完成；</p></blockquote><h3 id="4、EventLoop"><a href="#4、EventLoop" class="headerlink" title="4、EventLoop"></a>4、EventLoop</h3><blockquote><ul><li><p>是一种事件等待和处理的模型，可以解决多线程资源消耗高的问题；</p></li><li><p>事件发生时，应用程序会将事件放入到事件队列中，EventLoop会进行轮询，取出已经准备好的事件并分发给对应的事件处理器处理，事件分为：立即执行，延迟执行和定期执行；</p></li><li><p>每个EventLoop都维护一个Selector选择器和任务队列taskQueue，主要负责处理处理I&#x2F;O事件，普通任务，定时任务；</p><img src="/2023/04/10/Netty/11.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（1）事件处理机制"><a href="#（1）事件处理机制" class="headerlink" title="（1）事件处理机制"></a>（1）事件处理机制</h4><blockquote><ul><li><p>NioEventLoop事件处理机制采用无锁串行化，保证线程安全；</p></li><li><p>BossEventLoopGroup和WorkEventGroup包含多个NipEventLoop；</p></li><li><p>Boss负责监听客户端连接事件，一旦连接建立，Boss将channel注册到Work中的一个NioEventLoop，channel生命周期所有事件处理是线程独立的；</p></li><li><p>NioEventLoop读取完数据后，会调用绑定的ChannelPipelie，ChannelPIpeline是串行化执行，不会发生线程上下文切换，所以是线程安全的；</p></li><li><p>NioEventLoop不能执行事件过长的I&#x2F;O事件，一旦I&#x2F;O阻塞，会阻塞后面所有I&#x2F;O，造成事件积压；</p><img src="/2023/04/10/Netty/12.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）任务处理机制"><a href="#（2）任务处理机制" class="headerlink" title="（2）任务处理机制"></a>（2）任务处理机制</h4><blockquote><ol><li>普通任务：通过NioEvenLoop的execute（）方法，向任务队列taskQueue中添加任务，任务队列是FIFO。taskQueue是多生产者单消费者，在多线程下可以保证线程安全；</li><li>定时任务：通过NIoEventLoop的schduled（）方法，向定时任务队列SchduledQueue添加任务，任务队列是优先队列，用于周期性执行，如心跳检查机制；</li><li>尾部队列：相比普通队列，优先级较低，每次执行完taskQueue后，会取出taskQueue最后一个任务执行，该任务主要是负责收尾工作，如：监控信息上报等；</li></ol></blockquote><h4 id="（3）最佳实践"><a href="#（3）最佳实践" class="headerlink" title="（3）最佳实践"></a>（3）最佳实践</h4><blockquote><ol><li>网络连接建立三次握手比较耗费时间，采用Boos和Work可以，有助于缓解Reactor压力；</li><li>I&#x2F;O事件处理时间较长的，采用线程池进行异步处理，防止阻塞后边I&#x2F;O事件；</li><li>不要设计过多ChannelHandler；</li></ol></blockquote><h3 id="5、ChannelPipeline"><a href="#5、ChannelPipeline" class="headerlink" title="5、ChannelPipeline"></a>5、ChannelPipeline</h3><blockquote><ul><li><p>ChannelPipeline是ChannelHandler的容器载体，内部通过双向链表将ChannelHandler关联在一起；</p></li><li><p>当有IO读写时，会依次调用ChannelHandler对Channel拦截，进行数据处理；</p></li><li><p>一个Channel对应一个ChannelPipeline，一个ChannelPIpeline对应多个ChannelHandler；</p></li><li><p>ChannelHandlerContext保存了ChannelHandler的上下文（运行环境），同时包含了ChannelHandler的生命周期所有事件，如connect，bind等（减少2代码冗余，不用每一个ChannelHandler都写重复写conncet等生命周期事件）；</p><img src="/2023/04/10/Netty/13.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（1）ChannelPipeline链表结构"><a href="#（1）ChannelPipeline链表结构" class="headerlink" title="（1）ChannelPipeline链表结构"></a>（1）ChannelPipeline链表结构</h4><blockquote><ul><li><p>HeadContext既是Inboud处理器，又是Outbound处理器，网络操作数据的入口是HeadContext，进行Inbound事件传播。数据处理完后，会反方向经过Outbound处理器，最终到达HeadContext，即OutBound最后一站；HeadContext还会进行一些事件前置处理</p></li><li><p>TailContext是Outbound处理器，inbound事件的终止，将outbound事件传给上一站；</p></li><li><p>事件触发可以在中间的ChannelHandlerContext触发，事件执行不一定会从头到尾，提高程序性能；</p><img src="/2023/04/10/Netty/14.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）ChannelHandler事件传播机制"><a href="#（2）ChannelHandler事件传播机制" class="headerlink" title="（2）ChannelHandler事件传播机制"></a>（2）ChannelHandler事件传播机制</h4><blockquote><ul><li>inbound传播方向是从headContext-&gt;tailContext，客户端向服务端发送请求时，，会触发Inbound事件ChannelRead（）方法，最终调用writeAndFlush（）方法向客户端写回数据；</li><li>outbound传播方向是从tailContext-&gt;headContext，服务端写回数据时，会触发outbound事件的write()方法；</li></ul></blockquote><h4 id="（3）异常传播机制"><a href="#（3）异常传播机制" class="headerlink" title="（3）异常传播机制"></a>（3）异常传播机制</h4><blockquote><ul><li><p>发送异常时，若用户没有进行处理，最终会从Head传播到Tail，由tail进行处理；</p></li><li><p>处理异常的最好方法是，自定义处理器的末端加上统一异常处理器；</p><img src="/2023/04/10/Netty/15.jpg" class="" title="Netty"></li></ul></blockquote><h3 id="6、解码器"><a href="#6、解码器" class="headerlink" title="6、解码器"></a>6、解码器</h3><h4 id="（1）粘包和拆包"><a href="#（1）粘包和拆包" class="headerlink" title="（1）粘包和拆包"></a>（1）粘包和拆包</h4><blockquote><ul><li><p>MTU：链路层一次传输数据的最大单元，默认1500字节；</p></li><li><p>MSS：传输层一次传输数据的最大单元，即TCP报文；</p></li><li><p>MTU&lt;MSS+TCP首部+IP首部，就会进行拆包；</p></li><li><p>一次传输的数据单元过小，会进行批量发送；</p></li><li><p>TCP是面向流的，没有数据边界，客户端发送数据时，可能是拆分为多个包，，或者合并为一个包进行发送，接收方不知道数据的边界，无法得到有效数据；</p><img src="/2023/04/10/Netty/23.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li>滑动窗口：数据接收方设置的窗口大小，每次都会告知发送方自己的窗口大小，限制发送方发送数据的大小；数据发送不会每一个报文都回复ACK，是一段进行回复的，如发送A，B，C，报文A丢失，B，C到达，此时B，C报文会丢掉，当A，B，C都到达时，回复一个ACK；</li><li>Nagle算法：批量发送，发送数据时，数据还未确认，会先写入到缓冲区中，等到数据确认了或达到一定长度后就发送数据包，发送的数据会有一定的延迟性；</li></ul></blockquote><h4 id="（2）固定长度解码器FixedLengthFrameDecoder"><a href="#（2）固定长度解码器FixedLengthFrameDecoder" class="headerlink" title="（2）固定长度解码器FixedLengthFrameDecoder"></a>（2）固定长度解码器FixedLengthFrameDecoder</h4><blockquote><p>指定固定长度，无论接收方依次获取多大长度，都会按照指定长度进行解码</p></blockquote><h4 id="（3）特殊分割符解码器（DelimiterBasedFrameDecoder）"><a href="#（3）特殊分割符解码器（DelimiterBasedFrameDecoder）" class="headerlink" title="（3）特殊分割符解码器（DelimiterBasedFrameDecoder）"></a>（3）特殊分割符解码器（DelimiterBasedFrameDecoder）</h4><blockquote><ul><li>delimiter：指定分割符，可以同时指定多个分隔符，但最终只会选择最短的分隔符进行分割，如下：</li></ul><p>​      字符串：abc\njhg\n\r，指定分割符：\n,\n\r，最终字符：【abc,jhg】</p><ul><li>maxFrameLength：指定最大长度，若超过最大长度还没有进行字符分割，会抛出异常；</li><li>failFast：true，再超出maxFrameLength时，直接抛出异常否则等到解码出一个完整字符后，才抛出异常；</li><li>stripDelimiter：true为取出风格符，不加入编码，false加入编码</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DelimiterBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maxFrameLength, <span class="hljs-type">boolean</span> stripDelimiter, <span class="hljs-type">boolean</span> failFast,</span><br><span class="hljs-params">            ByteBuf delimiter)</span>&#123;.....&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）长度域解码器LengthFielBasedFrameDecoder"><a href="#（4）长度域解码器LengthFielBasedFrameDecoder" class="headerlink" title="（4）长度域解码器LengthFielBasedFrameDecoder"></a>（4）长度域解码器LengthFielBasedFrameDecoder</h4><blockquote><ul><li>长度域解码器是解决粘包&#x2F;拆包最常用的解码器；</li><li>基于消息长度+消息内容解码：报文消息只有长度字段和具体消息，长度字段占两个字节，length中的0x000c表示Content占用12字节；</li></ul><img src="/2023/04/10/Netty/16.jpg" class="" title="Netty"><ul><li>解码结果需要截断：解码的结果只保留内容，将长度去除；</li></ul><img src="/2023/04/10/Netty/17.jpg" class="" title="Netty"><ul><li>长度包括消息长度和消息内容长度：length长度包含了length存储长度+消息内容长度（2+14），需要将length长度修正-2，才可以得消息内容的真正长度；</li></ul><img src="/2023/04/10/Netty/18.jpg" class="" title="Netty"><ul><li>基于长度字段的偏移：头部除了长度，还有header数据，所以length长度需要跳过Header 2字节，才是length的开始地址；</li></ul><img src="/2023/04/10/Netty/19.jpg" class="" title="Netty"><ul><li>长度字段与内容字段的长度不相邻：length字段记录的长度不会记录Header长度，</li></ul><p>​       length（2字节）+lengthFieldLength（12字节）&#x3D;Header1+Content（14字节）</p><img src="/2023/04/10/Netty/20.jpg" class="" title="Netty"><ul><li>基于长度偏移和长度修正解码：长度length的开始位置需要跳过HDR1，length的长度需要加上HDR2才能表示后面字段长度，结果需要跳过HDR1（1字节）+Length（2字节）&#x3D;3字节；</li></ul><img src="/2023/04/10/Netty/21.jpg" class="" title="Netty"><ul><li><p>长度字段包含所有字段长度解码：HDR2+Context长度需要减去length长度和HDR1长度</p><p>Length（16字节）&#x3D;HDR1（1字节）+Length（2字节）+HDR2（1字节）+Context（12字节）</p></li></ul><img src="/2023/04/10/Netty/22.jpg" class="" title="Netty"></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxFrameLength;<span class="hljs-comment">//最大限制长度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldOffset;<span class="hljs-comment">//长度字段的偏移地址，即存放长度数据的开始地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldLength;<span class="hljs-comment">//长度字段占用的地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldEndOffset;<span class="hljs-comment">//长度字段结束的偏移地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthAdjustment;<span class="hljs-comment">//消息体的长度修正值</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> initialBytesToStrip;<span class="hljs-comment">//消息体的开始地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> failFast;<span class="hljs-comment">//结合maxFrameLength使用，判断是否需要立即抛出异常</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> discardingTooLongFrame;<span class="hljs-comment">//是否处于丢弃模式</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> tooLongFrameLength;<span class="hljs-comment">//需要丢弃的字节数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> bytesToDiscard;<span class="hljs-comment">//累计丢弃的字节数</span><br></code></pre></td></tr></table></figure><h3 id="7、writeAndFlush"><a href="#7、writeAndFlush" class="headerlink" title="7、writeAndFlush"></a>7、writeAndFlush</h3><blockquote><ul><li>write只是将数据写入ChannelOutBoundBuffer中，并没有写入socket缓冲区中，buffer是链表结构存储；</li><li>flush最终将数据写入到socket缓冲区；</li></ul></blockquote><h4 id="（1）writeAndFlush源码分析"><a href="#（1）writeAndFlush源码分析" class="headerlink" title="（1）writeAndFlush源码分析"></a>（1）writeAndFlush源码分析</h4><blockquote><ul><li>findContextOutBound：寻找下一个ChannelHandler（双向链表结构，直接获取prev指针即可获取到）；</li><li>inEventLoop：判断当前的线程和EventLoop分配给channel的线程是否一样，一样的化继续立即执行，不一样，如果不一样，则是将任务加入到任务队列中；</li><li>invokeWritAndFlush：执行下一个ChannelHandler中的write方法，即我们自定义的handler处理器中的write方法，需要继续传递给下一个执行器执行，需要调用父类write方法，最终依旧调用以下write方法；</li><li>从tail开始调用，一次往前执行到head；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>代码忽略<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(flush ?<br>                                                                   (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pipeline.touch(msg, next);<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            next.invokeWriteAndFlush(m, promise);<span class="hljs-comment">//执行write</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    代码忽略<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeWriteAndFlush</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>            invokeWrite0(msg, promise);<span class="hljs-comment">//write</span><br>            invokeFlush0();<span class="hljs-comment">//flush</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            writeAndFlush(msg, promise);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）写Buffer队列："><a href="#（2）写Buffer队列：" class="headerlink" title="（2）写Buffer队列："></a>（2）写Buffer队列：</h4><blockquote><ul><li>所有数据写完，最终到head节点，由head节点将数据写给客户端；</li><li>filterOutboundMessage(msg)：判断msg类型是否DirectByteBuff，不是进行转换为DirectByteBuff；</li><li>addMessage(msg, size, promise)：往buffer中添加数据；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//HeadContext</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>    assertEventLoop();<br>    <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">try</span> &#123;<br>        msg = filterOutboundMessage(msg);<span class="hljs-comment">//过滤消息</span><br>        <span class="hljs-comment">//代码忽略。。。。。。。。。。。。</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       <span class="hljs-comment">//代码忽略。。。。。。。。。。。。</span><br>    &#125;<br>    outboundBuffer.addMessage(msg, size, promise);<span class="hljs-comment">//buffer中添加数据</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Buffer：</strong></p><ul><li><p>一个链表结构，消息会被封装为Entry对象，添加到链表中；</p></li><li><p>flushedEntry：第一个写入缓冲区指针；</p></li><li><p>unflushedEntry：第一个未写入缓冲区的指针；</p></li><li><p>tailEntry：最后一个未写入缓冲区的指针；</p><img src="/2023/04/10/Netty/24.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li>每次写都会累加字节数，判断是否超过64字节，超过则设置为不可写状态，直到恢复为32字节以下，才可以继续写</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMessage</span><span class="hljs-params">(Object msg, <span class="hljs-type">int</span> size, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.newInstance(msg, size, total(msg), promise);<br>    <span class="hljs-keyword">if</span> (tailEntry == <span class="hljs-literal">null</span>) &#123;<br>        flushedEntry = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> tailEntry;<br>        tail.next = entry;<br>    &#125;<br>    tailEntry = entry;<br>    <span class="hljs-keyword">if</span> (unflushedEntry == <span class="hljs-literal">null</span>) &#123;<br>        unflushedEntry = entry;<br>    &#125;<br>    incrementPendingOutboundBytes(entry.pendingSize, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> invokeLater)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">newWriteBufferSize</span> <span class="hljs-operator">=</span> TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-built_in">this</span>, size);<br>    <span class="hljs-keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;<br>        setUnwritable(invokeLater);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）刷新Buffer队列"><a href="#（3）刷新Buffer队列" class="headerlink" title="（3）刷新Buffer队列"></a>（3）刷新Buffer队列</h4><blockquote><ul><li><p>add Flush（）：将unflushedEntry指向的数据写入到flushEntry指针处，flushedEntry指针指向的数据为真正发送到socket缓冲区的数据</p></li><li><p>decrementPendingOutboundBytes：减去待发送的数据，待发送数据总字节数小于规定值，恢复为可写状态；</p><img src="/2023/04/10/Netty/25.jpg" class="" title="Netty"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFlush</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> unflushedEntry;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (flushedEntry == <span class="hljs-literal">null</span>) &#123;<br>            flushedEntry = entry;<br>        &#125;<br>        <span class="hljs-keyword">do</span> &#123;<br>            flushed ++;<br>            <span class="hljs-keyword">if</span> (!entry.promise.setUncancellable()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pending</span> <span class="hljs-operator">=</span> entry.cancel();<br>                <span class="hljs-comment">//减去即将刷新数据，总字节数低，则设置为可写状态</span><br>                decrementPendingOutboundBytes(pending, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>            &#125;<br>            entry = entry.next;<br>        &#125; <span class="hljs-keyword">while</span> (entry != <span class="hljs-literal">null</span>);<br>        unflushedEntry = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>flush0：</strong></p><ul><li>getWriteSpinCount（）:获取最大自旋数（16），当数据过大时，需要分批写入，而写入过程太长的化，EventLoop线程会一直处于等待状态，可能会阻塞后面请求，所以当自旋数为0时，写会被暂时中断；</li><li>doWriteInternal(in, msg)：发送数据，每发送一次，自旋数减1；</li><li>incompleteWrite（）：确保数据全部发送完毕，数据没有写完，注册OP_WRITE事件；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">writeSpinCount</span> <span class="hljs-operator">=</span> config().getWriteSpinCount();<span class="hljs-comment">//获取自旋最大数（）</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> in.current();<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            clearOpWrite();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        writeSpinCount -= doWriteInternal(in, msg);<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Netty堆外内存"><a href="#8、Netty堆外内存" class="headerlink" title="8、Netty堆外内存"></a>8、Netty堆外内存</h3><h4 id="（1）堆外内存与堆内内存区别"><a href="#（1）堆外内存与堆内内存区别" class="headerlink" title="（1）堆外内存与堆内内存区别"></a>（1）堆外内存与堆内内存区别</h4><blockquote><ul><li><p>堆内内存由JVM管理，GC回收内存会耗费一定的时间；堆外内存不受JVM管理，可以降低GC回收内存对应用运行带来的影响；</p></li><li><p>堆外内存需要手动释放内存，不释放会造成内存泄漏；</p></li><li><p>堆内内存需要IO读写时，需要将堆内内存转换位堆外内存，才可以与底层设备交互，堆外内存可以减少一次内存拷贝；</p></li><li><p>堆外内存可以实现进程间，JVM多实例间数据共享；</p><img src="/2023/04/10/Netty/26.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）堆外内存分配"><a href="#（2）堆外内存分配" class="headerlink" title="（2）堆外内存分配"></a>（2）堆外内存分配</h4><blockquote><ul><li><p>ByteBuffer.allocateDirect（）：通过directByteBuffer（堆内内存中）分配的内存，directByteBuffer存储堆外内存的地址，大小等属性，当directByteBuffer被JVM回收时，Cleaner对象会回收堆外内存；</p></li><li><p>unsafe.allocateMemory（）：directByteBuffer调用该方法进行堆外内存分配，该方法分配堆外内存后，需要手动释放，不然会造成内存泄漏；</p><img src="/2023/04/10/Netty/27.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（3）堆外内存回收"><a href="#（3）堆外内存回收" class="headerlink" title="（3）堆外内存回收"></a>（3）堆外内存回收</h4><blockquote><ul><li><p>DirectByteBuffer分配内存时，会创建Cleaner对象，Cleaner对象是虚引用，双向链表结构；</p></li><li><p>当堆内DirectByteBuffer被回收后，等到下一次GC回收，会将Cleaner对象添加到ReferneceQueue，并执行Cleaner中的clean方法；</p></li><li><p>clean方法主要执行将Cleaner对象从双向链表中移除，以及调用unsafe.freeMemory释放堆外内存；</p><img src="/2023/04/10/Netty/28.jpg" class="" title="Netty"></li></ul></blockquote><h3 id="9、ByteBuf"><a href="#9、ByteBuf" class="headerlink" title="9、ByteBuf"></a>9、ByteBuf</h3><h4 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h4><blockquote><ul><li><p>readIndex：读取位置的开始指针，读取n个字节，readIndex+n，readIndex等于writeIndex时，表示无字节，则不能进行读；</p></li><li><p>writeIndex：写入位置的开始指针，写入n个指针，writeIndex加n个位置，当writeIndex等于capacity时，需要进行扩容；</p></li><li><p>capacity：ByteBuf容量，当writeIndex&#x3D;&#x3D;capacity时，进行扩容；</p></li><li><p>maxCapacity：最大容量，表示扩容后容量不能超过maxCapacity，超过该容量再写入就会报错；</p><img src="/2023/04/10/Netty/29.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）引用计数"><a href="#（2）引用计数" class="headerlink" title="（2）引用计数"></a>（2）引用计数</h4><blockquote><ul><li>创建一个ByteBuf时，引用计数器为1，当调用ByteBuf.release（）后，引用计数器为0；</li><li>当ByteBuf引用计数器为0时，会将ByteBuf放入对象池，可以直接使用，避免重复创建ByteBuf；</li><li>可以用来做内存泄漏检测工具，当ByteBuf不可达时，JVM会回收ByteBuf，通过判断ByteBuf是否不可达且引用计数器大于0，判断内存泄漏的位置；</li></ul></blockquote><h4 id="（3）ByteBuf分类"><a href="#（3）ByteBuf分类" class="headerlink" title="（3）ByteBuf分类"></a>（3）ByteBuf分类</h4><blockquote><ul><li>Heap&#x2F;Direct：Heap指JVM堆内分配内存，底层依赖字节数据，Direct指堆外内存，不受JVM限制，由ByteBuffer进行内存分配；</li><li>Pooled&#x2F;UnPooled：Pooled指从预先分配好的内存取出，用完放回，等待下一次分配，UnPooled则是每次都是系统调用申请内存，确保能够被JVM的GC回收；</li><li>Unsafe&#x2F;非Unsafe：Unsafe是利用offset+index进行操作，非Unsafe则是利用数组，直接操作下标；</li></ul></blockquote><h3 id="10、内存管理"><a href="#10、内存管理" class="headerlink" title="10、内存管理"></a>10、内存管理</h3><h4 id="（1）内存规格"><a href="#（1）内存规格" class="headerlink" title="（1）内存规格"></a>（1）内存规格</h4><blockquote><ul><li>Chunk：为Netty向操作系统申请内存的基本单位，所有内存分配是基于Chunk来实现的，Chunk是页的集合，每个Chunk大小为16M</li><li>Page：是Chunk用于管理内存的基本单位，大小为8k；</li><li>Subpage：分配的空间远小于Page时，会将Page划分为多个相同的子块进行分配大小不固定，根据用户分配的缓冲区大小决定，如：分配1k的内存，Page会划分为8个Subpage；</li><li>tiny：16-496B，small：512-4096B，normal：8k-16M，hug：&gt;16M</li></ul></blockquote><h4 id="（2）Netty内存池架构"><a href="#（2）Netty内存池架构" class="headerlink" title="（2）Netty内存池架构"></a>（2）Netty内存池架构</h4><blockquote><ul><li><p>PoolArean:</p></li><li><ul><li>tinySubpagePools数组：用于分配tiny规格内存大小；smallSubpagePools数组：用于分配small规格内存大小，如分配20B大小空间，也会向上取整32B；</li><li>PoolChunkList：一共六种不同内存使用率的PoolChunkList，之间通过双向链表组合，每次会检查每个chunk内存使用率，并放入对应的位置；qInit内存被完全释放也不会回收，避免chunk重复初始化；</li><li>Chunk：内存真正存储数据地方，每个chunk大小16M，page的集合，会有内存使用上限和下限，当内存分配后大于上限，会将Chunk从当前PoolChunkList移除，添加到下一个PoolChunkList，下限同理；</li></ul></li><li><p>PoolThreadCache：当内存释放时，Netty并不会将缓存归还给chunk，而是下一次使用时，直接取出用即可；内部有MemoryRegionCache，本质是一个队列，分别存放tiny，small，normal三种规格的数据；</p><img src="/2023/04/10/Netty/30.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li><p>PoolSubpage：</p></li><li><ul><li><p>通过bitmap记录是否被访问过；</p></li><li><p>分配小内存时，会先去tinySubpagePools或smallSubpagePools数组中先查看对应下标元素的next节点是否有内存，存在则直接分配；</p><img src="/2023/04/10/Netty/31.jpg" class="" title="Netty"><img src="/2023/04/10/Netty/32.jpg" class="" title="Netty"></li></ul></li></ul></blockquote><h4 id="（3）内存分配和回收"><a href="#（3）内存分配和回收" class="headerlink" title="（3）内存分配和回收"></a>（3）内存分配和回收</h4><blockquote><ul><li>内存分配的大小大于8k；采用page为单位进行内存分配；</li><li>内存分配的大小小于8K：先去PoolThreadCahce中查找是否有内存可以分配，没有则采用Subage为单位进行分配，并且用完空间后，不会回收，而是缓存到PoolThreadCache中；</li><li>PoolThreadCache：申请内存小于8K时，会到PoolThreadCache中的tiny，small中找是否有合适内存分配；申请内存大于8k，小于16M时，会冲PoolThreadCache中的normal中查找是否有符合的内存；大于16M的内存则直接分配；</li></ul></blockquote><h3 id="11、零拷贝"><a href="#11、零拷贝" class="headerlink" title="11、零拷贝"></a>11、零拷贝</h3><blockquote><ul><li>零拷贝：不需要将数据从一个内存位置拷贝到另外一个内存位置，减少内存拷贝损耗；</li></ul></blockquote><h4 id="（1）堆外内存"><a href="#（1）堆外内存" class="headerlink" title="（1）堆外内存"></a>（1）堆外内存</h4><blockquote><ul><li>JVM内部执行IO时，需要将堆内内存拷贝到堆外内存，JVM操作的堆内内存与操作系统分配的内存是不一样的，而且同一个对象在堆内内存的地址是不固定的，GC会通过压缩来减少内存碎片的产生；</li><li>Netty执行IO是在堆外内存操作的，可以避免由堆内内存拷贝到堆外内存</li></ul></blockquote><h4 id="（2）CompositeByteBuf"><a href="#（2）CompositeByteBuf" class="headerlink" title="（2）CompositeByteBuf"></a>（2）CompositeByteBuf</h4><blockquote><ul><li><p>调用addCompoments（）方法来合并两个ByteBuf，底层的byte数组还是复用的，不会进行拷贝；</p></li><li><p>内部维护一个Compoment数组，每一个Compoment对应一个ByteBuf，每一个ByteBuf维护各自的索引；</p></li><li><p>通过Compoment中的offset和endOffset，可以直到一个ByteBuf的开始读取位置到结束位置，从而形成一个逻辑整体；</p><img src="/2023/04/10/Netty/33.jpg" class="" title="Netty"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">final</span> ByteBuf srcBuf; <span class="hljs-comment">// 原始ByteBuf</span><br>    <span class="hljs-keyword">final</span> ByteBuf buf; <span class="hljs-comment">// srcBuf取出包装后的ByteBuf</span><br>    <span class="hljs-type">int</span> srcAdjustment; <span class="hljs-comment">// CompositeByteBuf 的起始索引相对于 srcBuf 读索引的偏移</span><br>    <span class="hljs-type">int</span> adjustment; <span class="hljs-comment">// CompositeByteBuf 的起始索引相对于 buf 的读索引的偏移</span><br>    <span class="hljs-type">int</span> offset; <span class="hljs-comment">// 相对CompositeByteBuf开始索引</span><br>    <span class="hljs-type">int</span> endOffset; <span class="hljs-comment">// 相对CompositeByteBud的结束索引</span><br>    <span class="hljs-comment">//省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/10/Netty/34.jpg" class="" title="Netty"><h4 id="（3）Unpooled-WrappedBuffer操作"><a href="#（3）Unpooled-WrappedBuffer操作" class="headerlink" title="（3）Unpooled.WrappedBuffer操作"></a>（3）Unpooled.WrappedBuffer操作</h4><blockquote><p>将一个或多个ByteBuf包装为一个大的ByteBuf，底层同样是共享byte数组，不会发生数据拷贝；</p></blockquote><h4 id="（4）ByteBuf-slice（）操作"><a href="#（4）ByteBuf-slice（）操作" class="headerlink" title="（4）ByteBuf.slice（）操作"></a>（4）ByteBuf.slice（）操作</h4><blockquote><p>将一个大的ByteBuf拆分为多个小的ByteBuf，每一个小的ByteBuf都会生成一个读写指针，底层的byte数组依旧与原来的ByteBuf共享;</p><img src="/2023/04/10/Netty/35.jpg" class="" title="Netty"></blockquote><h4 id="（5）文件传输FileRegiion"><a href="#（5）文件传输FileRegiion" class="headerlink" title="（5）文件传输FileRegiion"></a>（5）文件传输FileRegiion</h4><blockquote><p>FileRegion的对FileChannel的封装，底层使用JDK的NIO的FileChannel的transferTo（）方法实现文件传输，所以为零拷贝；</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、工作模型"><a href="#1、工作模型" class="headerlink" title="1、工作模型"></a>1、工作模型</h3><p>①vhost：实现资源的隔离和权限的监控，不同的vhost可以有相同的队列交换机;</p><p>②Broke：消息代理服务</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="图片1"><h3 id="2、直连交换机（Direct）"><a href="#2、直连交换机（Direct）" class="headerlink" title="2、直连交换机（Direct）"></a>2、直连交换机（Direct）</h3><p>①一个队列通过一个具体的routingKey绑定交换机；</p><p>②主要用于循环分发任务给工作者，负载均衡是在消费者之间</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="图片1"><h3 id="3、扇形交换机"><a href="#3、扇形交换机" class="headerlink" title="3、扇形交换机"></a>3、扇形交换机</h3><p>①消息发送给扇形交换机，扇形交换机广播给所有与之绑定的队列；</p><p>②使用场景</p><blockquote><ul><li>大规模多用户在线游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。</li></ul></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="图片1"><h3 id="4、主题交换机"><a href="#4、主题交换机" class="headerlink" title="4、主题交换机"></a>4、主题交换机</h3><p>①交换机与队列绑定的路由键可以使用通配符，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者&#x2F;多应用的时候，主题交换机都可以被列入考虑范围；</p><p>②路由匹配规则</p><blockquote><p>（1）#代表匹配0个或多个规则</p><p>（2）*匹配一个单词</p><p>（3）单词之间用 . 分开</p></blockquote><p>③适用于一些根据业务场景和消息类型过滤消息的场景</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="图片1"><h3 id="5、可靠性投递"><a href="#5、可靠性投递" class="headerlink" title="5、可靠性投递"></a>5、可靠性投递</h3><h4 id="①交换机，队列绑定配置，以及消费者"><a href="#①交换机，队列绑定配置，以及消费者" class="headerlink" title="①交换机，队列绑定配置，以及消费者"></a>①交换机，队列绑定配置，以及消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">------ 配置RabbitMQConfig.class -----------<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String exchangeName=<span class="hljs-string">&quot;test_exchange_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String queueName=<span class="hljs-string">&quot;test_queue_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String routingKey=<span class="hljs-string">&quot;test_key&quot;</span>;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(routingKey);<br>    &#125;<br>&#125;<br><br>-------------消费者Consumer.class------------------------------------------<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-comment">//消费消息</span><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.queueName)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费消息:&quot;</span>+name);<br>    &#125;<br>&#125;<br><br>-------------yml配置-----------------------------------------<br>spring:<br>  rabbitmq:<br>    host: localhost<br>    port: <span class="hljs-number">5672</span><br>    username: admin<br>    password: admin<br>    <span class="hljs-comment">//开启消息确认机制，一定要开启</span><br>    publisher-confirm-type: correlated<br>    publisher-returns: <span class="hljs-literal">true</span><br>    template:<br>      mandatory: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="②消息到RabbitMQ服务端"><a href="#②消息到RabbitMQ服务端" class="headerlink" title="②消息到RabbitMQ服务端"></a>②消息到RabbitMQ服务端</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="图片1"><p>（1）问题：生产者发送消息给MQ服务器时，可能由于网络原因或Broke故障导致发送失败，生产者无法确定是否发送成功；</p><p>（2）事务确认模式：通过channel.txCommit提交事务，若发生异常，使用channel.txRollback回滚事务，我们可以捕捉处理异常，会阻塞后面所有消息的消费；</p><p>（3）Confirm确认模式</p><blockquote><p>correlationData：消息的唯一标识；</p><p>ack：消息发送成功返回true，发送失败返回false;</p><p>cause：消息发送失败原因</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;confirm&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">confirm</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开启消息确认机制，correlationData1为消息标识,</span><br><span class="hljs-comment">     * ack消息是否发送成功（true标识发送成功），cause:发送失败原因</span><br><span class="hljs-comment">     */</span><br>    rabbitTemplate.setConfirmCallback((correlationData1,ack,cause)-&gt;&#123;<br>        <span class="hljs-keyword">if</span> (ack)&#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送失败，&quot;</span>+<span class="hljs-string">&quot;失败原因为：&quot;</span>+cause);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//发送五条消息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//消息的唯一标识</span><br>        CorrelationData correlationData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(String.valueOf(i));<br>        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//消息发送失败</span><br>            Map&lt;String,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;correlationData&quot;</span>, i);<br>            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;无法找到交换机的消息&quot;</span>);<br>            rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;notQueue&quot;</span>, String.valueOf(i),map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            rabbitTemplate.convertAndSend(RabbitMQConfig.queueName,i,correlationData);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③消息从交换机到路由队列"><a href="#③消息从交换机到路由队列" class="headerlink" title="③消息从交换机到路由队列"></a>③消息从交换机到路由队列</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="图片1"><p>（1）问题：交换机到队列的路由或队列不存在，发送消息丢失</p><p>（2）重发消息到新的队列消费</p><blockquote><p>message：回退消息</p><p>replayCode：错误状态码</p><p>replayText：错误内容</p><p>exchange：交换机</p><p>routingKey:路由</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;returnBack&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">returnBack</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//设置消息重发机制</span><br>    rabbitTemplate.setReturnCallback((message, replyCode, replyText,exchange, routingKey)-&gt;&#123;<br>        System.out.println(<span class="hljs-string">&quot;回退消息：&quot;</span>+message);<br>        System.out.println(<span class="hljs-string">&quot;不通路由：&quot;</span>+routingKey);<br>        System.out.println(<span class="hljs-string">&quot;交换机:&quot;</span>+exchange);<br>        System.out.println(<span class="hljs-string">&quot;replayText:&quot;</span>+replyText);<br>        <span class="hljs-comment">//重发消息到备份队列</span><br>        rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                      RabbitMQConfig.backKey,message.getBody());<br>    &#125;);<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                  <span class="hljs-string">&quot;no&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④消息从队列到消费者"><a href="#④消息从队列到消费者" class="headerlink" title="④消息从队列到消费者"></a>④消息从队列到消费者</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="图片1"><p>（1）问题：消息到达队列后，等待消费者消费，消费者未消费，服务宕机，队列消息丢失；</p><p>（2）队列和交换机设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤消息到消费者-消费失败"><a href="#⑤消息到消费者-消费失败" class="headerlink" title="⑤消息到消费者 消费失败"></a>⑤消息到消费者 消费失败</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="图片1"><p>（1）消费者从MQ中获取消息后，MQ会删除消息，消费者异常消费失败，消息丢失</p><p>（2）消费者消费消息完成后，手动发送ack给服务端</p><blockquote><p>none：自动ACK，默认</p><p>maunal：手动ACK</p><p>auto：方法未抛出异常，自动发送ACK，抛出异常（不是AmqpRejectAndDontReueueException）则发送nack，重新入队列</p><p>开启了maunal后，一定要手动basicACK，否则消息会无限消费</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#设置手动ack<br>listener:<br>direct:<br>acknowledge-mode: manual<br></code></pre></td></tr></table></figure><blockquote><p>【1】void basicAck(long deliveryTag, boolean multiple) ：</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息，如</p><p>发送消息1，2，3，未应答，发送消息4，应答1，2，3，4</p><p>【2】void basicNack(long deliveryTag, boolean multiple, boolean requeue)</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息</p><p>requeue：是否重新入队列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.backQueue)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerAck</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(String msg, Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟故障</span><br>            <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;消息消费：&quot;</span>+msg);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 应答消息消费成功，参数2：true开启批量应答</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ioException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;发送失败，消息丢失&quot;</span>);<br>            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、消息幂等性"><a href="#6、消息幂等性" class="headerlink" title="6、消息幂等性"></a>6、消息幂等性</h3><h4 id="①问题"><a href="#①问题" class="headerlink" title="①问题"></a>①问题</h4><p>对于同一个系统中，一次请求或重复多次请求对资源的影响是一致性的。如：同一笔订单中，由于网络延迟，消费者重新支付，如果没有幂等性，则会造成多次消费，有幂等性，对同个订单支付多次时，只会支付一次；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" title="图片1"><h4 id="②解决方案"><a href="#②解决方案" class="headerlink" title="②解决方案"></a>②解决方案</h4><blockquote><p>发送消息时，带上全局唯一id，每次消费消息时，前往redis中判断是否存在该消费消息，存在，消息丢弃，不存在，消费消息，将id写入redis中。</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" title="图片1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>    redis:<br>        port: <span class="hljs-number">6379</span><br>        password: <span class="hljs-number">123456</span><br>        host: localhost<br>    rabbitmq:<br>        host: localhost<br>        port: <span class="hljs-number">5672</span><br>        username: admin<br>        password: admin<br>        publisher-confirm-type: correlated<br>        publisher-returns: <span class="hljs-literal">true</span><br>        template:<br>        mandatory: <span class="hljs-literal">true</span><br>        #设置手动ack<br>        listener:<br>            simple:<br>                acknowledge-mode: manual<br>                #重试次数<br>                retry:<br>                enabled: <span class="hljs-literal">true</span><br>                max-attempts: <span class="hljs-number">3</span> #重试次数最多三次<br>                initial-interval: <span class="hljs-number">2000</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String exchangeName=<span class="hljs-string">&quot;test_exchange_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String idempotent_queue=<span class="hljs-string">&quot;idempotent_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String idempotent_key=<span class="hljs-string">&quot;idempotent_key&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(idempotentQueue())<br>        .to(directExchange()).with(idempotent_key);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">idempotentQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(idempotent_queue).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>生产者发送消息：</p><p>设置messageId为唯一id，做为key，存储到redis中，用于判断消息是否消费过</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/idempotent&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">idempotent</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//设置唯一标识</span><br>    CorrelationData correlationData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    correlationData.setId(String.valueOf(<span class="hljs-number">1</span>));<br>    <span class="hljs-comment">//消息体</span><br>    String msg=<span class="hljs-string">&quot;hello&quot;</span>;<br>    Message message= MessageBuilder.withBody(msg.getBytes())<br>    .setMessageId(UUID.randomUUID()+<span class="hljs-string">&quot;&quot;</span>)<br>    .setContentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    .build();<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                  RabbitMQConfig.idempotent_key,message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>消费者消费消息：</p><p>消费时，判断redis中，该id的值是否存在，存在则消费过，丢弃消息，否则消费消息，将id写入redis；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.idempotent_queue)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumers</span><span class="hljs-params">(Message message,Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费次数：&quot;</span>+message.getMessageProperties().getDeliveryTag());<br>    <span class="hljs-comment">/** 根据用户唯一标识+deliverTag，设置key */</span><br>    String key=message.getMessageProperties().getMessageId();<br>    <span class="hljs-comment">/** redis中不存在 */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (s==<span class="hljs-literal">null</span>)&#123;<br>        String msg=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        System.out.println(<span class="hljs-string">&quot;消费消息&quot;</span>+msg);<br>        stringRedisTemplate.opsForValue().set(key,key);<br>    &#125;<br>    <span class="hljs-comment">/** 模拟消费者消费消息后故障， */</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/** 应答消息 */</span><br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">true</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="7、消息的顺序性"><a href="#7、消息的顺序性" class="headerlink" title="7、消息的顺序性"></a>7、消息的顺序性</h3><h4 id="①问题-1"><a href="#①问题-1" class="headerlink" title="①问题"></a>①问题</h4><blockquote><p>生产者按顺序发送A，B，C消息，多个消费者消费消息时，由于各消费者消费速度不一样，可能造成消费的顺序不为A，B，C，从而导致数据错乱</p></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" class="" title="图片1"><h4 id="②解决方案-1"><a href="#②解决方案-1" class="headerlink" title="②解决方案"></a>②解决方案</h4><blockquote><p>一个消费者对应一个队列，同一个业务的消息发送到同一个队列中</p></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" class="" title="图片1"><h3 id="8、延迟消息"><a href="#8、延迟消息" class="headerlink" title="8、延迟消息"></a>8、延迟消息</h3><h4 id="①死信队列"><a href="#①死信队列" class="headerlink" title="①死信队列"></a>①死信队列</h4><p>队列中配置了dead-letter-exchange属性，指定交换机，则队列中的死信就会投递到该交换机中；</p><p>死信：</p><p>（1）消息被拒绝或返回nack，且requeue设置为false；</p><p>（2）消息超时，无人消费；</p><p>（3）消息堆积，最早消息成为死信</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" class="" title="图片1"><p>队列配置死信交换机如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">test_queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(test_queue_dead)<br>    <span class="hljs-comment">//设置死信交换机</span><br>    .deadLetterExchange(dead_exchange)<br>    .deadLetterRoutingKey(dead_key)<br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②延迟交换机"><a href="#②延迟交换机" class="headerlink" title="②延迟交换机"></a>②延迟交换机</h4><p>指定交换机延迟时间，交换机时间到后会发送消息给队列消费；消息头需要携带x-delay参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/dead&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dead</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//消息体</span><br>    String msg=<span class="hljs-string">&quot;hello&quot;</span>;<br>    Message message= MessageBuilder.withBody(msg.getBytes())<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>,<span class="hljs-number">10000</span>)<span class="hljs-comment">//设置延迟时间</span><br>    .build();<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.test_exchange_dead,<br>                                  RabbitMQConfig.test_key,message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置延迟交换机，需要先去下载延迟交换机插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange_test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder<br>    .directExchange(test_exchange_dead)<br>    .delayed()<span class="hljs-comment">//设置延迟交换机</span><br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、消息堆积（惰性队列）"><a href="#9、消息堆积（惰性队列）" class="headerlink" title="9、消息堆积（惰性队列）"></a>9、消息堆积（惰性队列）</h3><p>①生产者消费消息速度超过消费者消费速度，就会堆积消息；</p><p>②解决：增加消费者；消费者内部采用线程池处理；扩大堆积队列</p><p>③惰性队列：接收到消息后，会直接存入磁盘，消费者消费时，才会加载到内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">test_queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(test_queue_dead)<br>    .lazy()<span class="hljs-comment">//配置为延迟队列</span><br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10、消息中间件四种消息投递模型"><a href="#10、消息中间件四种消息投递模型" class="headerlink" title="10、消息中间件四种消息投递模型"></a>10、消息中间件四种消息投递模型</h3><h4 id="①点对点（PTP）模型"><a href="#①点对点（PTP）模型" class="headerlink" title="①点对点（PTP）模型"></a>①点对点（PTP）模型</h4><blockquote><ul><li><p>点对点通信，一个队列可以有多个生产者和多个消费者；</p></li><li><p>消息按照接收消息的顺序，先后放入队列中，一个消息只能有一个消费者消费；</p></li><li><p>消息消费后，会从队列中删除；</p></li><li><p>虽然采用队列，但是消息的消费可能是无序的，队列可以将消息给多个消费者消费，所以队列保证分发是有序的，但消费顺序取决于消费者的处理速度；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" class="" title="图片1"></li></ul></blockquote><h4 id="②发布订阅（Pub-x2F-Sub）模型"><a href="#②发布订阅（Pub-x2F-Sub）模型" class="headerlink" title="②发布订阅（Pub&#x2F;Sub）模型"></a>②发布订阅（Pub&#x2F;Sub）模型</h4><blockquote><p>生成者发送消息到一个主题中，订阅了该主题的所有消费者，都可以收到消息；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" class="" title="图片1"></blockquote><h4 id="③分区（Partition）模型"><a href="#③分区（Partition）模型" class="headerlink" title="③分区（Partition）模型"></a>③分区（Partition）模型</h4><blockquote><ul><li><p>生产者根据主题类型发送消息到对应的分区（Partition），一个分区可以理解为一个队列，且分区中队列存储的数据只是一部分，而PTP模型中，队列存储的数据是全部数据；</p></li><li><p>每个分区（Partition）会对应一组消费者，消费者只能消费由自己所在分区派发的消息；</p></li><li><p>每个分区只能发送给一个消费者,消费者数量不能多余分区；</p></li><li><p>分区模型，将点对点模型和发布订阅模式结合起来；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" class="" title="图片1"></li></ul></blockquote><h4 id="④transfer模型"><a href="#④transfer模型" class="headerlink" title="④transfer模型"></a>④transfer模型</h4><blockquote><ul><li><p>生产者发送消息到topic上，会转发到每一个队列；</p></li><li><p>队列中拥有消息的全量数据，一个队列的消息可以被多个消费者消费；</p></li><li><p>队列同样不保证消息消费的顺序性;</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" class="" title="图片1"></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2023/03/24/ElasticSearch/"/>
    <url>/2023/03/24/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h3 id="1、ElasticSearch基本概念"><a href="#1、ElasticSearch基本概念" class="headerlink" title="1、ElasticSearch基本概念"></a>1、ElasticSearch基本概念</h3><h4 id="（1）Node节点"><a href="#（1）Node节点" class="headerlink" title="（1）Node节点"></a>（1）Node节点</h4><blockquote><p>一个节点是一个集群的服务器，存储集群的数据，参与集群的索引和搜索功能。像集群有名字，节点也有自己的名称，默认在启动时会以一个随机的UUID的前七个字符作为节点的名字，你可以为其指定任意的名字。通过集群名在网络中发现同伴组成集群。一个节点也可是集群。</p></blockquote><h4 id="（2）index索引"><a href="#（2）index索引" class="headerlink" title="（2）index索引"></a>（2）index索引</h4><blockquote><p>一个索引是文档的集合，类比mysql中的数据库，每个索引有唯一名称（全为小写字母），我们对文档进行搜索，增删改时，都要用到这个名字。</p></blockquote><h4 id="（3）Type类型"><a href="#（3）Type类型" class="headerlink" title="（3）Type类型"></a>（3）Type类型</h4><blockquote><p>一个索引中可以存放不同数据，类比mysql中的表，6.0版本以上已废弃。</p></blockquote><h4 id="（4）Document文档"><a href="#（4）Document文档" class="headerlink" title="（4）Document文档"></a>（4）Document文档</h4><blockquote><p>索引中的一条数据，类比msql中的一行数据，插入索引以文档为单位，以JSON格式存储。</p></blockquote><h4 id="（5）Shard分片"><a href="#（5）Shard分片" class="headerlink" title="（5）Shard分片"></a>（5）Shard分片</h4><blockquote><p>数据量过大时，ElasticSearch索引过慢，因此将索引划分成多份，这些份就是分片。分片允许水平扩容；同时支持分布式，并行操作。</p></blockquote><h4 id="（6）Replication复制"><a href="#（6）Replication复制" class="headerlink" title="（6）Replication复制"></a>（6）Replication复制</h4><blockquote><p>一个分片可以有多个备份，分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p></blockquote><h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><h4 id="（1）索引创建"><a href="#（1）索引创建" class="headerlink" title="（1）索引创建"></a>（1）索引创建</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test-index-users<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;number_of_shards&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//设置分片数量</span><br>    <span class="hljs-attr">&quot;number_of_replicas&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">//指定映射关系</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;long&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;remarks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（2）倒排索引"><a href="#（2）倒排索引" class="headerlink" title="（2）倒排索引"></a>（2）倒排索引</h4><blockquote><p>ElasticSearch会为下面的数据创建两个索引树，ID不指定会自动生成，以Name和Age生成的索引树就为倒排索引</p></blockquote><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Kate</td><td align="center">24</td></tr><tr><td align="center">2</td><td align="center">John</td><td align="center">24</td></tr><tr><td align="center">3</td><td align="center">Bill</td><td align="center">29</td></tr><tr><td align="center">4</td><td align="center">Kate</td><td align="center">26</td></tr><tr><td align="center">5</td><td align="center">Brand</td><td align="center">29</td></tr></tbody></table><blockquote><p>以Name字段建立的索引树</p></blockquote><table><thead><tr><th align="center">Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td align="center">Kate</td><td align="center">1,4</td></tr><tr><td align="center">Brand</td><td align="center">5</td></tr><tr><td align="center">John</td><td align="center">2</td></tr><tr><td align="center">Bill</td><td align="center">3</td></tr></tbody></table><blockquote><p>以Age创建索引树</p></blockquote><table><thead><tr><th align="center">Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td align="center">24</td><td align="center">1,2</td></tr><tr><td align="center">26</td><td align="center">4</td></tr><tr><td align="center">29</td><td align="center">3,5</td></tr></tbody></table><blockquote><p>①每个字段对应一组Term，每个Term对应一个Posting List，他是一组id，根据id到磁盘查找速度会快很多；</p><p>②Term存放于有序表Term DIctionary（磁盘中）中，Term按序存放，每次查找term时，根据二分查找，时间复杂度为LogN；</p><p>③对于Term中大量重复前缀，ElasticSearch会把每一个Term的前缀取出来放入树种，这颗树就是Term Index。</p></blockquote><img src="/2023/03/24/ElasticSearch/1.png" class="" title="ElasticSearch"><blockquote><p>Posting List压缩：</p><p>①bitmap是一种数据结构，其用0&#x2F;1代表值是否存在，如</p><p>{1，2，3，5},对应bitmap为：[1，0，1，1，1]</p><p>②但bitmap随着元素的增加，bitmap存储空间也是线性增加，会占用大量空间；</p><p>③Roardings bitmap：</p><p>将posting List按照65535分块，0-65535为第一块，65536-131071为第二块，再用&lt;商，余数&gt;表示一组id，商表示在第几组，余数则表示在组中位置，如下图：</p></blockquote><img src="/2023/03/24/ElasticSearch/2.png" class="" title="ElasticSearch"><h3 id="3、DSL查询"><a href="#3、DSL查询" class="headerlink" title="3、DSL查询"></a>3、DSL查询</h3><blockquote><ul><li>match查询，会将查询池进行分词，包含分词后的词，数据可以被查到，如：</li></ul><p>查询词：苹果橘子，只要包含苹果、橘子的文档都会被查出</p><ul><li>term查询，需要包含和查询值一样的文档，数据才可以被查到（查询词若为英文单词，全部字母需要小写，否则匹配不到），如：</li></ul><p>数据：【Apple ，oragne】，查询词：apple  可以被查到的数据：Apple</p></blockquote><h4 id="（1）复合查询"><a href="#（1）复合查询" class="headerlink" title="（1）复合查询"></a>（1）复合查询</h4><h6 id="①布尔查询（bool-query）"><a href="#①布尔查询（bool-query）" class="headerlink" title="①布尔查询（bool query）"></a>①布尔查询（bool query）</h6><blockquote><ul><li>子查询可以任意顺序出现</li><li>可以嵌套多个查询，包括bool查询</li><li>如果bool查询中没有must条件，should中必须至少满足一条才会返回结果，不满足不反回数据。</li><li>四种操作符must、should、must_not、filter</li></ul></blockquote><img src="/2023/03/24/ElasticSearch/3.png" class="" title="ElasticSearch"><blockquote><p>must与filter区别</p></blockquote><img src="/2023/03/24/ElasticSearch/4.png" class="" title="ElasticSearch"><h6 id="②提高查询（boosting-query）"><a href="#②提高查询（boosting-query）" class="headerlink" title="②提高查询（boosting query）"></a>②提高查询（boosting query）</h6><blockquote><p>boosting查询中一个子查询条件不满足，则是减低数据显示的权重（score），如</p><p>name&#x3D;”tom” and age&#x3D;1,条件age不匹配，数据还是会显示，只是降低权重（scope）</p></blockquote><img src="/2023/03/24/ElasticSearch/5.png" class="" title="ElasticSearch"><h6 id="③固定分数查询（constant-scope）"><a href="#③固定分数查询（constant-scope）" class="headerlink" title="③固定分数查询（constant_scope）"></a>③固定分数查询（constant_scope）</h6><blockquote><p>查询某个条件时，返回固定的scope，我们可以利用filter过滤，返回scope，不需要计算scope，filter是忽略scope的</p></blockquote><img src="/2023/03/24/ElasticSearch/6.png" class="" title="ElasticSearch"><h6 id="④最佳匹配查询（dis-max）"><a href="#④最佳匹配查询（dis-max）" class="headerlink" title="④最佳匹配查询（dis_max）"></a>④最佳匹配查询（dis_max）</h6><blockquote><p>将与任一匹配的文档返回，但只返回结果最佳的评分 作为查询的评分返回</p><p>在使用多个match匹配时，<u>匹配度最高的不一定是最佳结果</u>，因为match匹配时，会将title，body中match匹配结果的评分进行累加，最终返回，下面计算评分:</p><ol><li>通过title 匹配 brown fox ，id&#x3D;1匹配到(第一个match)</li></ol><p>id&#x3D;1分数：0.6931472</p><p>id&#x3D;2分数：0</p><img src="/2023/03/24/ElasticSearch/7.png" class="" title="ElasticSearch"><p>2.body 匹配 brown fox（第二个match）</p><p>id&#x3D;1分数：0.2111090919</p><p>id&#x3D;2分数：0.77041256</p><img src="/2023/03/24/ElasticSearch/8.png" class="" title="ElasticSearch"><p>3.整体查询的结果分数&#x3D;第一个match分数+第二个match分数</p><p>id为1的分数&#x3D;0.6931472+0.2111090919&#x3D;0.90425634</p><p>id为2的分数&#x3D;0+0.77041256&#x3D;0.77041256</p><img src="/2023/03/24/ElasticSearch/9.png" class="" title="ElasticSearch"><p>使用dis_max,   分数 &#x3D; 第一个匹配条件分数 + tie_breaker * 第二个匹配的条件的分数 </p><img src="/2023/03/24/ElasticSearch/10.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤函数查询（function-score）"><a href="#⑤函数查询（function-score）" class="headerlink" title="⑤函数查询（function_score）"></a>⑤函数查询（function_score）</h6><blockquote><p>使用自定义的函数计算评分值</p><ul><li>script_score 使用自定义的脚本来完全控制分值计算逻辑。如果你需要以上预定义函数之外的功能，可以根据需要通过脚本进行实现。</li></ul><img src="/2023/03/24/ElasticSearch/11.png" class="" title="ElasticSearch"><ul><li>weight 对每份文档适用一个简单的提升，且该提升不会被归约：当weight为2时，结果为2 * score。</li><li>random_score 使用一致性随机分值计算来对每个用户采用不同的结果排序方式，对相同用户仍然使用相同的排序方式。</li></ul><img src="/2023/03/24/ElasticSearch/12.png" class="" title="ElasticSearch"><ul><li>field_value_factor 使用文档中某个字段的值来改变_score，比如将受欢迎程度或者投票数量考虑在内。</li></ul><img src="/2023/03/24/ElasticSearch/13.png" class="" title="ElasticSearch"><ul><li>衰减函数(Decay Function) - linear，exp，gauss</li></ul></blockquote><h4 id="（2）全文搜索"><a href="#（2）全文搜索" class="headerlink" title="（2）全文搜索"></a>（2）全文搜索</h4><h6 id="①match查询"><a href="#①match查询" class="headerlink" title="①match查询"></a>①match查询</h6><blockquote><p><strong>单词匹配</strong></p><p>（1）检查查询字段类型，字段为string类型，则match匹配的词要进行分词；</p><p>（2）分析查询字符串，下图中quick只有一个单词，分词后结果为quic，所以match执行的是当个term查询</p><p>（3）term通过倒排索引。，查询到id为 【1，3】</p><p>（4）为每个查询结果进行评分</p><img src="/2023/03/24/ElasticSearch/14.png" class="" title="ElasticSearch"></blockquote><blockquote><p><strong>多词匹配</strong></p><p>多个单词，实际上是执行多个单词term匹配，然后合并结果</p><img src="/2023/03/24/ElasticSearch/15.png" class="" title="ElasticSearch"><p>上方查询与下方bool查询等价</p><img src="/2023/03/24/ElasticSearch/16.png" class="" title="ElasticSearch"><p>match多词匹配中，有个operator属性，默认值为or，结果与上面等价</p><img src="/2023/03/24/ElasticSearch/17.png" class="" title="ElasticSearch"><p>match支持参数minimum_should_match来控制匹配单词数，可以是分数，也可以直接指定匹配单词数</p><img src="/2023/03/24/ElasticSearch/18.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/19.png" class="" title="ElasticSearch"></blockquote><h6 id="②match-phrase查询"><a href="#②match-phrase查询" class="headerlink" title="②match_phrase查询"></a>②match_phrase查询</h6><blockquote><p>本质是连续的term查询（必须满足所有单词匹配），遇到数据中没有的词，就会查询不到，同时搜索单词的顺序需要和数据中单词顺寻保持一致，否则查询不到；如下：</p><img src="/2023/03/24/ElasticSearch/20.png" class="" title="ElasticSearch"><p>下面匹配单词和上图一样，但是顺寻不一样，匹配结果不同</p><img src="/2023/03/24/ElasticSearch/21.png" class="" title="ElasticSearch"></blockquote><h6 id="③match-pharse-prefix"><a href="#③match-pharse-prefix" class="headerlink" title="③match_pharse_prefix"></a>③match_pharse_prefix</h6><blockquote><p>该匹配是最后一个词是前缀匹配，前面的单词和match_pharse匹配一致，如：</p><p>【brown quick f】需要匹配到单词brown、quick，且以f为前缀的单词，同时顺序需要保持一致；</p><img src="/2023/03/24/ElasticSearch/22.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/23.png" class="" title="ElasticSearch"></blockquote><h6 id="④match-bool-prefix"><a href="#④match-bool-prefix" class="headerlink" title="④match_bool_prefix"></a>④match_bool_prefix</h6><blockquote><p>也是连续的term匹配，最后一个单词前缀匹配即可，需要匹配所有单词，但顺序可以不一致，如下图：</p><img src="/2023/03/24/ElasticSearch/24.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤multi-match"><a href="#⑤multi-match" class="headerlink" title="⑤multi_match"></a>⑤multi_match</h6><blockquote><p>查询单词，满足其中一个字段即可，不用所有单词都匹配</p><img src="/2023/03/24/ElasticSearch/25.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/26.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥query-string"><a href="#⑥query-string" class="headerlink" title="⑥query_string"></a>⑥query_string</h6><blockquote><p>根据运算符来来提供查询字符串，查询前，拆分每一个文本</p><img src="/2023/03/24/ElasticSearch/27.png" class="" title="ElasticSearch"></blockquote><h6 id="⑦simple-query-string"><a href="#⑦simple-query-string" class="headerlink" title="⑦simple_query_string"></a>⑦simple_query_string</h6><blockquote><p>查询时，会自动将搜索词中无效的文本忽略</p><img src="/2023/03/24/ElasticSearch/28.png" class="" title="ElasticSearch"></blockquote><h6 id="⑧interval"><a href="#⑧interval" class="headerlink" title="⑧interval"></a>⑧interval</h6><blockquote><p>单词都要匹配，且按照匹配条件顺序进行匹配</p><img src="/2023/03/24/ElasticSearch/29.png" class="" title="ElasticSearch"></blockquote><h4 id="（3）Term查询"><a href="#（3）Term查询" class="headerlink" title="（3）Term查询"></a>（3）Term查询</h4><h6 id="①exist查询"><a href="#①exist查询" class="headerlink" title="①exist查询"></a>①exist查询</h6><blockquote><p>查询指定字段存在的数据，字段索引值不存在的原因：JSON数据为null、index设置为false、字段长度超过映射长度、字段数据类型错误</p><img src="/2023/03/24/ElasticSearch/30.png" class="" title="ElasticSearch"></blockquote><h6 id="②id查询"><a href="#②id查询" class="headerlink" title="②id查询"></a>②id查询</h6><blockquote><p>查询指定id的数据</p><img src="/2023/03/24/ElasticSearch/31.png" class="" title="ElasticSearch"></blockquote><h6 id="③prefix前缀查询"><a href="#③prefix前缀查询" class="headerlink" title="③prefix前缀查询"></a>③prefix前缀查询</h6><blockquote><p>查找指定字段的前缀值相同的数据</p><img src="/2023/03/24/ElasticSearch/32.png" class="" title="ElasticSearch"></blockquote><h6 id="④term分词查询"><a href="#④term分词查询" class="headerlink" title="④term分词查询"></a>④term分词查询</h6><blockquote><p>根据分词查询数据，查询词需要和value值完全一样才会匹配</p><img src="/2023/03/24/ElasticSearch/33.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤terms多分词查询"><a href="#⑤terms多分词查询" class="headerlink" title="⑤terms多分词查询"></a>⑤terms多分词查询</h6><blockquote><p>根据多个分词查询数据</p><img src="/2023/03/24/ElasticSearch/34.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥term-set查询"><a href="#⑥term-set查询" class="headerlink" title="⑥term_set查询"></a>⑥term_set查询</h6><blockquote><p>指定term需要匹配词的数量</p><img src="/2023/03/24/ElasticSearch/35.png" class="" title="ElasticSearch"></blockquote><h6 id="⑦wildcard查询"><a href="#⑦wildcard查询" class="headerlink" title="⑦wildcard查询"></a>⑦wildcard查询</h6><blockquote><p>通配符查询，如*可以匹配任意多个随意在字符</p><img src="/2023/03/24/ElasticSearch/36.png" class="" title="ElasticSearch"></blockquote><h6 id="⑧range查询"><a href="#⑧range查询" class="headerlink" title="⑧range查询"></a>⑧range查询</h6><blockquote><p>范围匹配查询</p><img src="/2023/03/24/ElasticSearch/37.png" class="" title="ElasticSearch"></blockquote><h6 id="⑩fuzzy模糊查询"><a href="#⑩fuzzy模糊查询" class="headerlink" title="⑩fuzzy模糊查询"></a>⑩fuzzy模糊查询</h6><blockquote><p>模糊查询，可以进行匹配词的增删改，如增：sic-&gt;sick 、改：box-&gt;fox、删：black-&gt;lack、换:act-&gt;cat</p><p>（只能更改一个字符）</p><img src="/2023/03/24/ElasticSearch/38.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/39.png" class="" title="ElasticSearch"></blockquote><h3 id="4、聚合查询"><a href="#4、聚合查询" class="headerlink" title="4、聚合查询"></a>4、聚合查询</h3><h5 id="（1）桶（Bucket）聚合"><a href="#（1）桶（Bucket）聚合" class="headerlink" title="（1）桶（Bucket）聚合"></a>（1）桶（Bucket）聚合</h5><blockquote><ol><li><p>桶：类似于MySQL中的groud by查询后的分组，是存放满足特定条件文档的集合；</p></li><li><p>指标：对桶中的文档进行计算，类似于MySQL中的count（），avg（）函数</p><img src="/2023/03/24/ElasticSearch/40.png" class="" title="ElasticSearch"></li></ol></blockquote><blockquote><p>数据准备</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /car/_bulk<br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">10000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-10-28&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-11-05&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">30000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;green&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ford&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-05-18&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">15000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toyota&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-07-02&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">12000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;green&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toyota&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-08-19&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-11-05&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">80000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bmw&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-01-01&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">25000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ford&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-02-12&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h6 id="①普通的聚合查询"><a href="#①普通的聚合查询" class="headerlink" title="①普通的聚合查询"></a>①普通的聚合查询</h6><blockquote><p>以汽车中的颜色进行分组聚合，doc_count：表示组数据的数量，每个桶的数量代表改颜色文档数量</p><img src="/2023/03/24/ElasticSearch/41.png" class="" title="ElasticSearch"></blockquote><h6 id="②嵌套聚合查询"><a href="#②嵌套聚合查询" class="headerlink" title="②嵌套聚合查询"></a>②嵌套聚合查询</h6><blockquote><p>在一个聚合查询到数据，再进行聚合，如下面先以color属性聚合数据，然后在每个桶中再聚合price数据求平均值，如下图：</p><img src="/2023/03/24/ElasticSearch/42.png" class="" title="ElasticSearch"></blockquote><h6 id="③filter过滤"><a href="#③filter过滤" class="headerlink" title="③filter过滤"></a>③filter过滤</h6><blockquote><p>filter过滤条件，查询指定的数据进行聚合，如下</p><img src="/2023/03/24/ElasticSearch/43.png" class="" title="ElasticSearch"></blockquote><blockquote><p>filters:对filter进行分组聚合，filters中条件进行过滤，将过滤后相同的数据聚合</p><img src="/2023/03/24/ElasticSearch/44.png" class="" title="ElasticSearch"></blockquote><h6 id="④range聚合"><a href="#④range聚合" class="headerlink" title="④range聚合"></a>④range聚合</h6><blockquote><p>对number类型进行聚合，根据范围值进行聚合，to不包括值。from包括值</p><img src="/2023/03/24/ElasticSearch/45.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤Date-Range聚合"><a href="#⑤Date-Range聚合" class="headerlink" title="⑤Date Range聚合"></a>⑤Date Range聚合</h6><blockquote><p>对日期进行聚合,from和to后面的参数需要按照我们指定的format格式进行输入</p><img src="/2023/03/24/ElasticSearch/46.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥Histogram聚合"><a href="#⑥Histogram聚合" class="headerlink" title="⑥Histogram聚合"></a>⑥Histogram聚合</h6><blockquote><ol><li><p>histogram 桶要求两个参数：一个数值字段以、一个定义桶大小间隔。</p></li><li><p>可以使用各种嵌套聚合，来计算对应区间数据</p><img src="/2023/03/24/ElasticSearch/47.png" class="" title="ElasticSearch"></li></ol></blockquote><h5 id="（2）metrics聚合"><a href="#（2）metrics聚合" class="headerlink" title="（2）metrics聚合"></a>（2）metrics聚合</h5><h6 id="①单值分析：stat类型"><a href="#①单值分析：stat类型" class="headerlink" title="①单值分析：stat类型"></a>①单值分析：stat类型</h6><blockquote><ul><li><p>avg：求指定字段平均值</p><img src="/2023/03/24/ElasticSearch/48.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>max：求指定字段最大值，min：求指定字段最小值</p><img src="/2023/03/24/ElasticSearch/49.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>sum：求指定字段总和</p><img src="/2023/03/24/ElasticSearch/50.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>value_count：求所有统计数量</p><img src="/2023/03/24/ElasticSearch/51.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="②单值分析：其他类型"><a href="#②单值分析：其他类型" class="headerlink" title="②单值分析：其他类型"></a>②单值分析：其他类型</h6><blockquote><ul><li><p>weighted_avg：带权重，求平均值，如：a权重为0.3,b权重为0.7，求平均值：（0.3<em>a+0.7</em>b）&#x2F; 2</p><img src="/2023/03/24/ElasticSearch/52.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>cardinality：指定字段，根据字段值去重</p><img src="/2023/03/24/ElasticSearch/53.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>median_absolute_deviation：指定字段求中位数</p><img src="/2023/03/24/ElasticSearch/54.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="③非单值分析：stats"><a href="#③非单值分析：stats" class="headerlink" title="③非单值分析：stats"></a>③非单值分析：stats</h6><blockquote><ul><li><p>stats包括max、min、avg、sum</p><img src="/2023/03/24/ElasticSearch/55.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>matrix_stats：描述字段之间的关系，针对矩阵模型，count：统计数量，mean：平均值</p><img src="/2023/03/24/ElasticSearch/56.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>extended_stat：指定字段，汇总该字段的所有信息</p><img src="/2023/03/24/ElasticSearch/57.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="④非单值分析：百分型"><a href="#④非单值分析：百分型" class="headerlink" title="④非单值分析：百分型"></a>④非单值分析：百分型</h6><blockquote><ul><li><p>percentiles：根据指定字段计算百分比</p><img src="/2023/03/24/ElasticSearch/58.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>percentile_ranks：指定字段和值，统计该值内数值在总体占比，如下：</p><img src="/2023/03/24/ElasticSearch/59.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="⑤非单值分析：地理位置型"><a href="#⑤非单值分析：地理位置型" class="headerlink" title="⑤非单值分析：地理位置型"></a>⑤非单值分析：地理位置型</h6><blockquote><ul><li><p>geo_bounds：查找指定位置的坐标范围</p><img src="/2023/03/24/ElasticSearch/60.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（3）Pipeline聚合"><a href="#（3）Pipeline聚合" class="headerlink" title="（3）Pipeline聚合"></a>（3）Pipeline聚合</h5><blockquote><p>上一步的·聚合结果成为下一个聚合的输入</p></blockquote><h6 id="①Average聚合"><a href="#①Average聚合" class="headerlink" title="①Average聚合"></a>①Average聚合</h6><blockquote><p>在上一个bucket聚合的结果作为输入，输入到metrics聚合中求平均值</p><img src="/2023/03/24/ElasticSearch/61.png" class="" title="ElasticSearch"></blockquote><h3 id="5、原理分析"><a href="#5、原理分析" class="headerlink" title="5、原理分析"></a>5、原理分析</h3><blockquote><ul><li><p>一个ElasticSearch集群下，有多个node节点组成；</p></li><li><p>每个node节点上有多个分片，分为主分片和复制分片，主分片会将数据同步给复制分片；</p></li><li><p>一个分片对应一个Lucence Index索引结构；</p></li><li><p>一个Lucence Index上有多个Segment（即倒排索引），每个Segment存储文件即为文档数据；</p><img src="/2023/03/24/ElasticSearch/62.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（1）Lucence"><a href="#（1）Lucence" class="headerlink" title="（1）Lucence"></a>（1）Lucence</h5><h6 id="①Segment"><a href="#①Segment" class="headerlink" title="①Segment"></a>①Segment</h6><blockquote><ul><li>Shard&#x3D;Lucene Index</li><li>Lucene Index的Segment存放多种数据结构：<ol><li>Inverted Index（倒排索引）：分为两部分：一个有序的数据字典（单词term和出现频率）和与term对应的Posting列表（存放单词的文件），如：查询hello world时，将其分为hello和world两个单词，组成倒排索引（如下表）</li><li>自动补全：如果要查找以‘c’开头的词，会进行二分查找；</li><li>全表查找：查找包含‘our’字母的单词，会进行全表查询；</li><li>Document Values：列式存储，大大提升访问速度</li></ol></li></ul></blockquote><table><thead><tr><th>Dictionary</th><th>Posting List</th><th></th></tr></thead><tbody><tr><td>term</td><td>freq</td><td>documents</td></tr><tr><td>choice</td><td>1</td><td>2，3，4</td></tr><tr><td>come</td><td>4</td><td>3，5，6</td></tr><tr><td>hello</td><td>2</td><td>6，7，8</td></tr><tr><td>ours</td><td>3</td><td>4，7，8</td></tr></tbody></table><h6 id="②搜索中"><a href="#②搜索中" class="headerlink" title="②搜索中"></a>②搜索中</h6><blockquote><ol><li><p>搜索每一个segament，然后合并搜索结果；</p></li><li><p>Segment是不可变的，删除时，数据依旧保存在文件中，只是标记为删除；更新时，先删除，然后重新索引</p></li><li><p>Lucence会对存储数据进行压缩；</p></li><li><p>lecence会缓存所有数据，提高查询效率；</p><img src="/2023/03/24/ElasticSearch/63.png" class="" title="ElasticSearch"></li></ol></blockquote><h6 id="③缓存"><a href="#③缓存" class="headerlink" title="③缓存"></a>③缓存</h6><blockquote><ol><li>索引文件时，会对文件建立缓存，并定期刷新数据；</li><li>随着数据的增多，会产生大量segment，增加索引文件时，会将segment合并，删除</li></ol></blockquote><h5 id="（2）Shard"><a href="#（2）Shard" class="headerlink" title="（2）Shard"></a>（2）Shard</h5><blockquote><ol><li>Shard可能分布在不同的节点机器上，搜索返回结果会在网络中传输；</li><li>每个节点都会存储一份路由表，记录节点上shard信息等，请求到任何节点，都可以转发到对应的shard上的node节点；</li></ol></blockquote><h5 id="（3）Es分析器"><a href="#（3）Es分析器" class="headerlink" title="（3）Es分析器"></a>（3）Es分析器</h5><blockquote><p>①分为三部分：</p><ul><li>字符串过滤器：字符串分词前，将HTML标签去掉，替换&amp;为and；</li><li>分词器：将字符串分为一个个单词，简单的分词器，遇到空格或标点符号就会分词；</li><li>Token过滤器：将分好的词按顺序进入过滤，可能会改变词，如：小写化，删除无用词条，增加同义词条</li></ul><p>②内置分词器：</p><p>例子：Hello world （5）</p><ul><li>标准分析器：es默认分词器，根据Unicode定义的单词边界划分文本，去除大部分标点符号，最后词条小写，如【hello，world，5】；</li><li>简单分析器：任何不是字母的地方进行分词，最后词条小写，如【hello，world】；</li><li>空格分析器：以空格划分文本，如【Hello，world，（5）】；</li><li>语言分析器：会将无用单词删除，同时提取英语的词干，如</li></ul><p>I am watching TV and doing homework–&gt;【I，am，watch，TV，do，homework】</p></blockquote><h5 id="（4）索引原理"><a href="#（4）索引原理" class="headerlink" title="（4）索引原理"></a>（4）索引原理</h5><h6 id="①文档索引创建流程"><a href="#①文档索引创建流程" class="headerlink" title="①文档索引创建流程"></a>①文档索引创建流程</h6><blockquote><ul><li><p>客户端发送创建索引请求转发到node1节点；</p></li><li><p>根据文档id确定文档分片属于p2，请求转发到Node3；</p></li><li><p>Node3索引数据创建成功，请求转发到Node1，Node2副分片节点上，所有节点创建成功，Node3向协调节点报告成功，协调节点向客户端报告成功；</p><img src="/2023/03/24/ElasticSearch/64.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="②索引流程"><a href="#②索引流程" class="headerlink" title="②索引流程"></a>②索引流程</h6><blockquote><ul><li>协调节点通过文档id，计算请求对应的分片，请求转发到对应的节点分片上；</li><li>分片接收到请求后，会将请求数据写入到Memory Buffer中，每隔一秒更新到FileSystem缓存中；</li><li>缓存中的数据可能会丢失，所以每次请求会写入进Transaction日志中（保证可靠性），当缓存数据写入磁盘时，会清除transaction日志；</li><li>transaction日志flush过程中，会将数据刷新到磁盘，同时内容写入一个新的transaction日志中，删除原来的日志，flush每30分钟执行一次，或日志文件大小超过512M时也会触发；</li></ul><p>transLog日志，对未提交的数据，保证对未提交的数据可以通过id实时访问到</p><img src="/2023/03/24/ElasticSearch/65.png" class="" title="ElasticSearch"></blockquote><h6 id="③数据持久化过程"><a href="#③数据持久化过程" class="headerlink" title="③数据持久化过程"></a>③数据持久化过程</h6><blockquote><p>主要步骤：write—refresh—flush—merge</p><ul><li>write：一个新文档会被写入到内存缓冲区中，同时也会写入transLog日志中，此时文档还未写入Segment中，所以是搜索不到新文档的，需要refresh后才能搜索到，Commit point记录所有segment元信息</li><li><img src="/2023/03/24/ElasticSearch/66.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>refresh：每隔一秒执行一次刷新，将数据写入到segment中，segment存储在内存中，且可以在segment中搜索到数据，刷新后，清空内存缓冲区数据；该阶段可能会发送数据丢失</p><img src="/2023/03/24/ElasticSearch/67.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>flush：每隔30分钟或translog日志文件过大时，就会刷新，创建新的translog日志，删除旧日志；</p></li><li><ul><li><p>所有内存缓冲区的数据被写入Segment中；</p></li><li><p>内存缓冲区被清空；</p></li><li><p>将commit point中所有数据写入到磁盘中；</p></li><li><p>此时索引数据已经写入磁盘，已经持久化，因此不需要原日志数据保证数据安全，清除原translog日志；</p><img src="/2023/03/24/ElasticSearch/68.png" class="" title="ElasticSearch"></li></ul></li></ul></blockquote><blockquote><ul><li><p>Merge：每秒刷新会创建大量segment，而搜索时会必须轮询每一个段，段越多，搜索效率越差。es后台会将小段合并，大段合并到更大的段，refresh时，会创建新的段，从已有段选取大小合适的段，与新段合并，然后删除旧的段；</p><img src="/2023/03/24/ElasticSearch/69.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（5）读取文档流程"><a href="#（5）读取文档流程" class="headerlink" title="（5）读取文档流程"></a>（5）读取文档流程</h5><blockquote><ul><li><p>初始查询阶段，查询会广播道每一个分片，每一个分片在本地执行搜索，并构建一个匹配文档大小的from+size队列（文档查询是在FileSystem Cache中查询，可能存在Memory Buffer有数据未刷新到FileSystem Cache中，所以是近实时查询）；</p></li><li><p>每一个分片返回各自的队列，队列中存储文档id，协调节点的队列合并这些分片返回的队列，生成一个全局排序的队列；</p></li><li><p>协调节点分辨出那个文档要取回阶段，根据文档id获取文档完整数据，返回给客户端；</p><img src="/2023/03/24/ElasticSearch/70.png" class="" title="ElasticSearch"></li></ul></blockquote><h3 id="6、索引优化"><a href="#6、索引优化" class="headerlink" title="6、索引优化"></a>6、索引优化</h3><blockquote><ol><li>大量数据提交的时候，采用批量提交（bulk），一次批量提交的请求不超过几十MB，太大会使用过多内存；出现EsRejectExceuttionException异常时，说明es索引已经到极限，应减少数据收集。</li><li>es写入数据采用的是延迟写入数据，每1秒会将Memory Buffer数据刷新（refresh）到Segment中，segment会进行合并，这样数据才能检索到，是近实时的，可以通过延长refresh的时间间隔，减少segment合并压力，提高索引速度（index_refresh_interval）。</li><li>通过设置index_buffer_size大小，调整分配内存大小给索引进程，默认为10%，即该数值内存分配到不同的分片上。</li><li>调整index.translog.sync_interval参数，调整日志刷新到磁盘的大小（默认5秒）,从而减少I&#x2F;O操作，index.translog.flush_threashold_size参数，当达到threshold大小时，才会flush刷新到Lucene索引文件中。</li><li>_id使用es生成的id，避免自定义生成id，以避免对id的版本管理。</li><li>_all包含了所有索引字段，便于全文检索，业务不需要时可以关闭，_source存储了原始文档，如果没有需求获取原始数据，可以通过includes、excludes属性判断数据是否放入_source字段。可以减少数据取回阶段发送的请求。</li><li>es默认副本数量为3，虽然可以提高集群可用性，但会影响写入效率，数据写入后，同时要更新到副节点上，等副节点文档生效后，才会返回。</li></ol></blockquote><h3 id="7、查询优化"><a href="#7、查询优化" class="headerlink" title="7、查询优化"></a>7、查询优化</h3><blockquote><ul><li>路由优化：</li></ul><ol><li><ol><li>不带路由：请求发送到协调节点上，协调节点将请求分发到每一个分片，将每一个分片返回的结果进行排序汇聚，之后返回给用户；</li><li>带routing查询：查询时，根据路由分发到对应的分片上，不用查询所有分片，经过协调节点排序返回，routing设置为用户id，效率会提升；</li></ol></li></ol><ul><li>尽量使用filter替代query，filter对插叙只需回答是或不是，不会计算相关性评分，效率比query高，同时filter可以进行缓存。</li><li>避免大分页，正常分页from到size，是要每个分片查询from+size条数据，即n*（from+size），返回给协调节点进行排序，若数据量过大，会耗费大量CPU资源；可以通过设置文档id为偏移量，将其作为分页条件。</li><li>Cache设置：</li></ul><ol><li><ol><li>QueryCache：filter查询结果后会进行缓存，可以通过设置indicis.queries.cache,size参数，调整缓存大小；</li><li>FieldDataCache：聚类和排序下，可以设置字段数据缓存大小；</li><li>ShardRequestCache：分片查询结果缓存，不会缓存hits内容</li></ol></li></ol><ul><li>避免查询过多数据，避免过深的聚合查询，层级过深的聚合查询，会耗费大量CPU资源；</li></ul></blockquote><h3 id="8、数据结构优化"><a href="#8、数据结构优化" class="headerlink" title="8、数据结构优化"></a>8、数据结构优化</h3><blockquote><ol><li>减少不需要的字段，不需要用于搜索的字段，不要存储到ES中，提高效率，节约空间；</li><li>避免动态映射，动态映射带来不可控制的数据类型，可能导致查询异常；</li><li>document模型设计时，考虑好关联查询等情况，避免在es使用关联查询或更加复杂的操作；</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java遗传算法组卷</title>
    <link href="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/"/>
    <url>/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、遗传算法介绍"><a href="#一、遗传算法介绍" class="headerlink" title="一、遗传算法介绍"></a>一、遗传算法介绍</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote><p>遗传算法是模拟达尔文的生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种随机搜索全局最优解的方法。它模拟自然选择和遗传中发生的<u><strong>复制、交叉、变异</strong></u>等现象。一个种群通过随机选择、变异。交叉。复制，不断产生适应度更大的个体（适应度越大，被选择的概率越大），最终得到一群最适应环境的个体。</p></blockquote><h4 id="2、执行流程"><a href="#2、执行流程" class="headerlink" title="2、执行流程"></a>2、执行流程</h4><h5 id="（1）编码"><a href="#（1）编码" class="headerlink" title="（1）编码"></a>（1）编码</h5><blockquote><p>遗传算法里，优化问题的解被称为个体，基因串代表一个个体。基因串一般被表达为简单的字符串或数字符串，不过也有其他的依赖于特殊问题的表示方法适用；一个基因串可表示如下：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/1.png" class="" title="遗传算法"></blockquote><h5 id="（2）初始胡种群"><a href="#（2）初始胡种群" class="headerlink" title="（2）初始胡种群"></a>（2）初始胡种群</h5><blockquote><p>种群可以看作是个体的集合。初始化种群主要是随机生成一定数量的个体组合为种群；这个初始化的过程我们可以进行干预，以提高初始化种群的质量。每个个体对应一个适应度数值。种群如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/2.png" class="" title="遗传算法"></blockquote><h5 id="（3）进化"><a href="#（3）进化" class="headerlink" title="（3）进化"></a>（3）进化</h5><blockquote><p>进化流程包括：评估适应性函数，根据适应度选择个体，并进行交叉，变异，复制。如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/3.png" class="" title="遗传算法"></blockquote><h3 id="二、遗传算法组卷"><a href="#二、遗传算法组卷" class="headerlink" title="二、遗传算法组卷"></a>二、遗传算法组卷</h3><h4 id="1、试卷编码"><a href="#1、试卷编码" class="headerlink" title="1、试卷编码"></a>1、试卷编码</h4><blockquote><p>（1）题库组卷中，一份试卷代表一个个体，多份试卷组合为一个种群，在种群中，不断进化获取最优解，最终获取适应度最高的试卷，即为最优解；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/5.png" class="" title="遗传算法"><p>（2）个体由基因型表示，试卷主要包括单选题（8道），多选题（2道），判断题（2道），大题（2道），我们以题目的题号（主键id）当做基因型的编号，如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/4.png" class="" title="遗传算法"></blockquote><h4 id="2、初始化种群"><a href="#2、初始化种群" class="headerlink" title="2、初始化种群"></a>2、初始化种群</h4><blockquote><p>（1）试卷难度我们分为简单，中等，难（数据库中题目难度分为三个等级1，2，3）。在题库中选择题目时，按照我们规定的题型比例选取题目。在初始化时，我们进行干预，适当提高种群的适应度。</p><p>（2）用户选择简单，初始化种群时，选择难度&#x3D;1的题目进行组合；用户选择中等，选择难度&#x3D;1或难度&#x3D;2的题目进行组合；用户选择困难，选择难度&#x3D;2的题目进行组合，如下图:</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/6.png" class="" title="遗传算法"></blockquote><h4 id="3、终止条件"><a href="#3、终止条件" class="headerlink" title="3、终止条件"></a>3、终止条件</h4><blockquote><p>（1）题库组卷中，根据用户选择的难度，对应不同的期望度（目标值），试卷的适应度不断趋近这个期望度。</p><p>（2）当试卷适应度&gt;&#x3D;目标期望值，终止寻找，找到最优解；当进化的代数超过我们指定的最大进化数，终止寻找；当试卷适应度已经达到最大适应度，终止寻找</p></blockquote><h4 id="4、适应度函数计算"><a href="#4、适应度函数计算" class="headerlink" title="4、适应度函数计算"></a>4、适应度函数计算</h4><blockquote><p>（1）试卷难度计算公式：题目分值*难度 &#x2F; 总分；</p><p>（2）试卷知识点覆盖率：不同知识点数 &#x2F; 题目总数；</p><p>（3）试卷的适应度，需要考虑到整体试卷的难度以及试卷知识点的覆盖率，N知识点分布权重，M为难度系数所占权重，公式如下：</p><p>适应度&#x3D;不同知识点数 &#x2F; 题目总数<em>N+题目分值</em>难度 &#x2F; 总分*M</p></blockquote><h4 id="5、交叉"><a href="#5、交叉" class="headerlink" title="5、交叉"></a>5、交叉</h4><blockquote><p>（1）在种群中，随机选择两个适应度较高的个体进行交叉（不一定选择到适应度最高的个体），进行基因交换，获取新个体。</p><p>（2）个体选择采用轮盘赌算法，适应度越大的个体，被选中的概率越大（但也不一定被选中），轮盘赌算法如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/7.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/8.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/9.png" class="" title="遗传算法"><p>（3）两个个体进行交叉，利用随机函数产生交叉点，选取父个体边界点左边的编号，选取母个体边界点右边的编号，组合成新的基因，同时要判断是否有重复题型，重复题型则到题库中选取类型，难度一致的题目进行替换</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/10.png" class="" title="遗传算法"></blockquote><h4 id="6、变异"><a href="#6、变异" class="headerlink" title="6、变异"></a>6、变异</h4><blockquote><p>（1）变异是随机的，按照我们指定的变异率，随机选取个体进行变异，变异后的编号若重复，则重新查找；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/11.png" class="" title="遗传算法"><p>（2）题库选题去重，遇到重复题库，先删除，放到删除题库中，等操作完再添加1回去，如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/12.png" class="" title="遗传算法"><p>（3）在种群进化中，按照我们规定的代数n，进化代数达到n，变异率变大2倍，最终不超过我们指定的最大变异率（一般为10%），如：进化代数：n&#x3D;5</p><p>若变异率m&#x3D;0.01，当进化到第五代时，m&#x3D;m*2&#x3D;0.01；当进化到第十代时，m&#x3D;0.04。</p><p>若变异率m&#x3D;0.1，当进化到第五代时，m&#x3D;0.1，当进化到第十代时，m&#x3D;0.1</p></blockquote><h4 id="7、复制"><a href="#7、复制" class="headerlink" title="7、复制"></a>7、复制</h4><blockquote><p>根据个体的适应度进行快速排序（从小到大），然后按照复制的数量，从后往前进行个体复制</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/13.png" class="" title="遗传算法"><p>快排思路：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/14.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/15.png" class="" title="遗传算法"></blockquote><h4 id="8、修正"><a href="#8、修正" class="headerlink" title="8、修正"></a>8、修正</h4><blockquote><p>（1）在进化时，我们会指定一个m，n和种群最佳适应度s，每一次进化后，会计算种群适应度，大于最佳适应度，更新最佳适应度；m则是种群达不到最佳适应度的最大进化数；n则是实际种群达不到最佳适应度的进化数。</p><p>（2）当进化时，种群的总体适应度达不到最佳适应度，n++，当n&gt;&#x3D;m时，需要进行种群修正，也就是变异，随机选取个体进行变异；</p><p>（3）重新计算种群适应度，更新最佳适应度，将n置0。</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/16.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/17.png" class="" title="遗传算法"></blockquote><h4 id="9、整体业务流程"><a href="#9、整体业务流程" class="headerlink" title="9、整体业务流程"></a>9、整体业务流程</h4><blockquote><p>（1）从数据库中查询所有题目，按题型分类存放；</p><p>（2）创建配置类（进化算法需要的参数类），同时处理用户输入过来的参数；</p><p>（3）初始化一个种群（个体编码，组合种群）；</p><p>（4）种群进化，计算适应度，交叉，变异，复制，修正；</p><p>（5）选取种群适应度最高个体，返回结果；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/18.png" class="" title="遗传算法"></blockquote><h4 id="10、github链接"><a href="#10、github链接" class="headerlink" title="10、github链接"></a>10、github链接</h4><blockquote><p><a href="https://github.com/swttws/java-PlateForm-app">https://github.com/swttws/java-PlateForm-app</a></p><p>在src&#x2F;main&#x2F;java&#x2F;com&#x2F;su&#x2F;ga包下</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/17/hello-world/"/>
    <url>/2023/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h4 id="1、进程："><a href="#1、进程：" class="headerlink" title="1、进程："></a>1、进程：</h4><p>（1）运行的程序，例如使用QQ，就启动一个进程，操作系统为该进程分配内存空间；<br>（2）进程是程序的一次执行过程，是动态过程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.jpeg" class="" title="java线程"><h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><p>（1）线程有进程创建，是进程实体；<br>（2）一个进程可以拥有多个线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.jpeg" class="" title="java线程"><h4 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h4><p>同一时刻，多个任务交替执行，单核CPU实现任务就是并发；</p><h4 id="4、并行"><a href="#4、并行" class="headerlink" title="4、并行"></a>4、并行</h4><p>同一时刻，多个任务同时执行，多核CPU可以实现并行；</p><h4 id="5、线程执行机制"><a href="#5、线程执行机制" class="headerlink" title="5、线程执行机制"></a>5、线程执行机制</h4><p>（1）主线程结束，其他子线程还在运行，进程就会继续存活；<br>（2）所有线程挂掉，进程才会挂掉；<br>（3）run()方法为一个普通方法，并不会真正启动线程，会等run执行完毕后才会继续执行下面代码；<br>（4）start（）方法才会启动线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.jpeg" class="" title="java线程"><h4 id="6、线程启动"><a href="#6、线程启动" class="headerlink" title="6、线程启动"></a>6、线程启动</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.jpeg" class="" title="java线程"><p>（1）执行start（）方法<br>同时执行两个线程，一个执行start的线程，一个执行run的线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png" class="" title="java线程"><p>（2）本地方法，JVM调用，底层为c&#x2F;c++实现，真正实现多线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png" class="" title="java线程"><h4 id="7、线程终止唤醒阻塞状态线程"><a href="#7、线程终止唤醒阻塞状态线程" class="headerlink" title="7、线程终止唤醒阻塞状态线程"></a>7、线程终止唤醒阻塞状态线程</h4><p>（1）interrupt：设置共享变量为true，唤醒阻塞线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.jpeg" class="" title="java线程"><h4 id="8、join方法"><a href="#8、join方法" class="headerlink" title="8、join方法"></a>8、join方法</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/9.jpeg" class="" title="java线程"><h2 id="二、Thread线程常用方法"><a href="#二、Thread线程常用方法" class="headerlink" title="二、Thread线程常用方法"></a>二、Thread线程常用方法</h2><p>1、join（）方法：线程插队，线程一旦插队成功，肯定先执行完插入的线程的所有任务；<br>2、yield：让出CPU，让其他1线程执行，礼让时间不确定，不一定礼让成功<br>3、守护线程：当所有的用户线程结束，守护线程就会结束；<br>例：垃圾回收机制</p><h2 id="三、线程状态"><a href="#三、线程状态" class="headerlink" title="三、线程状态"></a>三、线程状态</h2><p>（1）java线程中有6种状态；<br>（2）操作系统中有5种状态；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.jpeg" class="" title="java线程"><h2 id="四、线程同步与锁"><a href="#四、线程同步与锁" class="headerlink" title="四、线程同步与锁"></a>四、线程同步与锁</h2><p>1、线程同步机制：使用同步机制保证数据在任何同一时刻，最多只有一个线程访问，以保证数据完整；<br>2、Synchronized同步原理：</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/11.jpeg" class="" title="java线程"><p>3、互斥锁：<br>（1）每个对象都有一个可称为“互斥锁”的标记，这个标记只能保证任意时刻只有一个线程访问该对象；<br>（2）影响程序执行效率；<br>（3）同步方法（非静态的）的锁可以是this对象，也可以是其他对象；<br>（4）同步方法（静态的）的锁为当前类本身；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/12.png" class="" title="java线程"><p>4、线程死锁：多个线程占用对方资源，不肯相让，导致形成死锁；<br>5、释放锁：<br>（1）线程同步方法，同步代码块执行结束；<br>（2）线程同步方法、同步代码块遇到break、return；<br>（3）出现未处理的error或Exception，导致异常结束；<br>（4）执行线程中wait（）方法，线程暂停，释放锁<br>sleep（），yield（），suspend（)不会释放锁</p><hr><h2 id="1、Object-wait"><a href="#1、Object-wait" class="headerlink" title="1、Object.wait()"></a>1、Object.wait()</h2><p>（1）一定要持有到调wait方法那个对象的锁，wait代码段放在synchronized块中；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/13.png" class="" title="java线程"><p>（2）持有该对象锁的线程，执行notify或notifyAll方法可以唤醒等待线程；<br>（3）调用wait后，会将该对象锁释放，进入等待状态，线程加入waitSet集合，waitSet底层是双向链表；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.png" class="" title="java线程"><p>（4)该线程被唤醒后，会与其他线程公平竞争该对象锁，只有该线程获取到对象锁后，才会继续往下执行；</p><hr><h2 id="2、Object-notify-、notifyAll（）"><a href="#2、Object-notify-、notifyAll（）" class="headerlink" title="2、Object.notify()、notifyAll（）"></a>2、Object.notify()、notifyAll（）</h2><p>（1）当调用对象notify方法时，会随机唤醒等待集合中一个线程，唤醒线程与其他线程公平竞争锁；<br>  从WaitSet集合中选出一个线程，加入到EntryLsit集合中<br>（2）当调用notifyAll方法时，唤醒等待集合所有线程；<br>（3）在某一时刻，只有唯一线程可以获取对象锁；</p><hr><h2 id="3、synchronized关键字"><a href="#3、synchronized关键字" class="headerlink" title="3、synchronized关键字"></a>3、synchronized关键字</h2><p>（1）同一个对象，多个synchronized方法，多个线程某一个时刻同时访问，只能先执行一个方法；（锁为对创建的对象锁）<br>（2）synchronized修饰的静态方法，多个对象中，多个线程只能访问一个线程去访问（对该对象的Class对象加锁）；<br>（3）synchroinzed修饰代码块，通过 monitorenter和monitorexit来获取锁和释放锁；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/15.png" class="" title="java线程"><p>（4）JVM同步基于进入与退出监视器对象（Monitor）来实现，每个对象实例·会有个Monitor对象，monitor对象和java对象一并创建并销毁，monitor由c++创建；<br>（5）多个线程访问一段同步代码块，获取不到锁的线程会放入Entrylist集合，处于阻塞的线程会被放入该集合中，当线程获取到Monitor对象时，monitor对象依赖于底层操作系统的mutex_lock（互斥锁），线程获取成功后，会持有mutex，其他线程无法获取mutex；<br>（6）基于底层操作系统的mutex_Lock来实现，每次锁的获取与释放都会带来用户态与内核态的切换，并发量高时，synchronized锁性能非常差；<br>（7）调用wait方法的线程会进入waitset集合，处于阻塞状态的线程会进入EntryList集合中，waitset中的线程被notify唤醒后，若争抢不到锁，线程会加入EntryList集合，进而进入内核状态；<br>解决上述方法：自旋，其原理：发生岁monitor的争用时，若Owner能够很短时间内释放该锁，则那些正在争用的线程可以自旋，在Owner释放锁后，会立即获取到锁，从而避免阻塞，争用一段时间后若无法获取锁，则进入阻塞状态。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/17.png" class="" title="java线程"><p>（8)互斥锁属性<br>【1】P_THREAD_MUTEX_TMIED_NP：普通锁，当一个线程加锁后，其余线程进入等待队列，并且在解锁后按照优先级获取锁，从而确保资源分配的公平性；<br>【2】P_THREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并通过unlock进行解锁，如果是不同新城请求，可通过加锁线程解锁后重新进行竞争；<br>【3】P_THREAD_MUTEX_ERRORCHECK_NP：检错锁，一个线程请求同一个锁，则返回EDEADLK，否则与【1】锁一样，不允许多次加锁时不会出现死锁；<br>【4】P_THREAD_MUTEX_ADAPTIVE_NP：适应锁，仅仅等待解锁后重新竞争；</p><hr><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>（1）对于锁的访问与java对象头相关，java对象头包括Mark Word、指向类指针、数组长度；<br>（2）Mark Word记录了对象、锁及垃圾回收相关信息，包括如下组成部分：<br>【1】无锁标记<br>【2】偏向锁标记<br>【3】轻量级锁标记<br>【4】重量级锁标记：synchroinzed标记<br>【5】GC标记<br>（3）锁演化阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<br>（4）偏向锁：<br>对于一个线程，主要作用是优化同一个线程多次获取同一个一个锁的情况，如果一个synchroinzed方法被一个线程访问，synchroinzed方法所在对象就会在起Mark Word中将偏向锁标记，同时还有一个字段存储线程id，，当这个线程继续访问同一个synchroinzed方法时，他会检查这个对象的Mark Word偏向锁标记以及是否指向该id：(建议关闭偏向锁)<br>【1】如果是同一个线程，线程无须进入内核态，而是直接进入方法中；<br>【2】如果是另外一个线程访问synchroinzed方法，偏向锁取消；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/18.png" class="" title="java线程"><p>（5）轻量级锁：（适合两个线程轮流访问），如自旋锁<br>若第一个线程已经获取到当前对象锁，这时第二个线程尝试争抢该对象锁，由于该对象的锁已经被第一个线程获取到，因此他是偏向锁。第二个线程在争抢时，会发现对象头中的Mark Word已经是偏向锁标记，，但里面存储的id并不是自己，则会进行CAS，从而获取到锁。两种情况：<br>【1】获取锁成功：会将Mark Word里的线程id由第一个线程变成自己的，这样对象依旧保持偏向锁状态；<br>【2】获取失败：则表示这可能有多个线程争抢对象锁，那么偏向锁升级，升级为轻量锁；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/19.png" class="" title="java线程"><p>（6）重量级锁<br>若自旋失败，锁会转换为重量级锁，无法获取到锁的对象都会进入Monitor（内核态)；自旋可以避免线程从用户态进入内核态；</p><hr><h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>（1）死锁线程1等待线程2互斥持有的资源，线程2等待线程1互斥持有的资源，两个线程无法继续执行；<br>（2）活锁：线程持续重试一个总是失败的操作，导致无法继续操作；<br>（3）饿死：线程一直被调度器延迟访问其可执行的资源，调度器先于优先级低的线程而执行高优先级线程，则总是执行高优先级线程，导致该线程一直无法执行；</p><hr><h2 id="6、Lock锁机制"><a href="#6、Lock锁机制" class="headerlink" title="6、Lock锁机制"></a>6、Lock锁机制</h2><p>（1）lock与synchroinzed区别：<br>【1】锁释放：lock必须通过unlock方法在finally中手动释放，synchroinzed通过jvm释放，synchroinzed锁的释放是按照加锁时的相反顺序释放，如加A锁，再加B锁，先释放B锁，再释放A锁，Lock锁的释放可以以任意顺序释放；<br>【2】锁获取：lock通过代码手工获取锁，synchroinzed通过jvm获取锁，无需开发者干预；<br>【3】具体实现方式：lock通过java代码实现，synchroinzed通过jvm底层实现；<br>【4】锁类型：lock提供多种，如公平锁，非公平锁，synchroinzed与lock均提供可重入锁；<br>（2）tryLock（）方法：获取到锁会返回true，获取不到则会放回false</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/20.png" class="" title="java线程"><p>（3）ReentrantLock 可重入锁：一个线程可以重复获取同一个锁，即使锁没有释放；</p><hr><h2 id="7、Condition"><a href="#7、Condition" class="headerlink" title="7、Condition"></a>7、Condition</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/21.png" class="" title="java线程"><p>（1）await</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/22.png" class="" title="java线程"><p>（2）condition.signal()<br>①原tail结点是CANCELLED状态；<br>②condition的结点transfer到AQS队列之后，通过lock.unlock()去唤醒；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/23.png" class="" title="java线程"><p>（3）传统可以通过synchroinzed+wait+notify&#x2F;notigyAll来实现多个线程之间的通信，整个过程由JVM实现，开发者无需了解底层实现细节；<br>（4）从jdk1.5后，并发包提供lock和Condition（await与signal&#x2F;signalAll）来实现多个线程之间通信，整个过程由开发者控制；<br>（5）Conditidion支持一个对象拥有多个waitset等待集合，而传统方式只允许有一个waitset集合；<br>（6）Condition必须关联一个lock,一个lock可以生成多个condition对象；<br>（7）await（）方法为避免被假唤醒，应当放入while循环中，调用await后会释放锁，需要signal（)方法唤醒才能继续执行；</p><hr><h2 id="8、volatile关键字（保证可见性）"><a href="#8、volatile关键字（保证可见性）" class="headerlink" title="8、volatile关键字（保证可见性）"></a>8、volatile关键字（保证可见性）</h2><p>（1）实现long&#x2F;double类型变量的原子操作，变量不会从寄存器获取变量，而是从内存（高速缓存）中获取；要实现原子性，等号右侧的赋值变量中不能出现被多线程所共享的变量，即使这个变量被volatile修饰也不行；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/24.png" class="" title="java线程"><p>（2）指令重排序</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/25.png" class="" title="java线程"><p>（3)内存屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-comment">//volatile会自动生成屏障</span><br><br>CPU0&#123;<br>a=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//storeMemoryBarrier()写屏障，写入到内存中</span><br>b=<span class="hljs-number">1</span>;<br>&#125;<br><br>CPU1&#123;<br><span class="hljs-keyword">while</span>(b==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//true</span><br>        <span class="hljs-comment">//loadMemoryBarrier();读屏障</span><br>        <span class="hljs-keyword">assert</span>(a==<span class="hljs-number">1</span>)<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/26.png" class="" title="java线程"><p>（4）防止指令重排序，实现变量的可见性的手段：内存屏障</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/27.png" class="" title="java线程"><hr><h2 id="9、java内存模型（JMM）"><a href="#9、java内存模型（JMM）" class="headerlink" title="9、java内存模型（JMM）"></a>9、java内存模型（JMM）</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/28.png" class="" title="java线程"><p>（1）顺序执行（限定在当个线程之上）:该线程的每个动作都happen-before它的后面动作；<br>（2）隐式锁（monitor）规则：unlock happen-before lock，之前的线程对于同步代码块的所有执行结果对于后序获取锁的线程来说都是可见的；<br>（3）volatile读写规则：对于一个volatile变量的写操作一定会happen-before后续对该变量的读操作；<br>（4）多线程启动规则：Thread对象的start方法happen-before该线程run方法中的任何一个动作，包括其中启动的任何子线程；<br>（5）多线程的终止规则：一个线程启动一个子线程，并且调用子线程join方法等待其结束那么当子线程结束后，父线程接下来的所有操作都可以看到子线程run方法中的执行结果；<br>（6)线程中断规则:可以用interrupt方法来中断线程，这个调用happen-before对该线程中断的检查；</p><hr><h2 id="10、CountDownLatch"><a href="#10、CountDownLatch" class="headerlink" title="10、CountDownLatch"></a>10、CountDownLatch</h2><p>（1）countDown（）方法：计数器不为0，计数器值减减，计数器最小值为0；<br>（2）await（）方法：调用该方法的线程，判断计数器是否为0，不为0，则阻塞，为0，直接继续执行线程；<br>（3）计数器为一次性的；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/29.png" class="" title="java线程"><p>（4)唤醒线程源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>   <span class="hljs-comment">//s为null，并行操作中，添加时，可能还没有执行next=线程，导致head.next=null</span><br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>           s = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//往尾结点找head.next</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                   s = t;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>           LockSupport.unpark(s.thread);<br>   &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="11、CyclicBarrier"><a href="#11、CyclicBarrier" class="headerlink" title="11、CyclicBarrier"></a>11、CyclicBarrier</h2><p>（1）await（int count）方法，等待线程达到指定数量count，才能继续执行；<br>（2）计数器可以重用，计数器值为0后，值置为初始值；<br>（3）CyclicBarrier(int parties, Runnable barrierAction)，barrierAction在最后一个线程抵达屏障后，会执行；<br>（4）会出现并发情况；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/30.png" class="" title="java线程"><p>（4）底层执行流程：<br>【1】初始化各种成员变量，包括parties，count以及Runable；<br>【2】调用await方法时，底层会先检查是否已经归0，如果是，执行可选的Runable，接下来进行下一个generation；<br>【3】在下一个分代中，将会重置count为parties，并且创建新的Generation实例；<br>【4】接下来signalAll方法，唤醒所有在屏障前面等待线程，让其继续开始执行；<br>【5】计数器没有归0，调用线程将会通过Condition的await方法在屏障前等待；<br>【6】执行过程在lock锁内，不会出现并发情况；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/31.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/32.png" class="" title="java线程"><hr><p><strong>12、CAS（Compare And Swap）</strong><br>（1）synchronized关键字与lock锁等锁机制都是悲观锁：无论任何操作，首先要获取锁，再执行后续操作，从而确保所有操作都是由当前这个线程来执行的；<br>（2）乐观锁：线程操做之前不会做任何预先处理，而是直接执行，当在最后执行变量更新的时候，当前线程需要由一种机制确保当前被操作的变量没有被其他线程修改；<br>（3）CAS为乐观锁的一种实现方式，比较与交换，不断循环，直到变量被成功修改为止，CAS本身通过硬件指令来提供支持，硬件通过一个指令来实现交换与比较，因此CAS可以确保变量操作的原子性；<br>（4）CAS操作数涉及如下：<br>【1】需要被操作的内存值V；<br>【2】需要进行比较的值A；<br>【3】需要进行写入的值B；<br>【4】只有当V&#x3D;&#x3D;A时，CAS才会通过原子操作的手段来将V的值更新为B；<br>（5）问题：<br>【1】循环开销问题：并发量大的情况下会导致线程一直自旋；<br>【2】只能保证一个变量的原子操作：可以通过AtomicReference来实现对多个变量的原子操作；<br>【3】ABA问题：1-&gt;3-&gt;1</p><hr><h2 id="13、CompletableFuture"><a href="#13、CompletableFuture" class="headerlink" title="13、CompletableFuture"></a>13、CompletableFuture</h2><p>异步执行，whenComplete（）等待任务执行返回结果，不会阻塞主线程的执行</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/33.png" class="" title="java线程"><hr><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><p>（1）本质上·，ThreadLocal是通过空间换取时间，从而实现每一个线程中间都会有一个变量的副本，这样每个线程都会操作该变量副本，从而避免多线程并发问题；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/34.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/35.png" class="" title="java线程"><p>（2）ThreadLocl与该运行的线程相绑定，每个线程对应不同ThreadLocal；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/36.png" class="" title="java线程"><p>（3）java四种类型引用<br>【1】强引用：new一个实例，GC不会回收new出来实例对象；<br>【2】软引用：如果GC内存空间回收时，空间不够，会清除软引用，空间够，则不会清楚；<br>【3】弱引用：下一次GC回收，会被清理；<br>【4】虚引用：指向队列的元素被清理时，会收到通知<br>（4）Entry使用弱引用为了避免内存泄漏<br>【1】若Entry中使用强引用，当栈中ThreadLocal引用销毁时，Entry中的kv一直存在，导致Entry的kv一直增加，导致内存泄漏；<br>【2】使用弱引用可以保证，当堆中的ThreadLocal对象只被弱引用所指向，会被GC回收，Entry中的Key置为null；<br>【3】当调用ThreadLocal的set和get方法时，会清除键为null的Entry对象；也可以通过调用remove方法删除指定key的Entry对象</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/37.png" class="" title="java线程"><hr><h2 id="15、AQS（AbstractQueuedSynchronizer）"><a href="#15、AQS（AbstractQueuedSynchronizer）" class="headerlink" title="15、AQS（AbstractQueuedSynchronizer）"></a>15、AQS（AbstractQueuedSynchronizer）</h2><h4 id="（1）组成"><a href="#（1）组成" class="headerlink" title="（1）组成"></a>（1）组成</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/38.png" class="" title="java线程"><h4 id="（2）可重入锁（ReentrantLock）源码分析"><a href="#（2）可重入锁（ReentrantLock）源码分析" class="headerlink" title="（2）可重入锁（ReentrantLock）源码分析"></a>（2）可重入锁（ReentrantLock）源码分析</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/39.png" class="" title="java线程"><p>【1】尝试获取对象锁，获取不到（其他线程已经持有锁，并且尚未释放）,该线程会进入AQS阻塞队列中；<br>【2】如果获取到锁，那么根据是公平锁还是非公平锁进行不同处理：<br>①如果是公平锁，线程直接放入AQS队列尾部；<br>②如果是非公平锁，线程会先进行CAS计算，，如果成功直接获取锁，如果失败，则与公锁一致，被放入阻塞队列末尾；<br>③当锁被释放（调用unlock），那么会调用release方法对static成员变量值一直减一操作，如果减一后，state为0，那么relaease执行完毕，并且调用LockSupport的unpark方法唤醒该线程后的等待队列中的第一个后继线程，将其唤醒，使之获取到对象锁；锁可以重入，多次调用lock锁，导致每一次调用，state都会加1；<br>【3】本质上是对AQS的state成员变量操作，对该成员变量加1，表示上锁，减1，表示释放锁；<br>公平锁上锁</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/40.png" class="" title="java线程"><p>非公平锁上锁</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/41.png" class="" title="java线程"><h4 id="（3）可重入读写锁（ReentrantReadWriteLock）"><a href="#（3）可重入读写锁（ReentrantReadWriteLock）" class="headerlink" title="（3）可重入读写锁（ReentrantReadWriteLock）"></a>（3）可重入读写锁（ReentrantReadWriteLock）</h4><p>【1】读锁：获取读锁时，会尝试判断当前对象是否拥有写锁，如果已经拥有写锁，直接失败，如果没有写锁，则表示当前对象没有排他锁，则当前线程会尝试对象加锁，，如果当前线程已经拥有该对象的锁，直接将读锁数量加1；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/42.png" class="" title="java线程"><p>【2】写锁：获取写锁时，会尝试当前对象是否拥有锁（读锁与写锁），如果已拥有锁并且线程并非当前线程，直接失败；如果当前对象没有加锁，就会为当前对象上锁，并且将写锁数量加1，将当前对象的排他锁线程持有者设为自己；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/43.png" class="" title="java线程"><p>【3】读锁释放：</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/44.png" class="" title="java线程"><p>【4】写锁释放</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/45.png" class="" title="java线程"><h4 id="（4）条件队列与阻塞队列"><a href="#（4）条件队列与阻塞队列" class="headerlink" title="（4）条件队列与阻塞队列"></a>（4）条件队列与阻塞队列</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/46.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/47.png" class="" title="java线程"><h4 id="（5）阻塞队列（BlockingQueue）"><a href="#（5）阻塞队列（BlockingQueue）" class="headerlink" title="（5）阻塞队列（BlockingQueue）"></a>（5）阻塞队列（BlockingQueue）</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/48.png" class="" title="java线程"><h4 id="（5）AQS与synchronized关系"><a href="#（5）AQS与synchronized关系" class="headerlink" title="（5）AQS与synchronized关系"></a>（5）AQS与synchronized关系</h4><p>【1】synchronized在实现<br>①存在两个数据结构：waitset，EntryList，waitset中存放的是调用了Object的wait方法的线程对象，EntryList存放的陷入到阻塞状态，需要获取monitor线程对象<br>②当一个线程被notify后，线程会从waitset中移动到EntryList中，进入到EntryList后，该线程依旧需要与其他线程争抢monitor对象，如果争抢到，就获取到锁，可以执行；<br>【2】AQS实现<br>①存放两种数据结构：Conditiojn对象上的条件队列，以及AQS的阻塞队列，这两个对象每一个都是Node实例（封装线程对象）<br>②当位于condition条件队列的线程被其他线程signal后，该线程会被移动到阻塞队列中，位于AQS阻塞队列中的Node对象本质上由一个双向队列构成；<br>③在获取AQS锁中，这些进入阻塞队列的线程会按照队列顺序先后尝试获取；<br>④当AQS阻塞队列中线程获取到锁后表示该线程可以正常执行；<br>⑤陷入对等或阻塞状态的线程，依然需要进入操作系统内核态，进入阻塞（park方法实现）；</p><hr><h2 id="16、ConcurrentHashMap"><a href="#16、ConcurrentHashMap" class="headerlink" title="16、ConcurrentHashMap"></a>16、ConcurrentHashMap</h2><h3 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h3><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/49.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/50.png" class="" title="java线程"><h3 id="（2）put方法"><a href="#（2）put方法" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/51.png" class="" title="java线程"><h4 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<span class="hljs-comment">//初始化</span><br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//添加位置结点为空</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<span class="hljs-comment">//添加结点</span><br>                    <span class="hljs-keyword">break</span>;                  <br>              &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>       Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>        <span class="hljs-comment">//多个线程操作，需要不断自旋判断数组是否尾空</span><br>       <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>               Thread.<span class="hljs-keyword">yield</span>(); <br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//只有一个线程进入</span><br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<span class="hljs-comment">//默认长度16</span><br>                       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                       table = tab = nt;<br>                       sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<span class="hljs-comment">//扩容因子  16*0.75</span><br>                   &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   sizeCtl = sc;<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> tab;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）put阶段存在hash冲突"><a href="#（2）put阶段存在hash冲突" class="headerlink" title="（2）put阶段存在hash冲突"></a>（2）put阶段存在hash冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>        binCount = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录链表长度，用于后面判断是否需要树华</span><br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>            K ek;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                ((ek = e.key) == key ||<br>                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="hljs-comment">//key的值与存在结点的key一样，直接替换</span><br>                oldVal = e.val;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                    e.val = value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Node&lt;K,V&gt; pred = e;<span class="hljs-comment">//记录前驱结点</span><br>            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//直到下一个结点为null，添加新结点到位部</span><br>                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                          value, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）元素个数统计与更新（addCount）"><a href="#（3）元素个数统计与更新（addCount）" class="headerlink" title="（3）元素个数统计与更新（addCount）"></a>（3）元素个数统计与更新（addCount）</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/52.png" class="" title="java线程"><h5 id="①初始化"><a href="#①初始化" class="headerlink" title="①初始化"></a>①初始化</h5><blockquote><p>private transient volatile long baseCount; 没有竞争情况下，通过CAS更新元素个数<br>private transient volatile CounterCell[] counterCells;  多线程竞争情况下，存储元素个数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterCell</span> &#123;<br>       <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>       CounterCell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>   &#125;<br><br><span class="hljs-comment">//求总和</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>       CounterCell[] as = counterCells; CounterCell a;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>       <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>               <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                   sum += a.value;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>直接访问baseCount累加元素个数；</li><li>找到CounterCell[]随机下标位置，累加个数</li><li>如果前面失败，进入fullAddCount（）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> ||<br>     <span class="hljs-comment">//CAS修改元素个数，修改成功则不进入if</span><br>    !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>    CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>     <span class="hljs-comment">//counterCells数组为空</span><br>    <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>        <span class="hljs-comment">//CAS修改对应CounterCells，修改成功，不进入if</span><br>        !(uncontended =<br>          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>        fullAddCount(x, uncontended);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    s = sumCount();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②元素个数并发更新（fullAddCount）"><a href="#②元素个数并发更新（fullAddCount）" class="headerlink" title="②元素个数并发更新（fullAddCount）"></a>②元素个数并发更新（fullAddCount）</h5><blockquote><ol><li>CountCell为null</li><li>已经初始化，然后存在竞争，CAS进行更新-&gt;失败触发CounterCell扩容</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">CounterCell[] as; CounterCell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br><span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;            <br>            <span class="hljs-type">CounterCell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x); <br>            <span class="hljs-comment">//修改cellBusy为1，表示只有一个线程操作</span><br>            <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; <br>                U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                    CounterCell[] rs; <span class="hljs-type">int</span> m, j;<br>                    <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                        (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                        rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                        rs[j] = r;<br>                        created = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (created)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>            &#125;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>        wasUncontended = <span class="hljs-literal">true</span>;      <br>    <span class="hljs-comment">//存在，CAS修改</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>        collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>        collide = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//容量不够，需要扩容</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>             U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>                CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<span class="hljs-comment">//n为原本as的长度</span><br>                    rs[i] = as[i];<br>                counterCells = rs;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cellsBusy = <span class="hljs-number">0</span>;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>    &#125;<br>    h = ThreadLocalRandom.advanceProbe(h);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp; <span class="hljs-comment">//cellsBusy互斥变量</span><br>         U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//类似加锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                          <br>        <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<span class="hljs-comment">//x元素个数</span><br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">//释放</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, v = baseCount, v + x))<br>       <span class="hljs-keyword">break</span>;    <br></code></pre></td></tr></table></figure><h4 id="（4）扩容阶段"><a href="#（4）扩容阶段" class="headerlink" title="（4）扩容阶段"></a>（4）扩容阶段</h4><blockquote><ul><li>元素个数大于数组长度</li><li>此时正在扩容，扩容阶段进入的线程会协助扩容</li><li>数组长度大于64，链表长度大于等于8</li></ul></blockquote><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/53.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/54.png" class="" title="java线程"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>    Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>     <span class="hljs-comment">//添加元素大于阈值，需要扩容</span><br>    <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>           (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">    rs二进制：</span><br><span class="hljs-comment">    0000 0000 0000 0000  1000 0000 0001 1100</span><br><span class="hljs-comment">        rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2：</span><br><span class="hljs-comment">        1000 0000 0001 1100（扩容标记）  0000 0000 0000 0010（参与扩容线程数）</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>        <span class="hljs-comment">//表示已经有线程正在扩容</span><br>        <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//表示不需要协助扩容</span><br>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//需要协助扩容，sc记录参与扩容的线程数</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<span class="hljs-comment">//sc二进制运算</span><br>                transfer(tab, nt);<br>        &#125;<br>        <span class="hljs-comment">//没有线程在扩容，第一次扩容+2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                     (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<span class="hljs-comment">//左移16位，最高位为1</span><br>            transfer(tab, <span class="hljs-literal">null</span>);<span class="hljs-comment">//第一次扩容</span><br>        s = sumCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        nextTable = <span class="hljs-literal">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        finishing = advance = <span class="hljs-literal">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//tab获取数组下标</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br></code></pre></td></tr></table></figure><hr><h2 id="17、线程池"><a href="#17、线程池" class="headerlink" title="17、线程池"></a>17、线程池</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/55.png" class="" title="java线程"><h4 id="（1）线程池构建（ThreadPoolExecutor）"><a href="#（1）线程池构建（ThreadPoolExecutor）" class="headerlink" title="（1）线程池构建（ThreadPoolExecutor）"></a>（1）线程池构建（ThreadPoolExecutor）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>【1】int corePoolSize：线程池中一直维护的线程数量，如果线程池处于任务空闲期间，该线程不会被回收调掉；<br>【2】int maximumPoolSize：线程池中所维护线程数的最大数量；<br>【3】long keepAlivePoolSize：临时线程存活时间，超过corePoolSize的线程在金经过KeepAliveTime时间后如果一直处于空闲状态，那么超过的线程将会被回收掉；<br>【4】TimeUnit unit： keepAlivePoolSize的时间单位；<br>【5】BlockingQueue<Runable> workQueue：向先池所提交的任务位于的阻塞队列，实现有多种；<br>【6】ThreadFactory threadFactory：线程工厂，用于创建新的线程并被线程池管理，默认线程工厂所创建的线程都是用户线程且优先级为正常优先级；<br>【7】RejectdExecutionHandler hadler：表示当前线程都在忙于执行任务，并且阻塞队列已满的情况下,新到来的任务该如何对待和处理（拒绝策略）；</p><h4 id="（2）拒绝策略："><a href="#（2）拒绝策略：" class="headerlink" title="（2）拒绝策略："></a>（2）拒绝策略：</h4><p>【1】AbortPolicy：直接抛出一个运行异常；<br>【2】DiscardPolicy：默默丢弃提交任务，不做任何处理，且不抛出异常<br>【3】DiscardOldestPolicy：丢弃阻塞队列中存放时间久的任务（队头元素），并且为当前所提交的任务留出一个队列空闲空间，将其放入队列；<br>【4】CallerRunsPolicy：直接由提交任务的线程来运行这个提交的任务（调用run方法）；</p><h4 id="（3）线程池总体策略"><a href="#（3）线程池总体策略" class="headerlink" title="（3）线程池总体策略"></a>（3）线程池总体策略</h4><p>【1】如果线程池正在执行的线程数&lt;corePoolSize，那么线程池就会优先选择新创建的线程来执行任务，而非将提交的任务加到阻塞队列中；<br>【2】如果线程中正在执行的线程数&gt;&#x3D;corePoolSize，那么线程池就会优先选择对提交的任务进行阻塞排队，而非创建新的线程；<br>【3】如果提交的任务无法加入到阻塞队列中，那么线程池就会创建新的线程，如果创建的线程数超过maximumPoolSize，那么拒绝策略起作用；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/56.png" class="" title="java线程"><h4 id="（4）线程池维护状态"><a href="#（4）线程池维护状态" class="headerlink" title="（4）线程池维护状态"></a>（4）线程池维护状态</h4><p>【1】线程池本身状态：ctl高三位来表示<br>【2】线程池中所运行线程数量：ctl其余29位表示；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/57.png" class="" title="java线程"><p>【3】RUNNING ：线程池可以接收新的任务提交，并且可以正常处理阻塞队列中的任务；<br>【4】SHUTDOWN ：不再接收新的任务提交，不过线程池可以正常处理阻塞队列中的任务；<br>【5】STOP ：不在接收新的任务，同时丢弃阻塞队列中的任务，中断正在处理中的任务；<br>【6】TIDYING ：所有任务都执行完毕后（包括阻塞队列中的任务），当前线程中的活动的线程数量降为0，调用terminated方法；<br>【7】TERMINATED ：线程终止状态，当terminated方法执行完毕后，线程池会处于该状态之下；<br>【8】RUNNING  -&gt;  SHUTDOWN :当调用线程池shutdown方法时，或者调用finalize方法后（该放啊内部调用shutdown方法）；<br>【9】RUNNING， SHUTDOWN  -&gt; STOP：当调用线程池shutdownNow方法；<br>【10】SHUTDOWN -&gt; TIDYING：在线程池与阻塞队列均为空时；<br>【11】STOP -&gt; TIDYING：线程池为空时；<br>【12】TIDYING -&gt; TERMINATED：在terminated方法执行完毕后。</p><h4 id="（5）线程池任务提交"><a href="#（5）线程池任务提交" class="headerlink" title="（5）线程池任务提交"></a>（5）线程池任务提交</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/58.png" class="" title="java线程"><p>【1】两种提交方式：submit和execute<br>【2】submit三种提交方式，无论哪种方式，最终将转换来的任务转换为一个Callable对象来处理；<br>【3】当Callable对象构造完毕后，最终会调用Executor接口声明的execute方法执行；<br>【4】execute方法源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//创建线程</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//线程执行体添加到阻塞队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//线程没有running，移除任务成功</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//队列满，线程超过最大值，拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/59.png" class="" title="java线程"><p>【5】addWorker（)方法分析：创建线程并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">//增加线程数量</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">//判断线程是否处于终止状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<span class="hljs-comment">//获取线程数量</span><br>            <span class="hljs-comment">//判断线程数量是否超出</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//false表示阻塞队列满</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//修改线程数量</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//创建一个线程</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            <span class="hljs-comment">//加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    <span class="hljs-comment">//hashSet存储工作线程</span><br>                    workers.add(w);<br>                    <span class="hljs-comment">//更新线程最大数量</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">//添加失败，删除线程</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/60.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/61.png" class="" title="java线程"><h4 id="（6）线程池任务的执行流程（Worker的run方法）"><a href="#（6）线程池任务的执行流程（Worker的run方法）" class="headerlink" title="（6）线程池任务的执行流程（Worker的run方法）"></a>（6）线程池任务的执行流程（Worker的run方法）</h4><p>getTask（）从阻塞队列获取队头任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 线程数量大于核心数量，返回null，回收线程</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">//工作线程大于最大线程或核心线程数，工作线程减1</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//工作线程减一</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                <span class="hljs-comment">//阻塞队列为空，</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                <span class="hljs-comment">//获取不到数据，线程阻塞（工作线程数小于核心线程数）</span><br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runWorker（）执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//任务不为空，为空，线程结束（线程销毁）</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//任务执行，任务为实现Runable的run方法</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/62.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/63.png" class="" title="java线程"><h4 id="（7）线程池终止"><a href="#（7）线程池终止" class="headerlink" title="（7）线程池终止"></a>（7）线程池终止</h4><p>【1】shutdown（）方法：拒绝新任务提交，会继续执行完阻塞队列中的任务后，才会进入终止状态；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/64.png" class="" title="java线程"><p>interruptIdleWorkers()方法</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/65.png" class="" title="java线程"><p>tryTerminate()方法</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/66.png" class="" title="java线程"><p>【2】shutdownNow（）方法：拒绝新任务提交，停止所有正在执行任务的线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/67.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/68.png" class="" title="java线程"><h4 id="（8）ForkJoinPool线程池"><a href="#（8）ForkJoinPool线程池" class="headerlink" title="（8）ForkJoinPool线程池"></a>（8）ForkJoinPool线程池</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/69.png" class="" title="java线程"><h4 id="（9）CompletableFuture"><a href="#（9）CompletableFuture" class="headerlink" title="（9）CompletableFuture"></a>（9）CompletableFuture</h4><h5 id="①thenApply源码"><a href="#①thenApply源码" class="headerlink" title="①thenApply源码"></a>①thenApply源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">uniApplyStage</span><span class="hljs-params">(</span><br><span class="hljs-params">    Executor e, Function&lt;? <span class="hljs-built_in">super</span> T,? extends V&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;V&gt; d =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;V&gt;();<br>    <span class="hljs-comment">//e:一步调用直接执行</span><br>    <span class="hljs-comment">//uniApply任务执行失败，需要入栈</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniApply(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniApply&lt;T,V&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        <span class="hljs-comment">//尝试执行任务</span><br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> &lt;S&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniApply</span><span class="hljs-params">(CompletableFuture&lt;S&gt; a,</span><br><span class="hljs-params">                           Function&lt;? <span class="hljs-built_in">super</span> S,? extends T&gt; f,</span><br><span class="hljs-params">                           UniApply&lt;S,T&gt; c)</span> &#123;<br>    Object r; Throwable x;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || (r = a.result) == <span class="hljs-literal">null</span> || f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    tryComplete: <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> AltResult) &#123;<br>            <span class="hljs-keyword">if</span> ((x = ((AltResult)r).ex) != <span class="hljs-literal">null</span>) &#123;<br>                completeThrowable(x, r);<br>                <span class="hljs-keyword">break</span> tryComplete;<br>            &#125;<br>            r = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; !c.claim())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) r;<br>            <span class="hljs-comment">//执行任务，并将结果写入result</span><br>            completeValue(f.apply(s));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            completeThrowable(ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②thenAcceptAsync源码（异步执行）"><a href="#②thenAcceptAsync源码（异步执行）" class="headerlink" title="②thenAcceptAsync源码（异步执行）"></a>②thenAcceptAsync源码（异步执行）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">uniAcceptStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                               Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;Void&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;Void&gt;();<br>    <span class="hljs-comment">//异步调用，e不为null，执行压入栈顶</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniAccept(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniAccept&lt;T&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,Void&gt; &#123;<br>    Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn;<br>    UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,<br>              CompletableFuture&lt;T&gt; src, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn) &#123;<br>        <span class="hljs-built_in">super</span>(executor, dep, src); <span class="hljs-built_in">this</span>.fn = fn;<br>    &#125;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">tryFire</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span> &#123;<br>        CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;<br>         <span class="hljs-comment">//dep为null，任务已经执行过</span><br>        <span class="hljs-comment">//uniAccept为false表示任务可能已被其他线程执行</span><br>        <span class="hljs-keyword">if</span> ((d = dep) == <span class="hljs-literal">null</span> ||<br>            !d.uniAccept(a = src, fn, mode &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : <span class="hljs-built_in">this</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dep = <span class="hljs-literal">null</span>; src = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//任务已经完成，继续执行前一个任务</span><br>        <span class="hljs-keyword">return</span> d.postFire(a, mode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">postFire</span><span class="hljs-params">(CompletableFuture&lt;?&gt; a, <span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; a.stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//前一个任务执行完毕</span><br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span> || a.result == <span class="hljs-literal">null</span>)<br>            a.cleanStack();<span class="hljs-comment">//任务出栈</span><br>        <span class="hljs-keyword">else</span><br>            a.postComplete();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span><br>            postComplete();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③supplyAsync源码"><a href="#③supplyAsync源码" class="headerlink" title="③supplyAsync源码"></a>③supplyAsync源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                                 Supplier&lt;U&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncSupply</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, AsynchronousCompletionTask &#123;<br>        CompletableFuture&lt;T&gt; dep;<span class="hljs-comment">//</span><br>        Supplier&lt;T&gt; fn;<span class="hljs-comment">//执行逻辑</span><br>        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;<br>            <span class="hljs-built_in">this</span>.dep = dep; <span class="hljs-built_in">this</span>.fn = fn;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123; run(); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;<br>            <span class="hljs-keyword">if</span> ((d = dep) != <span class="hljs-literal">null</span> &amp;&amp; (f = fn) != <span class="hljs-literal">null</span>) &#123;<br>                dep = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//result为任务执行完后的结果，为null表示未完成结果</span><br>                <span class="hljs-keyword">if</span> (d.result == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        d.completeValue(f.get());<span class="hljs-comment">//等待任务结束并设置结果</span><br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                        d.completeThrowable(ex);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//任务执行完成，执行所有依赖改任务的所有任务</span><br>                d.postComplete();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postComplete</span><span class="hljs-params">()</span> &#123;<br>    CompletableFuture&lt;?&gt; f = <span class="hljs-built_in">this</span>; <br>    Completion h;<br>    <span class="hljs-keyword">while</span> ((h = f.stack) != <span class="hljs-literal">null</span> ||<br>           (f != <span class="hljs-built_in">this</span> &amp;&amp; (h = (f = <span class="hljs-built_in">this</span>).stack) != <span class="hljs-literal">null</span>)) &#123;<br>        CompletableFuture&lt;?&gt; d; <br>        Completion t;<span class="hljs-comment">//保存的是依靠当前CompletableFuture的任务</span><br>        <span class="hljs-keyword">if</span> (f.casStack(h, t = h.next)) &#123;<span class="hljs-comment">//获取栈中下一个Completion</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当前的CompletableFuture不是this的，将所有Completion加入当前栈中</span><br>                <span class="hljs-keyword">if</span> (f != <span class="hljs-built_in">this</span>) &#123;<br>                    pushStack(h);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                h.next = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 为当前CompletableFuture，解除联系</span><br>            &#125;<br>            f = (d = h.tryFire(NESTED)) == <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span> : d;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个CompletableFuture持有一个Completion栈stack, 每个Completion持有一个CompletableFuture， 如此递归循环下去，是层次很深的树形结构，所以想办法将其变成链表结构。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/70.png" class="" title="java线程"><p>首先取出头结点，下图中灰色Completion结点，它会返回一个CompletableFuture, 同样也拥有一个stack，策略是遍历这个CompletableFuture的stack的每个结点，依次压入到当前CompletableFuture的stack中，关系如下箭头所示，灰色结点指的是处理过的结点。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/71.png" class="" title="java线程"><p>第一个Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/72.png" class="" title="java线程"><p>后续的Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面，重新构成了一个链表结构，后续也按照前面的逻辑操作，如此反复，便会遍历完所有的CompletableFuture, 这些CompletableFuture(叶子结点)的stack为空，也是结束条件。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/73.png" class="" title="java线程">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h4><p>（1）处理方法：<br>①第一行记录原数组行总数，列总数，有多少个不同的值；<br>②第二行开始，存储对应值行，对应值列，对应值大小<br>（2）二维数组转换为稀疏数组<br>①遍历二位数组，得到有效数据个数sum；<br>②根据sum创建稀疏数组，int [sum+1][3];<br>③将二维数组有效数据存入到稀疏数组；<br>（3）稀疏数组转换为二维数组<br>①读取稀疏数组第一行，得到行数，列数，创建原始二维数组；<br>②再读取稀疏数组后几行数据，并赋给二维数组；</p><h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><p>（1）先进先出，后进后出<br>（2）队列图</p><p>（3）循环队列<br>①front指向队列第一个元素；<br>②rear指向最后一个元素的后一个位置，预留一个空间(实际存放长度为maxSize-1)；<br>③队列满时，条件是（rear+1）%maxSize&#x3D;front；<br>④队列为空，rear&#x3D;&#x3D;front<br>⑤队列有效数据个数：（rear+maxSize-front）%maxSize</p><h4 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h4><p>（1）单链表创建示意图</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" class="" title="java线程"><p>（2）双向链表</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" class="" title="java线程"><h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><h5 id="（1）数组模拟栈"><a href="#（1）数组模拟栈" class="headerlink" title="（1）数组模拟栈"></a>（1）数组模拟栈</h5><p>①top初始化为-1；<br>②有数据加入时，top++，stack[top]&#x3D;n;<br>③出栈时，int value&#x3D;stack[top]，top–；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" class="" title="java线程"><h5 id="（2）计算一个表达式"><a href="#（2）计算一个表达式" class="headerlink" title="（2）计算一个表达式"></a>（2）计算一个表达式</h5><p>①通过index值（字符串扫描索引）遍历表达式<br>②若index发现是一个数字，直接入数栈<br>③扫描到的是符号：<br>若符号栈为空，直接入栈；<br>若符号栈有操作符，进行比较，若单前操作符的优先级小于等于栈中操作符，需要从数栈弹出两个数，符号栈pop出一个符号，进行运算，将运算结果入数栈，然后当前符号值入栈；<br>若符号栈有操作符，进行比较，若单前操作符的优先级大于栈中操作符，当前符号入符号栈；<br>④当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应数和符号，并运算，最后数栈只有一个数字，就为表达式结果</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" class="" title="java线程"><h5 id="（3）前缀表达式（波兰表达式）"><a href="#（3）前缀表达式（波兰表达式）" class="headerlink" title="（3）前缀表达式（波兰表达式）"></a>（3）前缀表达式（波兰表达式）</h5><p>前缀表达式求值：从右往左扫描，遇到数字，数字入栈，遇到运算符，弹出栈顶两个元素运算，并将结果入栈<br>如：（3+4）*5-6对应的前缀表达式：- *+3 4 5 6</p><h5 id="（4）中缀表达式"><a href="#（4）中缀表达式" class="headerlink" title="（4）中缀表达式"></a>（4）中缀表达式</h5><p>如：（3+4）*5-6</p><h5 id="（5）后缀表达式（逆波兰表达式）"><a href="#（5）后缀表达式（逆波兰表达式）" class="headerlink" title="（5）后缀表达式（逆波兰表达式）"></a>（5）后缀表达式（逆波兰表达式）</h5><p>后缀表达式求值：从左向右扫描，遇到数字，数字入栈，遇到运算符，弹出栈顶两个元素运算，并将结果入栈<br>如：（3+4）* _5-6后缀表达式为：3 4 + 5 * _6 -</p><h5 id="（6）中缀表达式转后缀表达式思路："><a href="#（6）中缀表达式转后缀表达式思路：" class="headerlink" title="（6）中缀表达式转后缀表达式思路："></a>（6）中缀表达式转后缀表达式思路：</h5><p>①初始化两个栈，运算符栈和存储中间结果栈；<br>②从左至右扫描；<br>③遇到数，入结果栈s2；<br>④遇到运算符，与s1比较优先级：<br>    若s1为空，或栈顶运算符为（，直接入栈；<br>    若优先级比s1栈顶运算符高，运算符入栈；<br>    若优先级比s1栈顶运算符相等或低，先将s1栈顶弹出，压入s2栈，再与s1新栈顶比较；<br>⑤遇到括号：<br>   括号为（，直接入s1栈；<br>    括号为 ），依次弹出s1栈运算符，直到遇到左括号（为止；<br>⑥重复②到⑤步骤<br>⑦将s1剩余运算符弹出压入s2；<br>⑧，依次将s2弹出，并逆序，即为后缀表达式；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" class="" title="java线程"><h4 id="5、算法时间复杂度"><a href="#5、算法时间复杂度" class="headerlink" title="5、算法时间复杂度"></a>5、算法时间复杂度</h4><p>（1）时间频度：算法中语句执行次数；<br>（2）算法时间复杂度可以忽略常数项；<br>（3）算法时间复杂度可以忽略低次项；<br>（4）算法时间复杂度可以忽略系数；<br>（5）常数阶O（1）：无论代码多少行，只要无循环复杂结构，时间复杂度就是O（1）；<br>（6）对数阶O(log2n)：</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" class="" title="java线程"><p>（7）线性阶O(n)：单层循环；<br>（8）线性对数阶O(nlogN): </p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.png" class="" title="java线程"><h4 id="6、冒泡排序"><a href="#6、冒泡排序" class="headerlink" title="6、冒泡排序"></a>6、冒泡排序</h4><p>（1）从前往后依次比较相邻元素的值，若发现逆序交换，使值大的从前往后移；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.png" class="" title="java线程"><p>（2）优化：<br>①排序过程中若无进行交换，说明已经有序；<br>②每一趟排序次数逐渐减少；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png" class="" title="数据结构"><h4 id="7、选择排序"><a href="#7、选择排序" class="headerlink" title="7、选择排序"></a>7、选择排序</h4><p>（1）第一次从arr[0] 到arr[n-1] 中选取最小值与arr[0]交换，第二次从arr[1] 到arr[n-1] 中选取最小值与arr[1]交换……………….;</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png" class="" title="数据结构"><h4 id="8、插入排序"><a href="#8、插入排序" class="headerlink" title="8、插入排序"></a>8、插入排序</h4><p>（1）分为无序表和有序表，每次取无序表的第一个元素，插入有序表</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png" class="" title="数据结构"><h5 id="9、希尔排序"><a href="#9、希尔排序" class="headerlink" title="9、希尔排序"></a>9、希尔排序</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png" class="" title="数据结构"><h4 id="10、快速排序"><a href="#10、快速排序" class="headerlink" title="10、快速排序"></a>10、快速排序</h4><p>（1）对冒泡排序的改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (begin&gt;end)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=quickSort1(nums,begin,end);<br>    sort(nums,begin,mid-<span class="hljs-number">1</span>);<br>    sort(nums,mid+<span class="hljs-number">1</span>,end);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSort1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-type">int</span> i=begin+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j=end;<br>    <span class="hljs-type">int</span> temp=nums[begin];<br><br>    <span class="hljs-keyword">while</span> (i&lt;j)&#123;<br>        <span class="hljs-comment">//在后端找比temp小的值</span><br>        <span class="hljs-keyword">while</span> (i&lt;j&amp;&amp;nums[j]&gt;temp)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//在前面找比temp大的值</span><br>        <span class="hljs-keyword">while</span> (i&lt;j&amp;&amp;nums[i]&lt;temp)&#123;<br>            i++;<br>        &#125;<br>        swap(nums,i,j);<br>        i++;<br>        j--;<br>    &#125;<br>    swap(nums,begin,j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> temp=nums[i];<br>    nums[i]=nums[j];<br>    nums[j]=temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="11、归并排序"><a href="#11、归并排序" class="headerlink" title="11、归并排序"></a>11、归并排序</h4><p>（1）该排序采用分治策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>     <span class="hljs-keyword">if</span> (begin&lt;end)&#123;<br>         <span class="hljs-type">int</span> mid=(begin+end)/<span class="hljs-number">2</span>;<br>         merge(nums,begin,mid,temp);<br>         merge(nums,mid+<span class="hljs-number">1</span>,end,temp);<br>         mergeSort(nums,begin,end,temp);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>     <span class="hljs-type">int</span> i=begin;<br>     <span class="hljs-type">int</span> mid=(begin+end)/<span class="hljs-number">2</span>;<br>     <span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=end)&#123;<br>         temp[index++]=nums[i]&lt;=nums[j]?nums[i++]:nums[j++];<br>     &#125;<br>     <span class="hljs-comment">//右边还存在数据</span><br>     <span class="hljs-keyword">while</span> (i&lt;=mid)&#123;<br>         temp[index++]=nums[i++];<br>     &#125;<br>     <span class="hljs-comment">//左边存在数据</span><br>     <span class="hljs-keyword">while</span> (j&lt;=end)&#123;<br>         temp[index++]=nums[j++];<br>     &#125;<br>     <span class="hljs-comment">//数组拷贝</span><br>     <span class="hljs-type">int</span> numsInex=begin;<br>     <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (t&lt;index)&#123;<br>         nums[numsInex++]=temp[t++];<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="12、基数排序"><a href="#12、基数排序" class="headerlink" title="12、基数排序"></a>12、基数排序</h4><p>（1）基数排序属于稳定性排序，空间换时间算法</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png" class="" title="数据结构"><p>（2）将带比较的值统一为同样长度，数位较短值前面补零，然后从最低位开始，依次进行排序；<br>  注：比较次数取决于最大数的位数</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/16.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/17.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/18.png" class="" title="数据结构"><h4 id="13、插值查找"><a href="#13、插值查找" class="headerlink" title="13、插值查找"></a>13、插值查找</h4><p>(1)mid&#x3D;left+(right-left)*(target-arr[left])&#x2F;(arr[right]-arr[left])；<br>(2)数字分布均匀查找效率高；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png" class="" title="数据结构"><h4 id="14、斐波那契查找"><a href="#14、斐波那契查找" class="headerlink" title="14、斐波那契查找"></a>14、斐波那契查找</h4><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.png" class="" title="数据结构"><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//获取斐波那契数列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] fib()&#123;<br>    <span class="hljs-keyword">int</span>[] f=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxSize];<br>    f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; f.length; i++) &#123;<br>        f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-comment">//斐波那契查找</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> low=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high=arr.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示斐波那契分割数值的下标</span><br>    <span class="hljs-keyword">int</span> mid=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] f=fib();<span class="hljs-comment">//获取斐波那契数列</span><br>    <span class="hljs-comment">//获取斐波那契分割下标</span><br>    <span class="hljs-keyword">while</span> (high&gt;f[k]<span class="hljs-number">-1</span>)&#123;<br>        k++;<br>    &#125;<br>    <span class="hljs-comment">//f[k]可能大于a的长度，因此需要构造一个新数组，并指向a[]</span><br>    <span class="hljs-keyword">int</span>[] temp= Arrays.copyOf(arr,f[k]);<br>    <span class="hljs-comment">//使用a数组最后的数填充temp</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = high+<span class="hljs-number">1</span>; i &lt; temp.length; i++) &#123;<br>        temp[i]=arr[high];<br>    &#125;<br>    <span class="hljs-comment">//使用while循环处理，找到数target</span><br>    <span class="hljs-keyword">while</span> (low&lt;=high)&#123;<br>        mid=low+f[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span>&lt;temp[mid])&#123;<br>            high=mid<span class="hljs-number">-1</span>;<br>            k--;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span>&gt;temp[mid])</span></span>&#123;<br>            low=mid+<span class="hljs-number">1</span>;<br>            k-=<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mid&lt;=high)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> high;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15、哈希表"><a href="#15、哈希表" class="headerlink" title="15、哈希表"></a>15、哈希表</h4><p>（1）根据关键字映射到表中一个位置来访问记录，数组为散列表；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/21.png" class="" title="数据结构"><h4 id="16、二叉树"><a href="#16、二叉树" class="headerlink" title="16、二叉树"></a>16、二叉树</h4><h5 id="（1）前中后遍历"><a href="#（1）前中后遍历" class="headerlink" title="（1）前中后遍历"></a>（1）前中后遍历</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/22.png" class="" title="数据结构"><h5 id="（2）前序、中序、后序查找"><a href="#（2）前序、中序、后序查找" class="headerlink" title="（2）前序、中序、后序查找"></a>（2）前序、中序、后序查找</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/23.png" class="" title="数据结构"><h5 id="（3）删除节点"><a href="#（3）删除节点" class="headerlink" title="（3）删除节点"></a>（3）删除节点</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/24.png" class="" title="数据结构"><h5 id="（4）线索二叉树"><a href="#（4）线索二叉树" class="headerlink" title="（4）线索二叉树"></a>（4）线索二叉树</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">① <span class="hljs-built_in">n</span>个节点的二叉链表中含有（<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>）个空指针域，利用空指针域，存放指向该节点某种（前序，中序，后序）遍历下的前驱或后继节点的指针；<br> ②<span class="hljs-built_in">left</span>可能指向左子树或前驱节点；<br> ③<span class="hljs-built_in">right</span>可能指向右子树或后继节点；<br> ④线索二叉树不能使用原来的遍历方式遍历<br></code></pre></td></tr></table></figure><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/25.png" class="" title="数据结构"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedNodes</span><span class="hljs-params">(HeroNode1 node)</span>&#123;<br>        <span class="hljs-comment">//如果node为null，不能线索化</span><br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        threadedNodes(node.getLeft());<br><br>        <span class="hljs-comment">//线索化当前节点</span><br>        <span class="hljs-comment">//先处理前驱节点</span><br>        <span class="hljs-keyword">if</span> (node.getLeft()==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//让当前节点的左指针指向前驱节点</span><br>            node.setLeft(pre);<br>            <span class="hljs-comment">//修改当前左指针的类型</span><br>            node.setLeftType(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//处理后继节点</span><br>        <span class="hljs-keyword">if</span> (pre!=<span class="hljs-literal">null</span>&amp;&amp;pre.getRight()==<span class="hljs-literal">null</span>)&#123;<br>            pre.setRight(node);<br>            pre.setRightType(<span class="hljs-number">1</span>);<br>        &#125;<br>        pre=node;<br>        threadedNodes(node.getRight());<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedList</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//定义变量记录当前遍历节点</span><br>      HeroNode1 node1=root;<br>      <span class="hljs-keyword">while</span> (node1!=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">//循环找到leftType=1的节点</span><br>          <span class="hljs-keyword">while</span> (node1.getLeftType()==<span class="hljs-number">0</span>)&#123;<br>              node1=node1.getLeft();<br>          &#125;<br>          System.out.println(node1);<br>          <span class="hljs-keyword">while</span> (node1.getRightType()==<span class="hljs-number">1</span>)&#123;<br>              node1=node1.getRight();<br>              System.out.println(node1);<br>          &#125;<br>          node1=node1.getRight();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="（5）堆排序"><a href="#（5）堆排序" class="headerlink" title="（5）堆排序"></a>（5）堆排序</h5><p>①大顶堆：每个节点的值大于或等于子节点的值；<br>②小顶堆：每个节点的值小于或等于子节点的值；<br>③升序采用大顶堆，降序采用小顶堆；<br>④堆排序思路：<br>A、从最左最下的非叶子节点开始，开始构造大顶堆（最后一个非叶子节点下标为n&#x2F;2-1）；<br>B、将根节点与每一次数组的后面值交换，根据根节点调整大顶堆<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665633465370-75bb9a07-c4db-438a-a128-3be0da822f64.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">headSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-comment">//将无序序列构造成大顶堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            adjustHeap(arr,i, arr.length);<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">//将堆顶元素压入数组末端</span><br>        <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>; i &gt;<span class="hljs-number">0</span> ; i--) &#123;<br>            temp=arr[i];<br>            arr[i]=arr[<span class="hljs-number">0</span>];<br>            arr[<span class="hljs-number">0</span>]=temp;<br>            adjustHeap(arr,<span class="hljs-number">0</span>,i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将数组构造成大顶堆</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    完成对i非叶子节点的树调整成大顶堆</span><br><span class="hljs-comment">    i表示非叶子节点在数组中的索引，</span><br><span class="hljs-comment">    len表示对多少个元素进行调整</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> length)</span>&#123;<br>        <span class="hljs-type">int</span> temp=arr[i];<br>        <span class="hljs-comment">//左子节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; j &lt; length ; j=j*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;length&amp;&amp;arr[j]&lt;arr[j+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//左子节点值小于右子节点</span><br>                j++;<span class="hljs-comment">//j指向右子节点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;temp)&#123;<span class="hljs-comment">//子节点大于父节点</span><br>                arr[i]=arr[j];<br>                i=j;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//已经将以i为父节点的树的最大值放在顶点</span><br>        arr[i]=temp;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="17、哈夫曼树"><a href="#17、哈夫曼树" class="headerlink" title="17、哈夫曼树"></a>17、哈夫曼树</h4><p>（1）节点的权：树节点的值；<br>（2）带权路径长度：从根节点到该节点之间的路径长度与该节点的权的乘积；<br>（3）树的带全路径长度（wpl）：所有叶子节点的带权路径长度；wpl最小就是哈夫曼树<br>（4）构造哈夫曼树思路：<br>①数组从小到大排序；<br>②取出权值最小的两个树，组合成一颗新的二叉树，形成新的根节点；<br>③以根节点的权值大小再次排序，重复上述步骤<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665639906644-aab33d51-cbfc-400e-b9d9-954ea5b3abf6.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">createHuffman</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>       <span class="hljs-comment">//遍历arr数组，arr构建成node，node放入ArrayList</span><br>       List&lt;Node&gt; nodes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>           nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value));<br>       &#125;<br><br>       <span class="hljs-keyword">while</span> (nodes.size()&gt;<span class="hljs-number">1</span>)&#123;<br>           Collections.sort(nodes);<br>           <span class="hljs-comment">//取出值最小两个节点</span><br>           Node leftNode=nodes.get(<span class="hljs-number">0</span>);<br>           Node rightNode=nodes.get(<span class="hljs-number">1</span>);<br>           <span class="hljs-comment">//构建一颗新的二叉树</span><br>           Node parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(leftNode.value+rightNode.value);<br>           parent.left=leftNode;<br>           parent.right=rightNode;<br><br>           <span class="hljs-comment">//删除从list中取出的两个jiedian</span><br>           nodes.remove(leftNode);<br>           nodes.remove(rightNode);<br>           <span class="hljs-comment">//添加parent</span><br>           nodes.add(parent);<br>       &#125;<br>       <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//返回头节点</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>（5）哈夫曼编码<br>①哈夫曼树是无损压缩；<br>②原理图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665644862747-f3e78fb3-582f-445c-a8a3-e0f1070f2957.jpeg"><br>③压缩字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建哈夫曼树</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Nodes <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(List&lt;Nodes&gt; nodes)</span>&#123;<br>      <span class="hljs-keyword">while</span> (nodes.size()&gt;<span class="hljs-number">1</span>)&#123;<br>          Collections.sort(nodes);<br>          Nodes leftNode=nodes.get(<span class="hljs-number">0</span>);<br>          Nodes rightNode=nodes.get(<span class="hljs-number">1</span>);<br>          Nodes parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Nodes</span>(<span class="hljs-literal">null</span>,leftNode.weight+rightNode.weight);<br>          parent.left=leftNode;<br>          parent.right=rightNode;<br><br>          nodes.remove(leftNode);<br>          nodes.remove(rightNode);<br>          nodes.add(parent);<br>      &#125;<br>      <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//接收一个字节数组，返回list</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Nodes&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span>&#123;<br>      List&lt;Nodes&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      Map&lt;Byte,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : bytes) &#123;<br>          Integer count=map.get(b);<br>          <span class="hljs-keyword">if</span> (count==<span class="hljs-literal">null</span>)&#123;<br>              map.put(b,<span class="hljs-number">1</span>);<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              map.put(b,count+<span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//每一个键值对转换为node对象</span><br>      <span class="hljs-keyword">for</span> (Byte b : map.keySet()) &#123;<br>          list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Nodes</span>(b,map.get(b)));<br>      &#125;<br>      <span class="hljs-keyword">return</span> list;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成哈夫曼树编码表</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将哈夫曼树存放在Map&lt;byte,String&gt;中，如32--01，97--100，100--11000 .......</span><br><span class="hljs-comment">StringBuilder存储叶子节点路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">static</span> Map&lt;Byte,String&gt; huffmanCode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//存放编码</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将传入nodes的所有叶子节点，获取哈夫曼编码，放入集合中;</span><br><span class="hljs-comment">code:左子节点是0，右子节点为1</span><br><span class="hljs-comment">stringBuilder用户拼接路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">(Nodes nodes,String code,StringBuilder s)</span>&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>    <span class="hljs-comment">//将传入code加入stringBuilder</span><br>    stringBuilder2.append(code);<br>    <span class="hljs-keyword">if</span> (nodes!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//判断当前nodes是叶子节点，还是非叶子节点</span><br>        <span class="hljs-keyword">if</span> (nodes.data==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//非叶子节点</span><br>            getCode(nodes.left,<span class="hljs-string">&quot;0&quot;</span>,stringBuilder2);<span class="hljs-comment">//向左</span><br>            getCode(nodes.right,<span class="hljs-string">&quot;1&quot;</span>,stringBuilder2);<span class="hljs-comment">//向右</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            huffmanCode.put(nodes.data,stringBuilder2.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>压缩时lastLength记录最后一位字节的长度，便于后面解压时对最后一位的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个方法，将字符串对应的byte【】数组，通过哈夫曼编码表，返回一个哈夫曼处理后（压缩后）的字节数组</span><br>   <span class="hljs-comment">//str=&gt;1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastLength=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录最后一位数的长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] zip(<span class="hljs-type">byte</span>[] bytes,Map&lt;Byte,String&gt; huffmanCodes)&#123;<br>       <span class="hljs-comment">//利用哈夫编码编码表，将字符串字节数组转换为哈夫曼编码对应的字符串</span><br>       <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : bytes) &#123;<br>           stringBuilder.append(huffmanCodes.get(b));<br>       &#125;<br>       <span class="hljs-comment">//将字符串准换为byte数组</span><br>       <span class="hljs-comment">//统计返回huffmanCodeBytes 长度</span><br>       <span class="hljs-type">int</span> len;<br>       <span class="hljs-keyword">if</span> (stringBuilder.length()%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>)&#123;<br>           len=stringBuilder.length()/<span class="hljs-number">8</span>;<br>           lastLength=<span class="hljs-number">8</span>;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           len=stringBuilder.length()/<span class="hljs-number">8</span>+<span class="hljs-number">1</span>;<br>           lastLength=stringBuilder.length()%<span class="hljs-number">8</span>;<span class="hljs-comment">//记录最后一位数的长度</span><br>       &#125;<br>       <span class="hljs-comment">//创建存储压缩后的byte数组</span><br>       <span class="hljs-type">byte</span>[] huffmanCodeBytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>       <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); i+=<span class="hljs-number">8</span>) &#123;<span class="hljs-comment">//每8位对应一个byte</span><br>           String strBytes;<br>           <span class="hljs-keyword">if</span> (i+<span class="hljs-number">8</span>&gt;stringBuilder.length())&#123;<br>               strBytes=stringBuilder.substring(i);<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               strBytes=stringBuilder.substring(i,i+<span class="hljs-number">8</span>);<br>           &#125;<br>           huffmanCodeBytes[temp++]= (<span class="hljs-type">byte</span>) Integer.parseInt(strBytes,<span class="hljs-number">2</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> huffmanCodeBytes;<br>   &#125;<br></code></pre></td></tr></table></figure><p>④解压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将每一个字节转换位二进制字符串</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">byteToString</span><span class="hljs-params">(<span class="hljs-type">byte</span> b,<span class="hljs-type">boolean</span> flag)</span>&#123;<br>      <span class="hljs-type">int</span> temp=b;<br>      <span class="hljs-keyword">if</span> (flag)&#123;<span class="hljs-comment">//true表示不是最后一位</span><br>          temp |=<span class="hljs-number">256</span>;<span class="hljs-comment">//正数补高位</span><br>      &#125;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Integer.toBinaryString(temp);<br>      <span class="hljs-keyword">if</span> (flag)&#123;<br>          <span class="hljs-keyword">return</span> str.substring(str.length()-<span class="hljs-number">8</span>);<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> str.substring(str.length()-lastLength);<span class="hljs-comment">//最后一位返回对应长度</span><br>      &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//解压</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] unzip(<span class="hljs-type">byte</span>[] huffmanBytes,Map&lt;Byte,String&gt; huffmanCodes)&#123;<br>      <span class="hljs-comment">//将压缩的字节数组转换为二进制字符串</span><br>      StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; huffmanBytes.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (i!=huffmanBytes.length-<span class="hljs-number">1</span>)&#123;<br>              stringBuilder.append(byteToString(huffmanBytes[i],<span class="hljs-literal">true</span>));<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              stringBuilder.append(byteToString(huffmanBytes[i],<span class="hljs-literal">false</span>));<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//将哈夫曼编码表的键值对顺序调换</span><br>      Map&lt;String,Byte&gt; unHuffmanCode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (Byte b : huffmanCodes.keySet()) &#123;<br>          unHuffmanCode.put(huffmanCodes.get(b),b);<br>      &#125;<br>      <span class="hljs-comment">//将二进制字符串编码，根据哈夫曼编码表反向编码</span><br>      List&lt;Byte&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); ) &#123;<br>          String str=stringBuilder.substring(i,count);<br>          Byte b= unHuffmanCode.get(str);<br>          <span class="hljs-comment">//反向编码表未找到，count++</span><br>          <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">null</span>)&#123;<br>              count++;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              result.add(b);<br>              i=count;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//result集合转换未字节数组</span><br>      <span class="hljs-type">byte</span>[] unzip=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[result.size()];<br>      <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (Byte b : result) &#123;<br>          unzip[index++]=b;<br>      &#125;<br>      <span class="hljs-keyword">return</span> unzip;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="18、二叉排序树（BST）"><a href="#18、二叉排序树（BST）" class="headerlink" title="18、二叉排序树（BST）"></a>18、二叉排序树（BST）</h4><p>（1）左子节点小于根节点，右子节点大于根节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加节点</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node2 node)</span>&#123;<br>      <span class="hljs-keyword">if</span> (node==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//判断传入节点的和当前子树的根节点的值的关系</span><br>      <span class="hljs-keyword">if</span>(node.value&lt;<span class="hljs-built_in">this</span>.value)&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-built_in">this</span>.left=node;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">this</span>.left.add(node);<br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-built_in">this</span>.right=node;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">this</span>.right.add(node);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>（2）删除节点思路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665731466521-09b6df75-e59a-4eef-97e3-06226d0b4406.jpeg"></p><h4 id="19、平衡二叉树（AVL树）"><a href="#19、平衡二叉树（AVL树）" class="headerlink" title="19、平衡二叉树（AVL树）"></a>19、平衡二叉树（AVL树）</h4><p>（1）左右两个个子树的高度差绝对值不超过1，并且左右两个都是平衡二叉树；<br>（2）左旋转：右子树高左旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665798378294-6d1d9a0e-8663-4d46-9e79-d823539fd403.jpeg"><br>（3）右旋转：左子树高右旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665801266953-f587f7b2-cf50-4c9a-9c48-c4e57776a0ee.jpeg"><br>（4）双旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665802551185-3859f49b-f842-468b-98ac-4b11e580d0b6.jpeg"></p><h4 id="20、B树"><a href="#20、B树" class="headerlink" title="20、B树"></a>20、B树</h4><p>（1）2-3树<br>①所有叶子节点都在同一层；<br>②有两个子节点的节点为二节点，二节点要么没有子节点，要么有两个子节点；<br>③有三个子节点的节点为三节点，三节点要么没有节点，要么有三个子节点；<br>④由二节点和三节点构成；<br>（2）说明<br>①B树阶：节点的最多子节点数，如2-3数的阶是3；<br>③关键字分布在整颗树中，叶子和非叶子都存储数据<br>（3）B+树·<br>①所有数据存放在叶子节点的链表中，链表中数据是有序的；<br>②非叶子节点只存储索引；</p><h4 id="21、图"><a href="#21、图" class="headerlink" title="21、图"></a>21、图</h4><p>（1）图的深度优先遍历（DFS）<br>①从初始访问节点出发，访问第一个邻接结点，然后以这个被访问的邻接结点作为初始结点，继续访问该初始结点的第一个邻接结点；<br>②步骤：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665887153552-302f201d-61a0-4e64-bfb8-c813e75a666c.jpeg"><br>（2）图的广度优先遍历（BFS）<br>①需要使用一个队列保持访问过结点的顺序，以便按照这个顺序来访问邻接结点；<br>②步骤<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665900274868-7bf0d067-3a9d-4f52-8000-3431c22931f9.jpeg"></p><h4 id="22、动态规划——背包问题"><a href="#22、动态规划——背包问题" class="headerlink" title="22、动态规划——背包问题"></a>22、动态规划——背包问题</h4><p>（1）01背包</p><table><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>1500</td></tr><tr><td>物品1</td><td>4</td><td>3000</td></tr><tr><td>物品2</td><td>3</td><td>2000</td></tr></tbody></table><p>背包填表（二维数组）过程<br>①第二行，假设只有物品0存在，对应最大价值1500；<br>②第三行，假设物品0和物品1存在，对应最大价值3000；<br>③第四行，假设物品0，1，2存在，对应最大价值3500，即最终背包最大价值。</p><table><thead><tr><th>物品</th><th>0磅</th><th>1磅</th><th>2磅</th><th>3磅</th><th>4磅</th></tr></thead></table><p>|<br> | 0 | 0 | 0 | 0 | 0 |<br>| 物品0 | 0 | 1500 | 1500 | 1500 | 1500 |<br>| 物品1 | 0 | 1500 | 1500 | 1500 | 3000 |<br>| 物品2 | 0 | 1500 | 1500 | 2000 | 2000+1500 |</p><p>④当j&lt;w[i]时，v[i][j]&#x3D;v[i-1][j]:<br>准备加入的物品的重量大于当前背包的中量，就直接使用上面的装入策略<br>⑤当j&gt;&#x3D;w[i],v[i][j]&#x3D;Math.max(v[i-1][j]，v[i-1][j-w[i]]+v[i])：<br>准备加入的物品重量小于当前背包重量；<br>v[i-1][j]:上一个单元格装入的最大值；<br>v[i]:当前商品价值；<br>v[i-1][j-w[i]]:装入i-1个商品，到剩余空间j-w[i]的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bag</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] w=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//物品重量</span><br>        <span class="hljs-type">int</span>[] v=&#123;<span class="hljs-number">1500</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">2000</span>&#125;;<span class="hljs-comment">//物品价值</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-number">4</span>;<span class="hljs-comment">//背包容量</span><br>        <span class="hljs-type">int</span> n=v.length;<span class="hljs-comment">//物品个数</span><br>        <span class="hljs-type">int</span>[][] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;bag.length ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; bag[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (w[i-<span class="hljs-number">1</span>]&gt;j)&#123;<span class="hljs-comment">//物品重量大于当前背包重量,因为物品下标从0开始，而遍历从1开始，所以要w[i-1]</span><br>                    bag[i][j]=bag[i-<span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    bag[i][j]=Math.max(bag[i-<span class="hljs-number">1</span>][j],bag[i-<span class="hljs-number">1</span>][j-w[i-<span class="hljs-number">1</span>]]+v[i-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(bag[n][m]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bag2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w,<span class="hljs-type">int</span>[] v,<span class="hljs-type">int</span> size)</span>&#123;<br>       <span class="hljs-type">int</span>[] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size+<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; w.length; i++) &#123;<span class="hljs-comment">//遍历物品</span><br>           <span class="hljs-comment">//遍历背包，必须从后往前遍历，从前往后遍历会重复放入同一个物品</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bag.length-<span class="hljs-number">1</span>; j &gt;=w[i]; j--) &#123;<br>               bag[j]=Math.max(bag[j],v[i]+bag[j-w[i]]);<br>           &#125;<br>       &#125;<br>       System.out.println(bag[bag.length-<span class="hljs-number">1</span>]);<br>   &#125;<br></code></pre></td></tr></table></figure><p>（2）完全背包：可以重复放入同一个物品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bag3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w,<span class="hljs-type">int</span>[] v,<span class="hljs-type">int</span> size)</span>&#123;<br>       <span class="hljs-type">int</span>[] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size+<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; w.length; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> w[i]; j &lt; bag.length; j++) &#123;<br>               bag[j]=Math.max(bag[j],v[i]+bag[j-w[i]]);<br>           &#125;<br>       &#125;<br>       System.out.println(bag[size]);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="23、KMP算法"><a href="#23、KMP算法" class="headerlink" title="23、KMP算法"></a>23、KMP算法</h4><p>（1）部分匹配值：前缀和后缀最长的共有元素长度，<br>①前缀：bread前缀：b、br、bre、brea、<br>②后缀：bread后缀：read、ead、ad、d<br>如：ABCDA：前缀A、AB、ABC、ABCD，后缀BCDA、CDA、DA、A，共有元素为A，长度为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取一个字符串的部分匹配值</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] kmpNext(String dest)&#123;<br>       <span class="hljs-type">int</span>[] next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dest.length()];<br>       next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//如果字符串长度为1，部分匹配值就是0</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i &lt; next.length; i++) &#123;<br>           <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;dest.charAt(i)!=dest.charAt(j))&#123;<br>               j=next[j-<span class="hljs-number">1</span>];<br>           &#125;<br>           <span class="hljs-comment">//部分匹配值+1</span><br>           <span class="hljs-keyword">if</span> (dest.charAt(i)==dest.charAt(j))&#123;<br>               j++;<br>           &#125;<br>           next[i]=j;<br>       &#125;<br>       <span class="hljs-keyword">return</span> next;<br>   &#125;<br><br>   <span class="hljs-comment">//KMP算法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(String str1,String str2,<span class="hljs-type">int</span>[] next)</span>&#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;<br>           <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;str1.charAt(i)!=str2.charAt(j))&#123;<br>               j=next[j-<span class="hljs-number">1</span>];<br>           &#125;<br>           <span class="hljs-keyword">if</span> (str1.charAt(i)==str2.charAt(j))&#123;<br>               j++;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (j==str2.length())&#123;<br>               <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h4 id="24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）"><a href="#24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）" class="headerlink" title="24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）"></a>24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）</h4><p>（1）普里姆算法：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666017664904-50f92163-0947-47e8-92e1-c43c3b1dad5f.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Prim算法,得到最小生成树</span><br>    <span class="hljs-comment">//v表示从哪一个顶点开始</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] prim(MGraph graph,<span class="hljs-type">int</span> v)&#123;<br>        <span class="hljs-type">int</span>[][] route=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.vertex][graph.vertex];<br>        <span class="hljs-type">int</span> minWay=<span class="hljs-number">10000</span>;<span class="hljs-comment">//记录最小路径</span><br>        <span class="hljs-type">int</span> x=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> y=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.vertex];<span class="hljs-comment">//记录顶点是否被访问</span><br>        visited[v]=<span class="hljs-number">1</span>;<span class="hljs-comment">//v记录已经被访问</span><br><br>        <span class="hljs-comment">//n个顶点的边未n-1个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; graph.vertex - <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-comment">//寻找已经访问顶点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.vertex; i++) &#123;<br>                <span class="hljs-comment">//遍历已访问顶点的邻接顶点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graph.vertex; j++) &#123;<br>                    <span class="hljs-comment">//顶点已经被访问，顶点i的邻接顶点j未被访问</span><br>                    <span class="hljs-keyword">if</span> (visited[i]==<span class="hljs-number">1</span>&amp;&amp;visited[j]==<span class="hljs-number">0</span>&amp;&amp;graph.weight[i][j]&lt;minWay)&#123;<br>                        minWay=graph.weight[i][j];<br>                        x=i;<br>                        y=j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;路劲&quot;</span>+x+<span class="hljs-string">&quot;-&gt;&quot;</span>+y+<span class="hljs-string">&quot;:&quot;</span>+minWay);<br>            <span class="hljs-comment">//记录最小路径</span><br>            route[x][y]=minWay;<br>            <span class="hljs-comment">//y节点标记未已经访问</span><br>            visited[y]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//minWay重新初始化</span><br>            minWay=<span class="hljs-number">10000</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> route;<br>    &#125;<br></code></pre></td></tr></table></figure><p>（2）克鲁斯卡尔算法<br>①所有边的权值从小到大排序；<br>②依次从边中选取最小边值加入到最小生成树中，并判断是否有回路存在；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666060310804-a6578624-76d5-42d3-95a5-db4dfd7aaaaa.jpeg"><br>③判断是否有回路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666061043459-817da6d0-66a9-4dbe-9f1a-3e1f61e1b0f2.jpeg"></p><h4 id="25、迪杰斯特拉算法（Dijkstra）和-弗洛伊德算法（Floyd）"><a href="#25、迪杰斯特拉算法（Dijkstra）和-弗洛伊德算法（Floyd）" class="headerlink" title="25、迪杰斯特拉算法（Dijkstra）和 弗洛伊德算法（Floyd）"></a>25、迪杰斯特拉算法（Dijkstra）和 弗洛伊德算法（Floyd）</h4><p>（1）迪杰斯特拉算法：<br>用于计算一个节点到其他节点的最短路径（广度优先的思想）<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666099671713-02d0d2cd-7ef2-4e0d-aba9-dbbc46aa7812.jpeg"><br>dis数组，记录顶点v到其他顶点的最短路径<br>dis更新规则：比较初始顶点v到V集合的距离，与v通过前驱节点到V集合中顶点距离，保留较小值</p><table><thead><tr><th>dis</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>65535</td><td>2</td><td>2</td></tr><tr><td><strong>B</strong></td><td>65535</td><td>3</td><td>3</td></tr><tr><td>C</td><td>65535</td><td>65535</td><td>9</td></tr><tr><td>D</td><td>65535</td><td>65535</td><td>65535</td></tr><tr><td>E</td><td>65535</td><td>4</td><td>4</td></tr><tr><td>F</td><td>65535</td><td>6</td><td>6</td></tr><tr><td>G</td><td>0</td><td>65535</td><td>4</td></tr></tbody></table><p>pre数组，记录每一个节点的前一个节点的下标</p><table><thead><tr><th>pre</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td><strong>B</strong></td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td>C</td><td>-1</td><td>-1</td><td>0  A</td></tr><tr><td>D</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>E</td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td>F</td><td>-1</td><td>6   G</td><td>6 G</td></tr><tr><td>G</td><td>-1</td><td>-1</td><td>-1</td></tr></tbody></table><p>vistied数组记录节点是否被访问，1表示被访问</p><table><thead><tr><th>pre</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>0</td><td>1</td></tr><tr><td><strong>B</strong></td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td></tr><tr><td>E</td><td>0</td><td>0</td><td>0</td></tr><tr><td>F</td><td>0</td><td>0</td><td>0</td></tr><tr><td>G</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迪杰斯特拉算法，index表示起始顶点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-comment">//初始化记录数组</span><br>        visitedVertex=<span class="hljs-keyword">new</span> <span class="hljs-title class_">VisitedVertex</span>(vertex.length,index);<br>        <span class="hljs-comment">//获取到记录数组</span><br>        <span class="hljs-type">int</span>[] dis = visitedVertex.dis;<br>        <span class="hljs-type">int</span>[] visited = visitedVertex.visited;<br>        <span class="hljs-type">int</span>[] pre = visitedVertex.pre;<br>        <span class="hljs-comment">//标记起始顶点为已经访问</span><br>        visited[index]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//更新dis数组和前驱数组，第一趟</span><br>        update(index);<br>        <span class="hljs-comment">//开始查找起始顶点，经过中间节点，到目标节点的距离  与原最短距离比较</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> searchNext(index);<br>            <span class="hljs-comment">//标记next为已经访问节点</span><br>            visited[next]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//更新最短距离</span><br>            update(next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//更新起始顶点经过index顶点到其他顶点的最短路径，并且更新前驱节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>            <span class="hljs-comment">//起始顶点到index顶点，再到i点的距离</span><br>            len=visitedVertex.dis[index]+matrix[index][i];<br>            <span class="hljs-keyword">if</span> (visitedVertex.visited[index]!=<span class="hljs-number">0</span>&amp;&amp;<br>                    visitedVertex.dis[i]&gt;len)&#123;<br>                visitedVertex.dis[i]=len;<br>                visitedVertex.pre[i]=index;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找一个距离index顶点最近的点返回，且该点是未访问过</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> min=<span class="hljs-number">65535</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visitedVertex.visited[i]!=<span class="hljs-number">1</span>&amp;&amp;min&gt;visitedVertex.dis[i])&#123;<br>                min=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历最短路径</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>          System.out.print(<span class="hljs-string">&quot;顶点&quot;</span>+vertex[index]);<br>          print(i);<br>          System.out.println();<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>      <span class="hljs-keyword">if</span> (visitedVertex.pre[index]==-<span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      print(visitedVertex.pre[index]);<br>      System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[index]);<br>  &#125;<br></code></pre></td></tr></table></figure><p>（2）弗洛伊德算法<br>①计算图中各个顶点的最短路径，每一个顶点都是起始顶点，求每一个起始顶点到其他顶点的最短路径；（迪杰斯特拉则是选定一个顶点为起始顶点，求其到其他顶点的最短路径）<br>②思路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666150127439-a7d252d0-eeaf-4170-8572-c8fa39e90c51.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] vertex;<span class="hljs-comment">//顶点数组</span><br>    <span class="hljs-type">int</span>[][] dis;<span class="hljs-comment">//保存从各个顶点出发，到其他顶点距离</span><br>    <span class="hljs-type">int</span>[][] pre;<span class="hljs-comment">//保存到目标结点的中间结点</span><br><br><span class="hljs-comment">//弗洛伊德算法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//中间顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; vertex.length; k++) &#123;<br>            <span class="hljs-comment">//起始顶点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>                <span class="hljs-comment">//终点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vertex.length; j++) &#123;<br>                    <span class="hljs-type">int</span> len=dis[i][k]+ dis[k][j];<span class="hljs-comment">//起始顶点，经过k，再到终点j</span><br>                    <span class="hljs-keyword">if</span> (len&lt; dis[i][j])&#123;<br>                        dis[i][j]=len;<span class="hljs-comment">//更新最短距离</span><br>                        pre[i][j]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历i到j最短距离</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;顶点&quot;</span>+vertex[i]+<span class="hljs-string">&quot;到顶点&quot;</span>+vertex[j]+<span class="hljs-string">&quot;的最短路径:&quot;</span>+vertex[i]);<br>    goDeap(i,j);<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[j]);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDeap</span><span class="hljs-params">(<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[begin][end]==-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[pre[begin][end]]);<br>    goDeap(pre[begin][end],end);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="26、字典树（Trie）"><a href="#26、字典树（Trie）" class="headerlink" title="26、字典树（Trie）"></a>26、字典树（Trie）</h4><p>（1）结点本身不存储完整单词；<br>（2）从根结点到某一结点，路径上经过的字符连接起来，为该结点的字符串；<br>（3）每个结点的所有子结点路径代表的字符都不相同；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670332166896-5d03a137-5e01-43fe-ac4a-351e1665edb4.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] dict;<span class="hljs-comment">//存储字字符</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<span class="hljs-comment">//true表示是字符串最后一个字符，及最后一层</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        dict=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//插入字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-comment">//当前结点</span><br>        Trie node=<span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">//遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> ch=word.charAt(i);<br>            <span class="hljs-comment">//存储下标</span><br>            <span class="hljs-type">int</span> index=ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//判断该字符是否出现过</span><br>            <span class="hljs-keyword">if</span> (node.dict[index]==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//存储该字符</span><br>                node.dict[index]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            <span class="hljs-comment">//进入子节点</span><br>            node=node.dict[index];<br>        &#125;<br>        <span class="hljs-comment">//标记最后一个字符为最后位置</span><br>        node.isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//查找字符串是否存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> trie!=<span class="hljs-literal">null</span>&amp;&amp;trie.isEnd;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> searchPrefix(prefix);<br>        <span class="hljs-keyword">return</span> trie!=<span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断字符前缀是否存在</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String word)</span>&#123;<br>        Trie node=<span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">//遍历字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> ch=word.charAt(i);<br>            <span class="hljs-comment">//获取下标位置</span><br>            <span class="hljs-type">int</span> index=ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//该字符不存在</span><br>            <span class="hljs-keyword">if</span> (node.dict[index]==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//进入下一个结点</span><br>            node=node.dict[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="27、并查集"><a href="#27、并查集" class="headerlink" title="27、并查集"></a>27、并查集</h4><h5 id="（1）普通并查集"><a href="#（1）普通并查集" class="headerlink" title="（1）普通并查集"></a>（1）普通并查集</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670500482203-dfd3eae6-5acb-43d6-bfc9-bc660aa9a860.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        count=n;<br>        parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i]=i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-keyword">while</span> (p!=parent[p])&#123;<br>            parent[p]=parent[parent[p]];<br>            p=parent[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> rootP=find(p);<br>        <span class="hljs-type">int</span> rootQ=find(q);<br>        <span class="hljs-keyword">if</span> (rootQ==rootP)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        parent[rootP]=rootQ;<br>        count--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）带权并查集"><a href="#（2）带权并查集" class="headerlink" title="（2）带权并查集"></a>（2）带权并查集</h5><h6 id="①寻找父节点（路径压缩）"><a href="#①寻找父节点（路径压缩）" class="headerlink" title="①寻找父节点（路径压缩）"></a>①寻找父节点（路径压缩）</h6><p>寻找父节点时，同时更新权值<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1680706918139-cd6a4f0c-f415-4997-b5a1-63730f52eae6.jpeg"></p><h6 id="②合并"><a href="#②合并" class="headerlink" title="②合并"></a>②合并</h6><p>小节点指向大节点<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1680707366906-d809ad4d-56f0-4077-9685-50d8ed687a2d.jpeg"></p><h5 id="（3）代码"><a href="#（3）代码" class="headerlink" title="（3）代码"></a>（3）代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Value</span> &#123;<br>    <span class="hljs-type">int</span>[] parent;<span class="hljs-comment">//父节点</span><br>    <span class="hljs-type">int</span>[] value;<span class="hljs-comment">//权值</span><br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Union_Value</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i]=i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//寻找父节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        <span class="hljs-comment">//当前节点为根节点</span><br>        <span class="hljs-keyword">if</span> (node==parent[node])&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-comment">//记录当前节点的父节点</span><br>        <span class="hljs-type">int</span> temp=parent[node];<br>        <span class="hljs-comment">//寻找根节点</span><br>        parent[node]=findParent(parent[node]);<br>        <span class="hljs-comment">//更新当前节点的权值</span><br>        value[node]+=value[temp];<br>        <span class="hljs-keyword">return</span> parent[node];<br>    &#125;<br><br>    <span class="hljs-comment">//合并节点值,weight为节点x与y之间的权值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> weight)</span>&#123;<br>        <span class="hljs-type">int</span> xRoot=findParent(x);<br>        <span class="hljs-type">int</span> yRoot=findParent(y);<br>        <span class="hljs-keyword">if</span> (xRoot==yRoot)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//小节点指向大节点</span><br>        parent[xRoot]=yRoot;<br>        value[xRoot]=value[y]+weight-value[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="28、红黑树"><a href="#28、红黑树" class="headerlink" title="28、红黑树"></a>28、红黑树</h4><p>（1）每个结点要么是红色，要么是黑色；<br>（2）根结点是黑色；<br>（3）每个叶子结点（NULL结点）是黑色的；<br>（4）不能相邻两个红色结点；<br>（5）从任一结点到其他每个叶子的所有路径都包含相同数目的黑色结点；<br>（6）任何一个结点的左右子树的高度差小于两倍;</p><h4 id="29、布隆过滤器"><a href="#29、布隆过滤器" class="headerlink" title="29、布隆过滤器"></a>29、布隆过滤器</h4><p>查找不到的元素一定不存在，查找到的元素可能存在<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1671885966092-4db90117-0ab6-40a1-b24c-c64d4c4f1b35.jpeg"></p><h4 id="30、LRU缓存"><a href="#30、LRU缓存" class="headerlink" title="30、LRU缓存"></a>30、LRU缓存</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1671887081323-73d147ca-175a-4a53-a9e8-d083375ecdb0.jpeg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/2022/04/07/Tomcat/"/>
    <url>/2022/04/07/Tomcat/</url>
    
    <content type="html"><![CDATA[<h3 id="1、整体架构和组件"><a href="#1、整体架构和组件" class="headerlink" title="1、整体架构和组件"></a>1、整体架构和组件</h3><h4 id="（1）整体架构"><a href="#（1）整体架构" class="headerlink" title="（1）整体架构"></a>（1）整体架构</h4><blockquote><ul><li><p>Connector：用于处理连接事件，并提供Socket与Request，Response的转化；</p></li><li><p>Container：封装和管理Servlet，用户处理Request请求；</p></li><li><p>一个Tomcat只有一个Server，一个Server有多个Service；</p></li><li><p>一个Service中只有一个Container，但有多个Connector，因为一个Service可以有多个连接；其生命周期由Server控制；</p><img src="/2022/04/07/Tomcat/1.jpg" class="" title="Tomcat"></li></ul></blockquote><h4 id="（2）组件"><a href="#（2）组件" class="headerlink" title="（2）组件"></a>（2）组件</h4><h5 id="①组件介绍"><a href="#①组件介绍" class="headerlink" title="①组件介绍"></a>①组件介绍</h5><blockquote><ul><li><p>Server：服务器，启动和停止整个系统；</p></li><li><p>Service：服务，一个Server上可以由多个服务，如订单服务，支付服务；</p></li><li><p>Connector：连接器，一个服务可以支持多种协议，每个协议对应一个Connector来处理；</p></li><li><p>Container：表示容器，即Servlet容器，包括Engine（引擎）、Host（主机）、Context（上下文）、Wrapper（包装器）；</p></li><li><p>Connector和Container关系：所有请求到达Tomcat后，首先经过Service交由Connector进行处理，Connector会将请求封装为Request，然后将请求交给Container处理，Container处理完后交给Connector，Connector底层通过socket进行数据返回客户端；</p><img src="/2022/04/07/Tomcat/2.jpg" class="" title="Tomcat"></li></ul></blockquote><h5 id="②Connector"><a href="#②Connector" class="headerlink" title="②Connector"></a>②Connector</h5><blockquote><ul><li><p>Connector内部通过ProtocolHandler来处理请求，一个ProtocolHandler代表一个连接处理（如HTTP、HTTPS各有一个对应的ProtocolHandler）；</p></li><li><p>Endpoint用于处理底层socket的连接，Processor用于将Endpoint处理的socket连接封装为Request，Adpater将Request转发给Container；</p></li><li><p>Endpoint用来实现TCP&#x2F;IP协议，Processor用来实现HTTP协议，Adpater用于将请求适配到Servlet容器中处理；</p><img src="/2022/04/07/Tomcat/3.jpg" class="" title="Tomcat"></li></ul></blockquote><h5 id="③Container"><a href="#③Container" class="headerlink" title="③Container"></a>③Container</h5><blockquote><ul><li><p>Container接收到请求后，会调用最顶层PipeLine，即EnginePipeline；</p></li><li><p>然后会依次执行Pipeline中的value，每个Pipeline的最后一个Standard*Value会调用下一个PipeLine；</p></li><li><p>执行到最后一个StandardWrapperValue，会创建FIlterChain，FilterChain包括与请求匹配的filter（过滤器）和Servlet，依次执行FIlterChain中的doFilter（）方法，执行完后会调用service方法；</p></li><li><p>请求处理完毕后，会将结果返回给Connector；</p><img src="/2022/04/07/Tomcat/4.jpg" class="" title="Tomcat"></li></ul></blockquote><h3 id="2、生命周期Lifecycle机制"><a href="#2、生命周期Lifecycle机制" class="headerlink" title="2、生命周期Lifecycle机制"></a>2、生命周期Lifecycle机制</h3><h4 id="（1）LIfecycle"><a href="#（1）LIfecycle" class="headerlink" title="（1）LIfecycle"></a>（1）LIfecycle</h4><blockquote><ul><li>Lifecycle是一个状态机，管理组件的生命周期；</li><li>当组件状态为starting_prep（准备启动），starting（正在启动），started（已经启动），调用star（）方法是无效的；</li><li>当组件状态为new（新创建），调用start（）方法会先执行init（）方法，然后执行start（）；</li><li>当组件状态为stop_prep（准备停止），stopping（正在停止），stoped（已经停止），调用stop（）方法为无效的；</li><li>stop（）方法可以将new状态变为stoped状态；</li></ul></blockquote><h4 id="（2）LifecycleBase"><a href="#（2）LifecycleBase" class="headerlink" title="（2）LifecycleBase"></a>（2）LifecycleBase</h4><h5 id="①监听器增加，删除，返回"><a href="#①监听器增加，删除，返回" class="headerlink" title="①监听器增加，删除，返回"></a>①监听器增加，删除，返回</h5><blockquote><ul><li>生命周期的监听器保存在CopyOnWriteArrayList集合中，保证线程安全；</li><li>返回监听器是返回一个新的数组；</li><li>采用模板设计模式来实现；</li></ul></blockquote><h5 id="②init（）"><a href="#②init（）" class="headerlink" title="②init（）"></a>②init（）</h5><blockquote><ul><li>setStateInternal（）：修改状态state，state用volite修饰；</li><li>initInternal（）：为abstract类型，需要组件自己实现对应方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;<span class="hljs-comment">//不是NEW状态，不能调用</span><br>        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        setStateInternal(LifecycleState.INITIALIZING, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//修改状态</span><br>        initInternal();<span class="hljs-comment">//初始化方法，需要组件自己实现</span><br>        setStateInternal(LifecycleState.INITIALIZED, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//修改状态</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleSubClassException(t, <span class="hljs-string">&quot;lifecycleBase.initFail&quot;</span>, toString());<span class="hljs-comment">//异常处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③start（）"><a href="#③start（）" class="headerlink" title="③start（）"></a>③start（）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br><span class="hljs-comment">//不是启动，准备启动，正在启动状态</span><br>    <span class="hljs-keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||<br>        LifecycleState.STARTED.equals(state)) &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//为new状态，调用init（）方法</span><br>    <span class="hljs-keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;<br>        init();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;<span class="hljs-comment">//启动失败</span><br>        stop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;<br>               !state.equals(LifecycleState.STOPPED)) &#123;<br>        invalidTransition(Lifecycle.BEFORE_START_EVENT);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        setStateInternal(LifecycleState.STARTING_PREP, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        startInternal();<span class="hljs-comment">//组件自己实现</span><br>        <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;<br>            stop();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;<br>            invalidTransition(Lifecycle.AFTER_START_EVENT);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setStateInternal(LifecycleState.STARTED, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//设置为已启动状态</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleSubClassException(t, <span class="hljs-string">&quot;lifecycleBase.startFail&quot;</span>, toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="④stop（）"><a href="#④stop（）" class="headerlink" title="④stop（）"></a>④stop（）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-keyword">if</span> (LifecycleState.STOPPING_PREP.equals(state) || LifecycleState.STOPPING.equals(state) ||<br>        LifecycleState.STOPPED.equals(state)) &#123;<span class="hljs-comment">//为这些状态，不能调用</span><br>    <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//将new状态设置为stopped状态</span><br>    <span class="hljs-keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;<br>        state = LifecycleState.STOPPED;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.STARTED) &amp;&amp; !state.equals(LifecycleState.FAILED)) &#123;<br>        invalidTransition(Lifecycle.BEFORE_STOP_EVENT);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;<br>            fireLifecycleEvent(BEFORE_STOP_EVENT, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setStateInternal(LifecycleState.STOPPING_PREP, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        stopInternal();<span class="hljs-comment">//组件自己实现</span><br>        <span class="hljs-keyword">if</span> (!state.equals(LifecycleState.STOPPING) &amp;&amp; !state.equals(LifecycleState.FAILED)) &#123;<br>            invalidTransition(Lifecycle.AFTER_STOP_EVENT);<br>        &#125;<br>        setStateInternal(LifecycleState.STOPPED, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑤destory（）"><a href="#⑤destory（）" class="headerlink" title="⑤destory（）"></a>⑤destory（）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-keyword">if</span> (LifecycleState.FAILED.equals(state)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            stop();<span class="hljs-comment">//failed状态触发stop方法</span><br>        &#125; <br>        <span class="hljs-comment">//代码忽略。。。。</span><br>    &#125;<br><span class="hljs-comment">//处于销毁或已经销毁状态</span><br>    <span class="hljs-keyword">if</span> (LifecycleState.DESTROYING.equals(state) || LifecycleState.DESTROYED.equals(state)) &#123;<br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//检查不合法状态代码忽略。。。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        setStateInternal(LifecycleState.DESTROYING, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        destroyInternal();<span class="hljs-comment">//组件自己实现</span><br>        setStateInternal(LifecycleState.DESTROYED, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleSubClassException(t, <span class="hljs-string">&quot;lifecycleBase.destroyFail&quot;</span>, toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、类加载"><a href="#3、类加载" class="headerlink" title="3、类加载"></a>3、类加载</h3><h4 id="（1）类加载机制"><a href="#（1）类加载机制" class="headerlink" title="（1）类加载机制"></a>（1）类加载机制</h4><blockquote><ul><li>java虚拟机把描述类的数据从Class类加载进行内存，并对数据进行校验、解析转换、初始化，最终形成可被虚拟机直接使用的java类型；</li><li>对于任何一个类，需要由加载他的类加载器和该类确定其在java虚拟机中的唯一性，每一个类加载器都有一个唯一的命名空间；</li><li>比较两个类是否相等，不同类加载器的类比较肯定不相等；</li></ul></blockquote><h4 id="（2）双亲委派模型"><a href="#（2）双亲委派模型" class="headerlink" title="（2）双亲委派模型"></a>（2）双亲委派模型</h4><blockquote><p>类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：加载存放于JAVA_HOME&#x2F;lib目录下文件，由虚拟机识别，按照文件名称识别；</li><li>扩展类加载器（Extension ClassLoader）：加载存放于JAVA_HOME&#x2F;lib&#x2F;ext目录下的类库；</li><li>应用程序类加载器（Application ClassLoader）：加载ClassPath下的类库（即我们自己开发的类）；</li></ul><p>双亲委派工作原理：</p><ul><li>一个类加载器收到类加载请求，自己不会加载，会传给父类加载器加载；</li><li>最终传送到启动类加载器，若父类加载器无法加载该类，子类会尝试加载；</li></ul><p>使用双亲委派原因：</p><ul><li>若不这样做，当用户写了一个java.lang.String类，并放在ClassPath下，那系统中会出现多个String类，会破坏java类型体系；</li><li>当开启双亲委派，当用户写了一个java.lang.String类，并放在ClassPath下，会直接报错；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 查看类是否被加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//让父类加载类</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">//父类加载不了，抛出异常</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//父类未加载到</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<span class="hljs-comment">//调用本身类加载器加载</span><br>                <span class="hljs-comment">//类记录代码忽略。。。。。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）Tomcat类加载"><a href="#（3）Tomcat类加载" class="headerlink" title="（3）Tomcat类加载"></a>（3）Tomcat类加载</h4><blockquote><p>Tomcat不能使用默认类加载机制：</p><ul><li>多个不同应用程序依赖同一个类库的不同版本，默认类加载器只能加载一份唯一的类库，不会管类库的版本号；</li><li>当修改jsp文件时，默认类加载器会直接获取方法区中的jsp文件（旧的），修改的jsp是不会被加载进去，解决方法就是将jsp类加载器卸载，重新创建类加载器；</li></ul><p>Tomcat新增类加载器：</p><ul><li><p>Common类加载器：加载Tomcat和Web都复用的类；</p></li><li><p>Cataline类加载器：加载Tomcat专用的类；</p></li><li><p>Shared类加载器：加载Tomcat下所有应用程序复用的类；</p></li><li><p>WebApplication类加载器：加载具体的web应用中所使用的类；</p></li><li><p>Jsp类加载器：加载每一个Jsp页面，实现热插拔（修改代码后，不用重启也会生效）；</p><img src="/2022/04/07/Tomcat/5.jpg" class="" title="Tomcat"></li></ul></blockquote><h3 id="4、Tomcat启动过程"><a href="#4、Tomcat启动过程" class="headerlink" title="4、Tomcat启动过程"></a>4、Tomcat启动过程</h3><h4 id="（1）启动脚本"><a href="#（1）启动脚本" class="headerlink" title="（1）启动脚本"></a>（1）启动脚本</h4><blockquote><ul><li>startup.sh是Tomcat的启动脚本，会调用catalina.sh脚本，并且传入start参数；</li></ul><img src="/2022/04/07/Tomcat/6.jpg" class="" title="Tomcat"><ul><li>catalina.sh脚本会调用Bootstrap中的main（）方法，并且携带start参数；</li></ul><img src="/2022/04/07/Tomcat/7.jpg" class="" title="Tomcat"></blockquote><h4 id="（2）Bootstrap-main"><a href="#（2）Bootstrap-main" class="headerlink" title="（2）Bootstrap.main()"></a>（2）Bootstrap.main()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (daemonLock) &#123;<br>        <span class="hljs-keyword">if</span> (daemon == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//daemon为bootstrap，刚启动时，dameon为null</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//类加载</span><br>                bootstrap.init();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-comment">//异常处理代码忽略。。。。。</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            daemon = bootstrap;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;start&quot;</span>;<br>        <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//获取最后一个参数，catalina.sh传入参数为start</span><br>            command = args[args.length - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;startd&quot;</span>)) &#123;<span class="hljs-comment">//启动状态</span><br>            args[args.length - <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;start&quot;</span>;<br>            daemon.load(args);<br>            daemon.start();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;stopd&quot;</span>)) &#123;<span class="hljs-comment">//停止状态</span><br>            args[args.length - <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;stop&quot;</span>;<br>            daemon.stop();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;start&quot;</span>)) &#123;<span class="hljs-comment">//启动状态</span><br>            daemon.setAwait(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置catalina实例setAwait（）方法</span><br>            daemon.load(args);<span class="hljs-comment">///调用catalina的load（）方法</span><br>            daemon.start();<span class="hljs-comment">//反射调用Catalina的start（）方法</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == daemon.getServer()) &#123;<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">//代码忽略。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Bootstrap.init()：</strong></p><ul><li>反射创建类Catalina实例，并赋值给catalinaDaemon；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    initClassLoaders();<span class="hljs-comment">//加载启动需要的相关类</span><br>    <span class="hljs-comment">//代码忽略。。。。。。。</span><br><span class="hljs-comment">//反射实例化Catalina类</span><br>    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="hljs-string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">startupInstance</span> <span class="hljs-operator">=</span> startupClass.getConstructor().newInstance();<br>    <span class="hljs-comment">//代码忽略。。。。。。。</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;setParentClassLoader&quot;</span>;<br>    <span class="hljs-comment">//参数设置代码忽略。。。。。。。</span><br>    startupInstance.getClass().getMethod(methodName, paramTypes);<br>    method.invoke(startupInstance, paramValues);<span class="hljs-comment">//执行setParentClassLoader()方法</span><br>    catalinaDaemon = startupInstance;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）daemon-load-args-【main方法中】"><a href="#（3）daemon-load-args-【main方法中】" class="headerlink" title="（3）daemon.load(args)【main方法中】"></a>（3）daemon.load(args)【main方法中】</h4><h5 id="①Catalina-load（）方法"><a href="#①Catalina-load（）方法" class="headerlink" title="①Catalina.load（）方法"></a>①Catalina.load（）方法</h5><blockquote><ul><li><p>daemon.load（）方法，反射调用Catalina.load（）方法；</p></li><li><p>核心方法为getServer.init()，该方法初始化了server，server为Tomcat中的最外容器；</p><img src="/2022/04/07/Tomcat/8.jpg" class="" title="Tomcat"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Catalina.load()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (loaded) &#123;<span class="hljs-comment">//已经加载过</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    loaded = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    initDirs();<br>    initNaming();<span class="hljs-comment">//初始化jmx</span><br>    <span class="hljs-comment">//代码忽略。。。。。。。。</span><br>    <span class="hljs-type">Digester</span> <span class="hljs-variable">digester</span> <span class="hljs-operator">=</span> createStartDigester();<span class="hljs-comment">//告知digester，哪个xml应该解析成生命类型</span><br><br>    <span class="hljs-keyword">try</span> (ConfigurationSource.<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> ConfigFileLoader.getSource().getServerXml()) &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> resource.getInputStream();<br>        <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(resource.getURI().toURL().toString());<br>        inputSource.setByteStream(inputStream);<br>        digester.push(<span class="hljs-built_in">this</span>);<br>        digester.parse(inputSource);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       <span class="hljs-comment">//异常处理代码忽略。。。。。。</span><br>    &#125;<br><span class="hljs-comment">//server设置catalina信息</span><br>    getServer().setCatalina(<span class="hljs-built_in">this</span>);<br>    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());<br>    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());<br>    initStreams();<br>    <span class="hljs-keyword">try</span> &#123;<br>        getServer().init();<span class="hljs-comment">//调用lifecycle的init方法,server初始化</span><br>    &#125; <br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②Server初始化"><a href="#②Server初始化" class="headerlink" title="②Server初始化"></a>②Server初始化</h5><blockquote><ul><li>Server的实现类为StandardServer，下面的initInternal（）方法会调用StandardServer中的方法；</li><li>StandardServer中，遍历每一个Service，对每一个Service中的组件进行初始化；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lifecycleBase.init()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br><span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        setStateInternal(LifecycleState.INITIALIZING, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        initInternal();<span class="hljs-comment">//初始化各种service组件</span><br>        setStateInternal(LifecycleState.INITIALIZED, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125; <br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br><span class="hljs-comment">//StandardServer.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-built_in">super</span>.initInternal();<br>    <span class="hljs-comment">//代码忽略。。。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; services.length; i++) &#123;<br>        services[i].init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③Service初始化"><a href="#③Service初始化" class="headerlink" title="③Service初始化"></a>③Service初始化</h5><blockquote><ul><li>StandardServer中遍历services数组，调用init（）方法初始化，最终调用StandardService中的initInternal（）方法；</li><li>该方法会初始化Engine。Connector组件；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardService.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-built_in">super</span>.initInternal();<br>    <span class="hljs-keyword">if</span> (engine != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//初始化engine</span><br>        engine.init();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Executor executor : findExecutors()) &#123;<span class="hljs-comment">//默认没有</span><br>        <span class="hljs-keyword">if</span> (executor <span class="hljs-keyword">instanceof</span> JmxEnabled) &#123;<br>            ((JmxEnabled) executor).setDomain(getDomain());<br>        &#125;<br>        executor.init();<br>    &#125;<br>    mapperListener.init();<br><span class="hljs-comment">//初始化Connector组件</span><br>    <span class="hljs-keyword">synchronized</span> (connectorsLock) &#123;<br>        <span class="hljs-keyword">for</span> (Connector connector : connectors) &#123;<br>            connector.init();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑤Engine初始化"><a href="#⑤Engine初始化" class="headerlink" title="⑤Engine初始化"></a>⑤Engine初始化</h5><blockquote><ul><li>StandardEngine初始化时，会调用父类ContainerBase的初始化方法，初始化stopstartExcutor线程池；</li><li>startstopExceutor线程池：在start和stop阶段，会将子容器的start或stop放入该线程池中执行；</li><li>Engine初始化时，不会初始化子容器，子容器初始化是在start时初始化的；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardEngine.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    getRealm();<br>    <span class="hljs-built_in">super</span>.initInternal();<span class="hljs-comment">//调用ContainerBase中方法</span><br>&#125;<br><span class="hljs-comment">//ContainerBaase.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    reconfigureStartStopExecutor(getStartStopThreads());<br>    <span class="hljs-built_in">super</span>.initInternal();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconfigureStartStopExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> threads)</span> &#123;<br>    <span class="hljs-keyword">if</span> (threads == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!(startStopExecutor <span class="hljs-keyword">instanceof</span> InlineExecutorService)) &#123;<br>            startStopExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InlineExecutorService</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Delegate utility execution to the Service</span><br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> Container.getService(<span class="hljs-built_in">this</span>).getServer();<br>        server.setUtilityThreads(threads);<span class="hljs-comment">//初始化线程池</span><br>        startStopExecutor = server.getUtilityExecutor();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//StandardServer.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUtilityThreads</span><span class="hljs-params">(<span class="hljs-type">int</span> utilityThreads)</span> &#123;<br><span class="hljs-comment">//代码忽略.......</span><br>    <span class="hljs-keyword">if</span> (oldUtilityThreads != utilityThreads &amp;&amp; utilityExecutor != <span class="hljs-literal">null</span>) &#123;<br>        reconfigureUtilityExecutor(getUtilityThreadsInternal(utilityThreads));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconfigureUtilityExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> threads)</span> &#123;<br>    <span class="hljs-keyword">if</span> (utilityExecutor != <span class="hljs-literal">null</span>) &#123;<br>        utilityExecutor.setCorePoolSize(threads);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">scheduledThreadPoolExecutor</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(threads, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskThreadFactory</span>(<span class="hljs-string">&quot;Catalina-utility-&quot;</span>, utilityThreadsAsDaemon, Thread.MIN_PRIORITY));<br>        <span class="hljs-comment">//查过10秒未获取任务，线程池销毁</span><br>    scheduledThreadPoolExecutor.setKeepAliveTime(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>        scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        utilityExecutor = scheduledThreadPoolExecutor;<br>        utilityExecutorWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.apache.tomcat.util.threads.ScheduledThreadPoolExecutor(utilityExecutor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑥Connector初始化"><a href="#⑥Connector初始化" class="headerlink" title="⑥Connector初始化"></a>⑥Connector初始化</h5><blockquote><ul><li>初始化adapter，adapter用于将请求转发给Container处理；</li><li>设置接收body的方法列表；</li><li>初始化protocolHandler，protocolHandler用于处理请求；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Connector.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-built_in">super</span>.initInternal();<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-comment">// 初始化adapter</span><br>    adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoyoteAdapter</span>(<span class="hljs-built_in">this</span>);<br>    protocolHandler.setAdapter(adapter);<br>    <span class="hljs-keyword">if</span> (service != <span class="hljs-literal">null</span>) &#123;<br>        protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());<br>    &#125;<br>    <span class="hljs-comment">//设置接收body的method列表</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == parseBodyMethodsSet) &#123;<br>        setParseBodyMethods(getParseBodyMethods());<br>    &#125;<br>    <span class="hljs-comment">//代码忽略。。。。。。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        protocolHandler.init();<span class="hljs-comment">//初始化protocolHandler，调用AbstractProtocol的init（）</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleException</span>( sm.getString(<span class="hljs-string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>protocolHandler初始化：</p><ul><li>ProtocolHanlder继承了AbstractProtocol，其init（）方法调用抽象父类的init（）方法；</li><li>接着调用AbstractEndpoint中的init（）方法，其核心方法为bindWithCLeanup（），该方法调用了bind（）方法；</li><li>最终调bind（）方法(有三个实现类，以NioEndpoint为例)，实现了端口和IP地址的绑定；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractProtocol.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-comment">//设置endpoint</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">endpointName</span> <span class="hljs-operator">=</span> getName();<br>    endpoint.setName(endpointName.substring(<span class="hljs-number">1</span>, endpointName.length()-<span class="hljs-number">1</span>));<br>    endpoint.setDomain(domain);<br>    endpoint.init();<span class="hljs-comment">//初始化endpoint</span><br>&#125;<br><span class="hljs-comment">//AbstractEndpoint.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (bindOnInit) &#123;<br>        bindWithCleanup();<span class="hljs-comment">//该方法实现端口地址绑定</span><br>        bindState = BindState.BOUND_ON_INIT;<br>    &#125;<br><span class="hljs-comment">//代码忽略。。。。。</span><br>&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindWithCleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bind();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>          <span class="hljs-comment">//代码忽略</span><br>    &#125;<br><span class="hljs-comment">//NioEndpoint.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    initServerSocket();<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initServerSocket</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (!getUseInheritedChannel()) &#123;<br>        serverSock = ServerSocketChannel.open();<br>        socketProperties.setProperties(serverSock.socket());<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(getAddress(), getPortWithOffset());<br>        <span class="hljs-comment">//绑定端口和地址</span><br>    serverSock.socket().bind(addr,getAcceptCount());<br>    &#125;<br>    <span class="hljs-comment">//代码忽略。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）daemon-start-【main方法中】"><a href="#（4）daemon-start-【main方法中】" class="headerlink" title="（4）daemon.start()【main方法中】"></a>（4）daemon.start()【main方法中】</h4><h5 id="①Catalina-start（）方法"><a href="#①Catalina-start（）方法" class="headerlink" title="①Catalina.start（）方法"></a>①Catalina.start（）方法</h5><blockquote><ul><li>daemon.start（）方法中，反射调用Catalina.start（）方法</li><li>await()方法：在独立线程中运行，在shutdown端口中阻塞监听关闭命令，收到关闭命令后，调用stop方法</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Catalina</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (getServer() == <span class="hljs-literal">null</span>) &#123;<br>        load();<br>    &#125;<br><span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        getServer().start();<span class="hljs-comment">//server中start方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (LifecycleException e) &#123;<br>        <span class="hljs-comment">//代码忽略。。。</span><br>    &#125;<br><span class="hljs-comment">//代码忽略</span><br><br>    <span class="hljs-comment">// 安全关闭Tomcat</span><br>    <span class="hljs-keyword">if</span> (useShutdownHook) &#123;<br>        <span class="hljs-keyword">if</span> (shutdownHook == <span class="hljs-literal">null</span>) &#123;<br>            shutdownHook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CatalinaShutdownHook</span>();<br>        &#125;<br>        <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (await) &#123;<span class="hljs-comment">//默认为true</span><br>        await();<span class="hljs-comment">//在shutdown端口阻塞监听关闭命令</span><br>        stop();<span class="hljs-comment">//关闭Tocmat</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②StandardServer-start（）方法"><a href="#②StandardServer-start（）方法" class="headerlink" title="②StandardServer.start（）方法"></a>②StandardServer.start（）方法</h5><blockquote><ul><li>LifecycleBase中的start（）方法，为模板方法，启动时调用StandardServer.startInternal（）方法；</li><li>startInternal（）方法：事件发出，启动前做准备，启动每一个service组件</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//LifecycleBase.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br><span class="hljs-comment">//代码忽略。。。。。。。。。</span><br>    setStateInternal(LifecycleState.STARTING_PREP, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    startInternal();<br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br><span class="hljs-comment">//StandServer.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="hljs-literal">null</span>);<br>    setState(LifecycleState.STARTING);<br>    globalNamingResources.start();<br>    <span class="hljs-keyword">synchronized</span> (servicesLock) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; services.length; i++) &#123;<br>            services[i].start();<span class="hljs-comment">//启动组件</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③StandardService-startInternal（）方法"><a href="#③StandardService-startInternal（）方法" class="headerlink" title="③StandardService.startInternal（）方法"></a>③StandardService.startInternal（）方法</h5><blockquote><ul><li>通过LifecycleBase中的start（）方法，调用StandardService.startInternal（）方法，原理同上；</li><li>startInternal（）方法会启动engine，connector组件；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardService.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>    <span class="hljs-comment">//启动engine组件</span><br>    <span class="hljs-keyword">if</span> (engine != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (engine) &#123;<br>            engine.start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (executors) &#123;<span class="hljs-comment">//启动线程池</span><br>        <span class="hljs-keyword">for</span> (Executor executor: executors) &#123;<br>            executor.start();<br>        &#125;<br>    &#125;<br>    mapperListener.start();<br>    <span class="hljs-keyword">synchronized</span> (connectorsLock) &#123;<br>        <span class="hljs-keyword">for</span> (Connector connector: connectors) &#123;<br>            <span class="hljs-keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;<br>                connector.start();<span class="hljs-comment">//启动conector组件</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="④Engine启动"><a href="#④Engine启动" class="headerlink" title="④Engine启动"></a>④Engine启动</h5><blockquote><ul><li><p>StandardEngine，StandardHost，StandardContext，StandardWrapped各个容器存在父子关系；</p></li><li><p>一个父容器对应多个子容器，一个子容器只能对应一个父容器；</p></li><li><p>一个StandardContext对饮一个webapp应用，一个StandardWrapped对应一个webapp中的servlet；</p></li><li><p>这些容器都继承ContainerBase，容器的启动由父容器调子容器start方法启动；如StandardEngine调用StandardHost的start（），StandardHost调用StandardContext的start（）方法；</p><img src="/2022/04/07/Tomcat/9.jpg" class="" title="Tomcat"></li></ul></blockquote><blockquote><p>ContainerBase：</p><ul><li>调用start（）方法会启动Container容器，然后执行ContainerBase的startInternal（）方法，启动子容器；</li><li>ContainerBase会将启动子线程任务交给线程池处理，并遍历所有Future的get（）方法，将异步转换为同步，只有容器全部启动后，才会继续执行下面代码；</li><li>pipeline.start（）启动Valve链表，若Valve是Lifecycle的实现类，则会调用start（）方法启动</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ContainerBase.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>    Container children[] = findChildren();<span class="hljs-comment">//寻找子容器</span><br>    List&lt;Future&lt;Void&gt;&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; children.length; i++) &#123;<br>        <span class="hljs-comment">//线程池启动子容器</span><br>        results.add(startStopExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StartChild</span>(children[i])));<br>    &#125;<br><br>    <span class="hljs-type">MultiThrowable</span> <span class="hljs-variable">multiThrowable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">for</span> (Future&lt;Void&gt; result : results) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result.get();<br>        &#125; <br>        <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">if</span> (pipeline <span class="hljs-keyword">instanceof</span> Lifecycle) &#123;<br>        ((Lifecycle) pipeline).start();<span class="hljs-comment">//启用pipeline</span><br>    &#125;<br>    setState(LifecycleState.STARTING);<br>    <span class="hljs-comment">// Start our thread</span><br>    <span class="hljs-keyword">if</span> (backgroundProcessorDelay &gt; <span class="hljs-number">0</span>) &#123;<br>        monitorFuture = Container.getService(ContainerBase.<span class="hljs-built_in">this</span>).getServer()<br>        .getUtilityExecutor().scheduleWithFixedDelay(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContainerBackgroundProcessorMonitor</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑤Host"><a href="#⑤Host" class="headerlink" title="⑤Host"></a>⑤Host</h5><blockquote><ul><li>valve添加到链表中，是添加在basic之前；</li><li>Context、Wrapper启动方法与Host类似；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardHost.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">errorValve</span> <span class="hljs-operator">=</span> getErrorReportValveClass();<br>    <span class="hljs-keyword">if</span> ((errorValve != <span class="hljs-literal">null</span>) &amp;&amp; (!errorValve.equals(<span class="hljs-string">&quot;&quot;</span>))) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            Valve[] valves = getPipeline().getValves();<br>            <span class="hljs-keyword">for</span> (Valve valve : valves) &#123;<span class="hljs-comment">//遍历所有valve，若已经存在，不添加</span><br>                <span class="hljs-keyword">if</span> (errorValve.equals(valve.getClass().getName())) &#123;<br>                    found = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!found) &#123;<br>                <span class="hljs-type">Valve</span> <span class="hljs-variable">valve</span> <span class="hljs-operator">=</span>(Valve) Class.forName(errorValve).getConstructor().newInstance();<br>                getPipeline().addValve(valve);<span class="hljs-comment">//添加到pipeline</span><br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>    <span class="hljs-built_in">super</span>.startInternal();<span class="hljs-comment">//调用父类启动下一个</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑥Connector启动"><a href="#⑥Connector启动" class="headerlink" title="⑥Connector启动"></a>⑥Connector启动</h5><blockquote><ul><li>调用顺序：Connector中的startInternal()–&gt;AbstractProtocol中的start()–&gt;NioEndpoint中的startInternal（）方法；</li><li>启动poller线程，用于处理请求事件，最终调用protocolHandler处理；</li><li>启动acceptor线程，用于处理请求连接；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Connector.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LifecycleException &#123;<br><span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        protocolHandler.start();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleException</span>(sm.getString(<span class="hljs-string">&quot;coyoteConnector.protocolHandlerStartFailed&quot;</span>), e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//AbstractProtocol.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//代码忽略</span><br>    endpoint.start();<br>    monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<span class="hljs-comment">//异步超时线程</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (!isPaused()) &#123;<br>                    startAsyncTimeout();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//代码忽略。。。</span><br>    startInternal();<br>&#125;<br><span class="hljs-comment">//NioEndpoint.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startInternal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (!running) &#123;<br>        running = <span class="hljs-literal">true</span>;<br>        paused = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-comment">// 启动工作线程</span><br>        <span class="hljs-keyword">if</span> (getExecutor() == <span class="hljs-literal">null</span>) &#123;<br>            createExecutor();<br>        &#125;<br>    <br>        initializeConnectionLatch();<span class="hljs-comment">//初始化最大并发请求数</span><br>    <br>        <span class="hljs-comment">// 启动poller线程，该线程用于接收请求事件，最终调用handler代码</span><br>        poller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Poller</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">pollerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(poller, getName() + <span class="hljs-string">&quot;-ClientPoller&quot;</span>);<br>        pollerThread.setPriority(threadPriority);<br>        pollerThread.setDaemon(<span class="hljs-literal">true</span>);<br>        pollerThread.start();<br>        startAcceptorThread();<span class="hljs-comment">//开启accept线程，处理连接请求</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、HTTP请求处理过程"><a href="#5、HTTP请求处理过程" class="headerlink" title="5、HTTP请求处理过程"></a>5、HTTP请求处理过程</h3><h4 id="（1）Connector请求连接处理"><a href="#（1）Connector请求连接处理" class="headerlink" title="（1）Connector请求连接处理"></a>（1）Connector请求连接处理</h4><img src="/2022/04/07/Tomcat/10.jpg" class="" title="Tomcat"><h5 id="①Acceptor"><a href="#①Acceptor" class="headerlink" title="①Acceptor"></a>①Acceptor</h5><blockquote><ul><li>Acceptor用于监听套接字（socket），将请求转发给poller线程；</li><li>实现了Runable接口，run（）方法为其执行请求连接转发逻辑；</li><li>setSocketOptions（）方法：将socket请求注册到poller中；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Acceptor.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">errorDelay</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (endpoint.isRunning()) &#123;<br>    <span class="hljs-comment">//运行过程中Endpoint停止，进行自旋</span><br>        <span class="hljs-keyword">while</span> (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;<br>            state = AcceptorState.PAUSED;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!endpoint.isRunning()) &#123;<span class="hljs-comment">//停止运行直接退出</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        state = AcceptorState.RUNNING;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//请求超过最大连接数，阻塞等待，直到连接数低于最大连接数</span><br>            endpoint.countUpOrAwaitConnection();<br>            <span class="hljs-keyword">if</span> (endpoint.isPaused()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">U</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//接收新的连接请求</span><br>                socket = endpoint.serverSocketAccept();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ioe) &#123;<br>                <span class="hljs-comment">// 代码忽略</span><br>            &#125;<br>            errorDelay = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// Configure the socket</span><br>            <span class="hljs-keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;<br>                <span class="hljs-comment">/** 将请求以事件方式传递到poller线程中**/</span><br>                <span class="hljs-keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;<br>                    endpoint.closeSocket(socket);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                endpoint.destroySocket(socket);<br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">//代码忽略。。。。。</span><br>    &#125;<br>    state = AcceptorState.ENDED;<br>&#125;<br><span class="hljs-comment">//NioEndpoint.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setSocketOptions</span><span class="hljs-params">(SocketChannel socket)</span> &#123;<br>    <span class="hljs-type">NioSocketWrapper</span> <span class="hljs-variable">socketWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Allocate channel and wrapper</span><br>        <span class="hljs-type">NioChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (nioChannels != <span class="hljs-literal">null</span>) &#123;<br>            channel = nioChannels.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">SocketBufferHandler</span> <span class="hljs-variable">bufhandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketBufferHandler</span>(<br>                <span class="hljs-comment">//代码忽略</span><br>            <span class="hljs-keyword">if</span> (isSSLEnabled()) &#123;<br>                channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureNioChannel</span>(bufhandler, selectorPool, <span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioChannel</span>(bufhandler);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">NioSocketWrapper</span> <span class="hljs-variable">newWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketWrapper</span>(channel, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//代码忽略。。。。。。</span><br>        poller.register(channel, socketWrapper);<span class="hljs-comment">//将NioChannel注册到poller中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②Poller"><a href="#②Poller" class="headerlink" title="②Poller"></a>②Poller</h5><blockquote><ul><li>Poller线程主要用于以较小的资源轮询以连接套接字，以保持连接，当数据可用时，传递给工作线程；</li><li>register（）方法：主要用于Acceptor将请求连接注册到Poller线程中，存放在events同步队列中；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NioEndpoint.Poller.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> NioChannel socket, <span class="hljs-keyword">final</span> NioSocketWrapper socketWrapper)</span> &#123;<br>    socketWrapper.interestOps(SelectionKey.OP_READ);<span class="hljs-comment">//this is what OP_REGISTER turns into.</span><br>    <span class="hljs-type">PollerEvent</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (eventCache != <span class="hljs-literal">null</span>) &#123;<br>        r = eventCache.pop();<span class="hljs-comment">//是否有连接可以复用</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>        r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PollerEvent</span>(socket, OP_REGISTER);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.reset(socket, OP_REGISTER);<br>    &#125;<br>    addEvent(r);<span class="hljs-comment">//添加到events队列中</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEvent</span><span class="hljs-params">(PollerEvent event)</span> &#123;<br>    events.offer(event);<span class="hljs-comment">//添加到事件同步队列中</span><br>    <span class="hljs-keyword">if</span> (wakeupCounter.incrementAndGet() == <span class="hljs-number">0</span>) &#123;<br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>PollerEvent：</strong></p><ul><li>events同步队列，存储的类型为PollerEvent；</li><li>实现Runable接口，run（）方法中判断若为register事件，表示为处理过，注册READ事件，不为register事件，则获取套接字原selectionKey中的事件注册；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NioEndpoint.PollerEvent.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (interestOps == OP_REGISTER) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//为register事件，注册read事件</span><br>            socket.getIOChannel().register(socket.getSocketWrapper().getPoller().getSelector(), SelectionKey.OP_READ, socket.getSocketWrapper());<br>        &#125; <br>        <span class="hljs-comment">//代码忽略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//获取注册事件</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> socket.getIOChannel().keyFor(socket.getSocketWrapper().getPoller().getSelector());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//代码忽略。。。。。</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">NioSocketWrapper</span> <span class="hljs-variable">socketWrapper</span> <span class="hljs-operator">=</span> (NioSocketWrapper) key.attachment();<br>                <span class="hljs-keyword">if</span> (socketWrapper != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//代码忽略。。。</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//注册事件到selcetor中</span><br>                    socket.getSocketWrapper().getPoller().cancelledKey(key, socket.getSocketWrapper());<br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Poller.run（）方法：</strong></p><ul><li>events（）方法：会执行队列中的每一个PollerEvent的run（）方法，run（）方法会将通道（socket）注册道Poller的selector中；</li><li>select（）：返回所有selcetionKey，接着调用processKey（）方法对连接进行处理；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NioEndPoint.Poller.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Loop until destroy() is called</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasEvents</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!close) &#123;<br>                hasEvents = events();<span class="hljs-comment">//调用PollerEvnet中的run（）方法注册事件</span><br>                <span class="hljs-keyword">if</span> (wakeupCounter.getAndSet(-<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                    keyCount = selector.selectNow();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    keyCount = selector.select(selectorTimeout);<br>                &#125;<br>                wakeupCounter.set(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-comment">//代码忽略。。。。。。。</span><br>        &#125;<br>        <span class="hljs-comment">//代码忽略。。。。。。。</span><br>        Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="hljs-number">0</span> ? selector.selectedKeys().iterator() : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//对准备好的连接进行处理</span><br>        <span class="hljs-keyword">while</span> (iterator != <span class="hljs-literal">null</span> &amp;&amp; iterator.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sk</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-type">NioSocketWrapper</span> <span class="hljs-variable">socketWrapper</span> <span class="hljs-operator">=</span> (NioSocketWrapper) sk.attachment();<br>            <span class="hljs-keyword">if</span> (socketWrapper == <span class="hljs-literal">null</span>) &#123;<br>                iterator.remove();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                iterator.remove();<br>                processKey(sk, socketWrapper);<span class="hljs-comment">//真正处理key的逻辑</span><br>            &#125;<br>        &#125;<br>        timeout(keyCount,hasEvents);<br>    &#125;<br><br>    getStopLatch().countDown();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>processKey（）：</strong></p><ul><li>处理读事件，将请求封装为Request；</li><li>处理写事件，将请求封装为Response写回客户端；</li><li>processSocket（）为独立读写事件的核心方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NioEndpoint.Poller.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processKey</span><span class="hljs-params">(SelectionKey sk, NioSocketWrapper socketWrapper)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            cancelledKey(sk, socketWrapper);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sk.isValid() &amp;&amp; socketWrapper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sk.isReadable() || sk.isWritable()) &#123;<br>                <span class="hljs-keyword">if</span> (socketWrapper.getSendfileData() != <span class="hljs-literal">null</span>) &#123;<br>                    processSendfile(sk, socketWrapper, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    unreg(sk, socketWrapper, sk.readyOps());<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">closeSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">//处理读事件</span><br>                    <span class="hljs-keyword">if</span> (sk.isReadable()) &#123;<br>                        <span class="hljs-comment">//代码忽略</span><br>                        <span class="hljs-comment">//处理读事件</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="hljs-literal">true</span>)) &#123;<br>                            closeSocket = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//处理读事件</span><br>                    <span class="hljs-keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;<br>                        <span class="hljs-comment">//代码忽略</span><br>                    <span class="hljs-comment">//处理写事件</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!processSocket(socketWrapper, SocketEvent.OPEN_WRITE, <span class="hljs-literal">true</span>)) &#123;<br>                            closeSocket = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (closeSocket) &#123;<span class="hljs-comment">//取消事件</span><br>                        cancelledKey(sk, socketWrapper);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Invalid key</span><br>            cancelledKey(sk, socketWrapper);<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ProcessSocket（）：</p><ul><li>获取ProcessSocket来处理请求；</li><li>将ProcessSocket放入线程池中执行；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractEndpoin.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processSocket</span><span class="hljs-params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="hljs-params">                             SocketEvent event, <span class="hljs-type">boolean</span> dispatch)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//代码忽略</span><br>        SocketProcessorBase&lt;S&gt; sc = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (processorCache != <span class="hljs-literal">null</span>) &#123;<br>            sc = processorCache.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sc == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//创建一个socketProcessor处理请求</span><br>            sc = createSocketProcessor(socketWrapper, event);<br>        &#125;<span class="hljs-comment">//代码忽略。。。。。</span><br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getExecutor();<br>        <span class="hljs-keyword">if</span> (dispatch &amp;&amp; executor != <span class="hljs-literal">null</span>) &#123;<br>            executor.execute(sc);<span class="hljs-comment">//放入线程池中执行</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sc.run();<br>        &#125;<br>    &#125; <span class="hljs-comment">//代码忽略。。。。。。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>SocketProcessor.doRun（）：</p><ul><li>线程池执行SocketProcessorBase的run（）方法，最终调用SocketProcessor的doRun（）方法；</li><li>doRun（）方法最终将请求交给handler去处理，最终调用的是Processor.process（）方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//NioEndpoint.SocketProcessor.class</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRun</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">NioChannel</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> socketWrapper.getSocket();<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> socket.getIOChannel().keyFor(socket.getSocketWrapper().getPoller().getSelector());<br>    <span class="hljs-type">Poller</span> <span class="hljs-variable">poller</span> <span class="hljs-operator">=</span> NioEndpoint.<span class="hljs-built_in">this</span>.poller;<br><span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">handshake</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//代码忽略........</span><br>        <span class="hljs-keyword">if</span> (handshake == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">SocketState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> SocketState.OPEN;<br>            <span class="hljs-comment">//请求交给handler处理，event为null，则为读请求</span><br>            <span class="hljs-keyword">if</span> (event == <span class="hljs-literal">null</span>) &#123;<br>                state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                state = getHandler().process(socketWrapper, event);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (state == SocketState.CLOSED) &#123;<br>                poller.cancelledKey(key, socketWrapper);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//代码忽略。。。。。。。</span><br>    &#125; <br>    <span class="hljs-comment">//代码忽略。。。。  </span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③Processor"><a href="#③Processor" class="headerlink" title="③Processor"></a>③Processor</h5><blockquote><ul><li><p>SocketProcessor中doRun（）方法中，调用了process（）方法处理请求；</p></li><li><p>AbstractProcessorLight.process()：最终调用service（）方法进行请求处理;</p></li><li><p>service（）：会生成request和response对象，最终调用Adapter.service（）将请求转发出去；</p><img src="/2022/04/07/Tomcat/11.jpg" class="" title="Tomcat"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractProtocol.class</span><br><span class="hljs-keyword">public</span> SocketState <span class="hljs-title function_">process</span><span class="hljs-params">(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status)</span> &#123;<br><span class="hljs-comment">//代码忽略</span><br><span class="hljs-keyword">if</span> (processor == <span class="hljs-literal">null</span>) &#123;<br>        processor = getProtocol().createProcessor();<br>        register(processor);<br>        <span class="hljs-keyword">if</span> (getLog().isDebugEnabled()) &#123;<br>            getLog().debug(sm.getString(<span class="hljs-string">&quot;abstractConnectionHandler.processorCreate&quot;</span>, processor));<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//代码忽略</span><br>      <span class="hljs-keyword">do</span> &#123;<br>        state = processor.process(wrapper, status);<span class="hljs-comment">//核心方法</span><br><span class="hljs-comment">//代码忽略</span><br>&#125;<br><span class="hljs-comment">//AbstractProcessorLight.class</span><br><span class="hljs-keyword">public</span> SocketState <span class="hljs-title function_">process</span><span class="hljs-params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span><span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SocketState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> SocketState.CLOSED;<br>    Iterator&lt;DispatchType&gt; dispatches = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (dispatches != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//代码忽略</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;<br>            <span class="hljs-comment">// Do nothing here, just wait for it to get recycled</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;<br>            state = dispatch(status);<br>            state = checkForPipelinedData(state, socketWrapper);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;<br>            state = SocketState.LONG;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == SocketEvent.OPEN_READ) &#123;<span class="hljs-comment">//处理读</span><br>            state = service(socketWrapper);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == SocketEvent.CONNECT_FAIL) &#123;<br>            logAccess(socketWrapper);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            state = SocketState.CLOSED;<br>        &#125;<br>    <span class="hljs-comment">//代码忽略</span><br>    &#125; <span class="hljs-keyword">while</span> (state == SocketState.ASYNC_END ||<br>             dispatches != <span class="hljs-literal">null</span> &amp;&amp; state != SocketState.CLOSED);<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="④Adapter"><a href="#④Adapter" class="headerlink" title="④Adapter"></a>④Adapter</h5><blockquote><ul><li>Adapter用于连接Connecto和Container，Processor会调用Adapter.service（）；</li><li>生成request和response对象，添加请求头；</li><li>postParseRequest(req, request, res, response)：解析请求，该方法会设置请求头等信息；</li><li>真正进入Container，调用pipeline中的方法；</li><li>最后执行finidhRequest（）和finishResponse刷新请求；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span><br><span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//生成connector的request和response请求</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (Request) req.getNote(ADAPTER_NOTES);<br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (Response) res.getNote(ADAPTER_NOTES);<br>    <span class="hljs-keyword">if</span> (request == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//设置request，代码忽略。。。。。。</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (connector.getXpoweredBy()) &#123;<span class="hljs-comment">//添加请求头</span><br>        response.addHeader(<span class="hljs-string">&quot;X-Powered-By&quot;</span>, POWERED_BY);<br>    &#125;<br><span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        postParseSuccess = postParseRequest(req, request, res, response);<br>        <span class="hljs-keyword">if</span> (postParseSuccess) &#123;<br>            request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());<br>            <span class="hljs-comment">// 进入容器COntianer</span><br>            connector.getService().getContainer().getPipeline().getFirst().invoke(<br>                request, response);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (request.isAsync()) &#123;<br>            <span class="hljs-comment">//代码忽略</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            request.finishRequest();<br>            response.finishResponse();<br>        &#125;<br>    <span class="hljs-comment">//代码忽略</span><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）Engin处理"><a href="#（2）Engin处理" class="headerlink" title="（2）Engin处理"></a>（2）Engin处理</h4><blockquote><ul><li><p>Adapter处理：</p></li><li><ul><li>Conncetor调用getService（）返回StandardService；</li><li>StandardService调用getContainer返回StandardEngine；</li><li>StandEngine调用getPipeline返回StandardPipeline；</li></ul></li><li><p>最终调用StandEngineValve的invoke（）方法，判断host不为空，调用HostPipeline第一个Valve；</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">connector.getService().getContainer().getPipeline().getFirst().invoke( request, response);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> request.getHost();<br>    <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//hostweinull直接返回</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (request.isAsyncSupported()) &#123;<br>        request.setAsyncSupported(host.getPipeline().isAsyncSupported());<br>    &#125;<br>    host.getPipeline().getFirst().invoke(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）Host处理"><a href="#（3）Host处理" class="headerlink" title="（3）Host处理"></a>（3）Host处理</h4><blockquote><ul><li>Host的pipeLine中一定存在ErrorReportValve和StandardHostVlve；</li><li>先执行ErrorReportValve，主要是检测Http中是否有异常；</li><li>后执行StandardHostValve，调用context的pipeline；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ErroReportValve.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-comment">// 调用下一个valve，即StandardHostValve</span><br>    getNext().invoke(request, response);<br>    <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>        <span class="hljs-comment">//正常提交，代码忽略。。。。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">throwable</span> <span class="hljs-operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);<br>    <span class="hljs-keyword">if</span> (request.isAsync() &amp;&amp; !request.isAsyncCompleting()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (throwable != <span class="hljs-literal">null</span> &amp;&amp; !response.isError()) &#123;<br>        response.reset();<br>        <span class="hljs-comment">//500异常</span><br>        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<br>    &#125;<br>    response.setSuspended(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        report(request, response, throwable);<span class="hljs-comment">//异常输出浏览器</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable tt) &#123;<br>        ExceptionUtils.handleThrowable(tt);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//StandardHostValve.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> request.getContext();<br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//代码忽略。。。。。</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);<br>        <span class="hljs-keyword">if</span> (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!response.isErrorReportRequired()) &#123;<br>                <span class="hljs-comment">//调用context</span><br>                context.getPipeline().getFirst().invoke(request, response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">//异常处理</span><br>        &#125;<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）Context处理"><a href="#（4）Context处理" class="headerlink" title="（4）Context处理"></a>（4）Context处理</h4><blockquote><p>通过执行StandardContextValve中的invoke方法，调用Wrapper的pipeline；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardContextValve</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-comment">// 禁止直接访问提下资源</span><br>    <span class="hljs-type">MessageBytes</span> <span class="hljs-variable">requestPathMB</span> <span class="hljs-operator">=</span> request.getRequestPathMB();<br>    <span class="hljs-keyword">if</span> ((requestPathMB.startsWithIgnoreCase(<span class="hljs-string">&quot;/META-INF/&quot;</span>, <span class="hljs-number">0</span>))<br>        || (requestPathMB.equalsIgnoreCase(<span class="hljs-string">&quot;/META-INF&quot;</span>))<br>        || (requestPathMB.startsWithIgnoreCase(<span class="hljs-string">&quot;/WEB-INF/&quot;</span>, <span class="hljs-number">0</span>))<br>        || (requestPathMB.equalsIgnoreCase(<span class="hljs-string">&quot;/WEB-INF&quot;</span>))) &#123;<br>        response.sendError(HttpServletResponse.SC_NOT_FOUND);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> request.getWrapper();<br>    <span class="hljs-keyword">if</span> (wrapper == <span class="hljs-literal">null</span> || wrapper.isUnavailable()) &#123;<br>        response.sendError(HttpServletResponse.SC_NOT_FOUND);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//代码忽略</span><br>    wrapper.getPipeline().getFirst().invoke(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）Wrapper处理"><a href="#（5）Wrapper处理" class="headerlink" title="（5）Wrapper处理"></a>（5）Wrapper处理</h4><blockquote><ul><li><p>Wrapper对应一个Servlet，是对Servlet的包装，主要执行StandardWrapperValve的invoke（）方法；</p></li><li><p>invoke主要执行如下逻辑：</p><ul><li>调用Wrapper的allocate分配一个Servlet；</li></ul><img src="/2022/04/07/Tomcat/12.jpg" class="" title="Tomcat"></li><li><p>​创建过滤器链；</p></li></ul><p>​<img src="/2022/04/07/Tomcat/13.jpg" class="" title="Tomcat"></p><ul><li>​调用过滤器链的doFilter方法；</li></ul><p>​<img src="/2022/04/07/Tomcat/14.jpg" class="" title="Tomcat"></p><ul><li>​释放资源，如过滤器链，Servlet相关资源；</li></ul></blockquote><h5 id="①allocate分配Servlet"><a href="#①allocate分配Servlet" class="headerlink" title="①allocate分配Servlet"></a>①allocate分配Servlet</h5><blockquote><ul><li>如果不为单线程模型，每次返回同一个Servlet，使用道单例设计模式；</li><li>为单线程模型，会采用Servlet池化技术，复用Servlet，避免频繁创建销毁；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandWrapper.class</span><br><span class="hljs-keyword">public</span> Servlet <span class="hljs-title function_">allocate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-keyword">if</span> (unloading) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(sm.getString(<span class="hljs-string">&quot;standardWrapper.unloading&quot;</span>, getName()));<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!singleThreadModel) &#123;<span class="hljs-comment">//每次返回一个相同的Servlet实例</span><br>        <span class="hljs-comment">// Load and initialize our instance if necessary</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span> || !instanceInitialized) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>                            log.debug(<span class="hljs-string">&quot;Allocating non-STM instance&quot;</span>);<br>                        &#125;<br>                        instance = loadServlet();<span class="hljs-comment">//加载Servlet</span><br>                        newInstance = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> (!singleThreadModel) &#123;<br>                            countAllocated.incrementAndGet();<br>                        &#125;<br>                    &#125; <br>                    <span class="hljs-comment">//代码忽略。。。。</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (!instanceInitialized) &#123;<br>                    initServlet(instance);<span class="hljs-comment">//初始化Servlet</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (singleThreadModel) &#123;<br>            <span class="hljs-keyword">if</span> (newInstance) &#123;<br>                <span class="hljs-keyword">synchronized</span> (instancePool) &#123;<br>                    instancePool.push(instance);<br>                    nInstances++;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//非单线程模型，返回一个相同的Servlet</span><br>           <span class="hljs-comment">//代码忽略</span><br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//单线程模式，用Servlet对象池加载</span><br>    <span class="hljs-keyword">synchronized</span> (instancePool) &#123;<br>        <span class="hljs-keyword">while</span> (countAllocated.get() &gt;= nInstances) &#123;<br>            <span class="hljs-comment">// Allocate a new instance if possible, or else wait</span><br>            <span class="hljs-keyword">if</span> (nInstances &lt; maxInstances) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    instancePool.push(loadServlet());<br>                    nInstances++;<br>                &#125;<br>                <span class="hljs-comment">//忽略代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>loadServlet（）：</strong></p><ul><li>通过实例对戏管理器，创建Servlet，实例管理器通过特定类加载加载器加载；</li><li>initServlet（）：调用Servlet的init（）方法（我们实现Servlet接口的init方法在此调用）；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//StandardWrapperValve.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Servlet <span class="hljs-title function_">loadServlet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><span class="hljs-comment">//代码忽略</span><br>    Servlet servlet;<br>    <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-comment">//创建Servlet</span><br>        <span class="hljs-type">InstanceManager</span> <span class="hljs-variable">instanceManager</span> <span class="hljs-operator">=</span> ((StandardContext)getParent()).getInstanceManager();<br>        <span class="hljs-keyword">try</span> &#123;<br>            servlet = (Servlet) instanceManager.newInstance(servletClass);<br>        &#125; <br>        <span class="hljs-comment">//代码忽略。。。</span><br><br>        initServlet(servlet);<span class="hljs-comment">//初始化Servlet</span><br>        fireContainerEvent(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-built_in">this</span>);<br>        loadTime=System.currentTimeMillis() -t1;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-comment">//代码忽略</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> servlet;<br> &#125;<br></code></pre></td></tr></table></figure><h5 id="②创建过滤器链createFilterChain"><a href="#②创建过滤器链createFilterChain" class="headerlink" title="②创建过滤器链createFilterChain"></a>②创建过滤器链createFilterChain</h5><blockquote><ul><li>过滤器链会放入Request缓存中，避免重复生成过滤器链；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ApplicationFilterChain.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationFilterChain <span class="hljs-title function_">createFilterChain</span><span class="hljs-params">(ServletRequest request,</span><br><span class="hljs-params">    <span class="hljs-keyword">if</span> (servlet == <span class="hljs-literal">null</span>)</span>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ApplicationFilterChain</span> <span class="hljs-variable">filterChain</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//过滤器链</span><br>    <span class="hljs-keyword">if</span> (request <span class="hljs-keyword">instanceof</span> Request) &#123;<span class="hljs-comment">//Request缓存中找</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (Request) request;<br>        <span class="hljs-keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;<br>            filterChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterChain</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            filterChain = (ApplicationFilterChain) req.getFilterChain();<br>            <span class="hljs-keyword">if</span> (filterChain == <span class="hljs-literal">null</span>) &#123;<br>                filterChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterChain</span>();<br>                req.setFilterChain(filterChain);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        filterChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterChain</span>();<br>    &#125;<br>    filterChain.setServlet(servlet);<br>    filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (StandardContext) wrapper.getParent();<br>    FilterMap filterMaps[] = context.findFilterMaps();<span class="hljs-comment">//过滤器链对象</span><br>    <span class="hljs-comment">//代码忽略。。。。。</span><br><span class="hljs-comment">//类型与路径匹配情况下，将filterConfig放入到过滤器链中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; filterMaps.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!matchFiltersURL(filterMaps[i], requestPath))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig)<br>                                                context.findFilterConfig(filterMaps[i].getFilterName());<br>        <span class="hljs-keyword">if</span> (filterConfig == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// FIXME - log configuration problem</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        filterChain.addFilter(filterConfig);<br>    &#125;<br><span class="hljs-comment">//servlet与类型匹配下，将Filter放入过滤器链</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; filterMaps.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!matchFiltersServlet(filterMaps[i], servletName))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig)<br>                                                context.findFilterConfig(filterMaps[i].getFilterName());<br>        <span class="hljs-keyword">if</span> (filterConfig == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        filterChain.addFilter(filterConfig);<br>    &#125;<br>    <span class="hljs-keyword">return</span> filterChain;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③调用过滤器链doFilter方法"><a href="#③调用过滤器链doFilter方法" class="headerlink" title="③调用过滤器链doFilter方法"></a>③调用过滤器链doFilter方法</h5><blockquote><ul><li><p>filter.doFilter(request, response, this)：</p></li><li><ul><li>通过pos和n来控制过滤器遍历，pos为当前访问过滤器下标，n为总过滤器数；</li><li>doFilter会将this传入（filterChain），我们在实现自定义filter时，会重写doFilter（）方法，doFilter里面会有业务逻辑，执行后调用filterChain.doFilter（）方法，继续执行下一个过滤器；</li><li>当某个过滤器不匹配时，我们通过return，不执行filterChain.doFilter（），从而不执行后面的过滤器以及service方法；</li></ul></li><li><p>servlet.service(request, response)：所有过滤器执行完后，会执行我们Servlet的service（）方法，即我们的业务逻辑；</p></li><li><p>整体执行流程如下：</p><img src="/2022/04/07/Tomcat/15.jpg" class="" title="Tomcat"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ApplicationFilterChain.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> request;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ServletResponse</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> response;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.security.AccessController.doPrivileged( <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>                        internalDoFilter(req,res);<span class="hljs-comment">//执行该方法</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;<br>            );<br>        &#125;<br>        <span class="hljs-comment">//代码忽略</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        internalDoFilter(request,response);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//ApplicationFilterChain.class</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internalDoFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-keyword">if</span> (pos &lt; n) &#123;<br>        <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> filters[pos++];<span class="hljs-comment">//获取过滤器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> filterConfig.getFilter();<br>        <span class="hljs-comment">//代码忽略</span><br>            <span class="hljs-keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;<br>            <span class="hljs-comment">//代码忽略</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                filter.doFilter(request, response, <span class="hljs-built_in">this</span>);<span class="hljs-comment">//执行所有过滤器doFilter</span><br>            &#125;<br>        &#125; <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//代码忽略</span><br>        <span class="hljs-keyword">if</span> ((request <span class="hljs-keyword">instanceof</span> HttpServletRequest) &amp;&amp;<br>            (response <span class="hljs-keyword">instanceof</span> HttpServletResponse) &amp;&amp;<br>            Globals.IS_SECURITY_ENABLED ) &#123;<br>          <span class="hljs-comment">//代码忽略</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            servlet.service(request, response);<span class="hljs-comment">//调用service方法</span><br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">//代码忽略</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2022/01/05/SpringBoot/"/>
    <url>/2022/01/05/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h3 id="1、-SpringBootApplication注解"><a href="#1、-SpringBootApplication注解" class="headerlink" title="1、@SpringBootApplication注解"></a>1、@SpringBootApplication注解</h3><blockquote><ul><li>SpringBoot核心类，标注在类上，表示该类为SpringBoot的配置类；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><span class="hljs-comment">//表示这是一个springBoot配置类</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-comment">//开启自动配置</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">                                 @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="（1）-EnableAutoConfiguration"><a href="#（1）-EnableAutoConfiguration" class="headerlink" title="（1）@EnableAutoConfiguration"></a>（1）@EnableAutoConfiguration</h4><blockquote><ul><li>通知SpringBoot开启自动配置功能；</li><li>之前Spring中需要的配置，由SpringBoot帮忙配置；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>AutoConfigurationImportSelector：</p><ul><li>将所需要的组件通过全类名返回，注册到IOC容器中；</li><li>SpringBoot启动时，从类路径下的META-INF&#x2F;spring.factories中获取自动配置类，将这些配置类加入IOC容器，通过注解@ConditionalOnClass判断是否导入相应的依赖包，从而通过@Bean进行自动配置；</li><li>追踪路径（同一个类下）：slectImports（）–getAutoConfigurationEntry（）–getCandidateConfigurations（）–loadFactoryNames（）–loadSpringFactories（）</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-comment">//代码忽略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-literal">null</span> ?<br>                <span class="hljs-comment">//加载WETA-INF/spring.factories下资源</span><br>                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>   <span class="hljs-comment">//代码忽略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）-AutoConfigurationPackage"><a href="#（2）-AutoConfigurationPackage" class="headerlink" title="（2）@AutoConfigurationPackage"></a>（2）@AutoConfigurationPackage</h4><blockquote><ul><li>@Import(AutoConfigurationPackages.Registrar.class)：默认将SpringbootApplication注解所标注的类所在的包以及子包扫描到Spring的IOC容器中；</li><li>通过调用registerBeanDefination（）方法，将bean注册到IOC容器中；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="2、SpringBoot启动分析（run方法）"><a href="#2、SpringBoot启动分析（run方法）" class="headerlink" title="2、SpringBoot启动分析（run方法）"></a>2、SpringBoot启动分析（run方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(primarySources).run(args);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（1）构造一个SpringApplication实例（初始化）"><a href="#（1）构造一个SpringApplication实例（初始化）" class="headerlink" title="（1）构造一个SpringApplication实例（初始化）"></a>（1）构造一个SpringApplication实例（初始化）</h4><blockquote><ul><li>将启动类放入primarySources中；</li><li>调用deduceFromClassPath（）方法，设置应用类型，Web环境下会设置为SERVLET类型（有DIspacthServlet类）；</li><li>setInitalizers（）方法：将在META-INF&#x2F;spring.factories下的所有配置类创建实例，添加到list集合中；</li><li>setListeners（）方法：初始化监听器，将在META-INF&#x2F;spring.factories下的所有ApplicationListener类创建实例，并放入listeners集合中</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.primarySources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));<br>    <span class="hljs-comment">//设置应用类型</span><br>    <span class="hljs-built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-comment">//初始化所有自动配置类，放入list集合中</span><br>    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>getSpringFactoriesInstances(Class<T> type)方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="hljs-title function_">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>    <span class="hljs-keyword">return</span> getSpringFactoriesInstances(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;&#125;);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="hljs-title function_">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> getClassLoader();<br>    <span class="hljs-comment">//loadFactoryNames（）方法：获取WETA-INF/spring.factories下所有配置类的全类名</span><br>    Set&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>    <span class="hljs-comment">//创建配置类的实例</span><br>    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>    AnnotationAwareOrderComparator.sort(instances);<span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）调用run（）方法"><a href="#（2）调用run（）方法" class="headerlink" title="（2）调用run（）方法"></a>（2）调用run（）方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>    <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>    stopWatch.start();<br>    <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    configureHeadlessProperty();<br>    <span class="hljs-comment">//1.获取并启动监听器</span><br>    <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>    listeners.starting();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>        <span class="hljs-comment">//2.环境准备</span><br>        <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners, applicationArguments);<br>        configureIgnoreBeanInfo(environment);<br>        <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<span class="hljs-comment">//启动时在console打印的内容</span><br>        <span class="hljs-comment">//3.创建spring容器</span><br>        context = createApplicationContext();<br>        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);<br>        <span class="hljs-comment">//4.spring前置处理器</span><br>        prepareContext(context, environment, listeners, applicationArguments, printedBanner);<br>        <span class="hljs-comment">//5.刷新spring容器</span><br>        refreshContext(context);<br>        <span class="hljs-comment">//6.spring后置处理器</span><br>        afterRefresh(context, applicationArguments);<br>        <span class="hljs-comment">//7.发出结束执行事件</span><br>        stopWatch.stop();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>        &#125;<br>        listeners.started(context);<br>        <span class="hljs-comment">//8.执行runner</span><br>        callRunners(context, applicationArguments);<br>    &#125;<br>    <span class="hljs-comment">//异常处理代码忽略。。。</span><br>    <span class="hljs-comment">///返回容器</span><br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="①获取并启动监听器"><a href="#①获取并启动监听器" class="headerlink" title="①获取并启动监听器"></a>①获取并启动监听器</h5><blockquote><ul><li>getSpringFactoriesInstances（）方法，到META-INF&#x2F;spring.factories中获取类型为SpringApplicationRunListener.class的实例集合；</li></ul><img src="/2022/01/05/SpringBoot/1.jpg" class="" title="SpringBoot"><ul><li>EventPublishingRunLIstener类的构造方法中，会将之前添加的监听器全部添加到SimpleApplicationEventMulticaster中；</li><li>starting（）方法启动监听器；SpringBoot会在执行阶段，发送不同的事件，来执行监听器对应的方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SpringApplicationRunListeners <span class="hljs-title function_">getRunListeners</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationRunListeners</span>(logger,<br>     getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="hljs-built_in">this</span>, args));<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">starting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (SpringApplicationRunListener listener : <span class="hljs-built_in">this</span>.listeners) &#123;<br>        listener.starting();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②环境构建"><a href="#②环境构建" class="headerlink" title="②环境构建"></a>②环境构建</h5><blockquote><ul><li>前面初始化时，尾部应用为SERVLET类型，创建StandardServletEnvironment类；</li><li>监听事件发布，ConfigurationApplicationLInstencer监听器主要负责加载项目中的yml或properties文件；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ConfigurableEnvironment <span class="hljs-title function_">prepareEnvironment</span><span class="hljs-params">(SpringApplicationRunListeners listeners,</span><br><span class="hljs-params">                                                   ApplicationArguments applicationArguments)</span> &#123;<br>    <span class="hljs-comment">//为Servlet类型，创建StandardServletEnvironment</span><br>    <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> getOrCreateEnvironment();<br>    configureEnvironment(environment, applicationArguments.getSourceArgs());<br>    ConfigurationPropertySources.attach(environment);<br>    <span class="hljs-comment">//监听事件发布</span><br>    listeners.environmentPrepared(environment);<br>    bindToSpringApplication(environment);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isCustomEnvironment) &#123;<br>        environment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,<br>                                                                                               deduceEnvironmentClass());<br>    &#125;<br>    ConfigurationPropertySources.attach(environment);<br>    <span class="hljs-keyword">return</span> environment;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>ConfigurationApplicationListencer类：</strong></p><ul><li><p>loadPostProcessors（）方法：到META-INF&#x2F;spring.factories中加载EnvironmentPostProcessor类型的类；</p><img src="/2022/01/05/SpringBoot/2.jpg" class="" title="SpringBoot"></li><li><p>postProcessEnvironment（）：执行完上述四个监听器的该方法后，会调用类本身逻辑，从META-INF&#x2F;spring.factories下加载yml和properties资源解析器，从而加载项目路径解析配置；</p><img src="/2022/01/05/SpringBoot/3.jpg" class="" title="SpringBoot"></li><li><p>默认加载配置路径</p><img src="/2022/01/05/SpringBoot/4.jpg" class="" title="SpringBoot"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEnvironmentPreparedEvent</span><span class="hljs-params">(ApplicationEnvironmentPreparedEvent event)</span> &#123;<br>    List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();<br>    postProcessors.add(<span class="hljs-built_in">this</span>);<br>    AnnotationAwareOrderComparator.sort(postProcessors);<br>    <span class="hljs-keyword">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;<br>        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③创建容器"><a href="#③创建容器" class="headerlink" title="③创建容器"></a>③创建容器</h5><blockquote><p>前面初始化时，设置了类型为SERVLET，通过反射创建容器实例，创建容器类型为：</p><img src="/2022/01/05/SpringBoot/5.jpg" class="" title="SpringBoot"></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title function_">createApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    Class&lt;?&gt; contextClass = <span class="hljs-built_in">this</span>.applicationContextClass;<br>    <span class="hljs-keyword">if</span> (contextClass == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.webApplicationType) &#123;<br>                <span class="hljs-keyword">case</span> SERVLET:<br>                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> REACTIVE:<br>                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//忽略代码</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="④Spring容器前置处理"><a href="#④Spring容器前置处理" class="headerlink" title="④Spring容器前置处理"></a>④Spring容器前置处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span><br><span class="hljs-params">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;<br>    context.setEnvironment(environment);<span class="hljs-comment">//设置环境</span><br>    postProcessApplicationContext(context);<span class="hljs-comment">//执行容器后置处理器</span><br>    applyInitializers(context);<span class="hljs-comment">//执行容器中的ApplicationInitializer</span><br>    listeners.contextPrepared(context);<span class="hljs-comment">//发布容器准备好事件</span><br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>    <span class="hljs-comment">//注册启动参数bean</span><br>    <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> context.getBeanFactory();<br>    beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-literal">null</span>) &#123;<br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>    &#125;<br>    <span class="hljs-comment">//代码忽略。。。。。。</span><br>    Set&lt;Object&gt; sources = getAllSources();<span class="hljs-comment">//获取启动类指定参数</span><br>    Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>    load(context, sources.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]));<span class="hljs-comment">//加载启动类，将启动类注册到bean容器中</span><br>    listeners.contextLoaded(context);<span class="hljs-comment">//发布加载完毕事件</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>applyInitalizers（）方法：</strong>执行以下所有类中的initialize（）方法；</p><p><strong>项目初始化</strong>：我们也可以自定义初始化类,实现接口ApplicationContextInitializer，该类实现initalize（）方法，将其放入META-INF&#x2F;spring.factories中key为org.springframework.context.ApplicationContextInitializer的value中；</p><img src="/2022/01/05/SpringBoot/6.jpg" class="" title="SpringBoot"></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>    <span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;<br>        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),<br>                                                                        ApplicationContextInitializer.class);<br>        Assert.isInstanceOf(requiredType, context, <span class="hljs-string">&quot;Unable to call initializer.&quot;</span>);<br>        initializer.initialize(context);<span class="hljs-comment">//执行初始化逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>将启动类加载如BeanDefiniationMap中：</strong>启动类将作为自动配置的入口；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;?&gt; source)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;<br>        <span class="hljs-comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span><br>        <span class="hljs-type">GroovyBeanDefinitionSource</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);<br>        load(loader);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isComponent(source)) &#123;<br>        <span class="hljs-built_in">this</span>.annotatedReader.register(source);<span class="hljs-comment">//启动类加载进行map中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑤刷新容器"><a href="#⑤刷新容器" class="headerlink" title="⑤刷新容器"></a>⑤刷新容器</h5><blockquote><p>最终会调用refresh（）方法，该方法是实现IOC和AOP的核心；</p><p><a href="https://swttws.github.io/2021/09/18/Spring/">可以参考该文章</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshContext</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>    refresh(context);<span class="hljs-comment">//容器刷新</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registerShutdownHook) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            context.registerShutdownHook();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (AccessControlException ex) &#123;<br>            <span class="hljs-comment">// Not allowed in some environments.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="⑥Spring容器后置处理器"><a href="#⑥Spring容器后置处理器" class="headerlink" title="⑥Spring容器后置处理器"></a>⑥Spring容器后置处理器</h5><blockquote><p>后置处理器为空方法，可以自定义自己的需求；</p></blockquote><h5 id="⑦执行Runner类的run方法"><a href="#⑦执行Runner类的run方法" class="headerlink" title="⑦执行Runner类的run方法"></a>⑦执行Runner类的run方法</h5><blockquote><ul><li>分为ApplicaitionRunner接口和CommandLineRunner接口；</li><li>SpringBoot启动后，会从IOC容器中获取所有Runners类，并执行run（）方法；</li><li>我们可以通过实现ApplicaitionRunne接口或CommandLineRunner接口，run（）方法写上我们的逻辑，在SpringBoot启动完后会执行所有runners的run方法（自定义类必须为IOC容器中的Bean）</li></ul></blockquote><h3 id="3、SpringBoot启动时数据初始化"><a href="#3、SpringBoot启动时数据初始化" class="headerlink" title="3、SpringBoot启动时数据初始化"></a>3、SpringBoot启动时数据初始化</h3><h4 id="（1）ApplicationRunner和CommandLineRunner"><a href="#（1）ApplicationRunner和CommandLineRunner" class="headerlink" title="（1）ApplicationRunner和CommandLineRunner"></a>（1）ApplicationRunner和CommandLineRunner</h4><blockquote><ul><li>两个接口中仅有一个run方法，所有实现这两个接口的类，会在SpringBootd的run（）方法结束前调用；</li><li>自定义的类需要实现该接口，实现run（）方法逻辑，同时必须是IOC容器中的Bean，否则不会执行；</li><li>可以通过@Order注解来实现调用顺序，@Order注解的值越小，优先级越高；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">//自定义类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterStart1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;容器启动后&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> &#123;<br>    List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//从IOC容器中获取Bean</span><br>    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());<br>    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());<br>    AnnotationAwareOrderComparator.sort(runners);<br>    <span class="hljs-keyword">for</span> (Object runner : <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;<br>        <span class="hljs-comment">//调用run方法，代码忽略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）InitializingBean"><a href="#（2）InitializingBean" class="headerlink" title="（2）InitializingBean"></a>（2）InitializingBean</h4><blockquote><ul><li>自定义类实现InitializingBean接口，afterPropertiesSet（）方法实现业务逻辑；</li><li>SpringBoot会在对象左右属性初始化后，调用该类的afterPropertiesSet（）方法；</li><li>调用该类在实现ApplicationRunner或CommandLine接口之前；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethods</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span><br><span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">//判断是否实现InitializingBean接口</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializingBean</span> <span class="hljs-operator">=</span> (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br>    <span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;<br>                    ((InitializingBean) bean).afterPropertiesSet();<span class="hljs-comment">//调用afterPropertiesSet方法</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-comment">//代码忽略</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ((InitializingBean) bean).afterPropertiesSet();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//代码忽略。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）-PostCostruct"><a href="#（3）-PostCostruct" class="headerlink" title="（3）@PostCostruct"></a>（3）@PostCostruct</h4><blockquote><ul><li>自定义类为IOC容器中的Bean，在方法上添加@PostConstruct注解；</li><li>该注解的方法调用，会在initializeBean（）方法中的applyBeanPostProcessorsBeforeInitialization（）方法中调用；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br><span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">//调用后置处理器InitDestroyAnnotationBeanPostProcessor，添加@POstConstruct注解方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">LifecycleMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> findLifecycleMetadata(bean.getClass());<br>    <span class="hljs-comment">//代码忽略。。。。。。</span><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">private</span> LifecycleMetadata <span class="hljs-title function_">buildLifecycleMetadata</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;<br>            <span class="hljs-comment">//判断是否有注解@PostConstruct</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.initAnnotationType != <span class="hljs-literal">null</span> &amp;&amp; method.isAnnotationPresent(<span class="hljs-built_in">this</span>.initAnnotationType)) &#123;<br>                <span class="hljs-type">LifecycleElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleElement</span>(method);<br>                currInitMethods.add(element);<br>                <span class="hljs-comment">//代码忽略。。。。</span><br>            &#125;<br>            <span class="hljs-comment">//代码忽略</span><br>        &#125;);<br>initMethods.addAll(<span class="hljs-number">0</span>, currInitMethods);<br>        destroyMethods.addAll(currDestroyMethods);<br>        targetClass = targetClass.getSuperclass();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (targetClass != <span class="hljs-literal">null</span> &amp;&amp; targetClass != Object.class);<br>    <span class="hljs-keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="hljs-built_in">this</span>.emptyLifecycleMetadata :<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleMetadata</span>(clazz, initMethods, destroyMethods));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、SpringBoot事务源码"><a href="#4、SpringBoot事务源码" class="headerlink" title="4、SpringBoot事务源码"></a>4、SpringBoot事务源码</h3><h4 id="（1）DataSourceTransactionManagerAutoConfiguration"><a href="#（1）DataSourceTransactionManagerAutoConfiguration" class="headerlink" title="（1）DataSourceTransactionManagerAutoConfiguration"></a>（1）DataSourceTransactionManagerAutoConfiguration</h4><blockquote><ul><li>SpringBoot配置了事务自动配置类DataSourceTransactionManagerAutoConfiguration；</li><li>在类路径下存在JdbcTemplate.class, PlatformTransactionManager.class，该配置类才会生效；</li></ul><img src="/2022/01/05/SpringBoot/7.jpg" class="" title="SpringBoot"><ul><li>当我们自定义DataSourceTransactionManager时，下面代码不会执行；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; JdbcTemplate.class, PlatformTransactionManager.class &#125;)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)</span><br><span class="hljs-meta">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceTransactionManagerAutoConfiguration</span> &#123;<br>    <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceTransactionManagerConfiguration</span> &#123;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean(PlatformTransactionManager.class)</span><br>        DataSourceTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource,</span><br><span class="hljs-params">                                                        ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers)</span> &#123;<br>            <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">transactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>            transactionManagerCustomizers.ifAvailable((customizers) -&gt; customizers.customize(transactionManager));<br>            <span class="hljs-keyword">return</span> transactionManager;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）TransactionAutoConfiguration"><a href="#（2）TransactionAutoConfiguration" class="headerlink" title="（2）TransactionAutoConfiguration"></a>（2）TransactionAutoConfiguration</h4><blockquote><ul><li>在DataSourceTransactionManagerAutoConfiguration之后才能生效；</li><li>引入spring-boot-starter-jdbc这个启动器后，SpringBoot会自动配置事务，我们只需要在需要事务的方法上加@Transactional注解即可；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(PlatformTransactionManager.class)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123; JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class,</span><br><span class="hljs-meta">                     DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class &#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(TransactionProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionAutoConfiguration</span> &#123;<br>    <span class="hljs-comment">//忽略代码</span><br><br>    <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>    <span class="hljs-meta">@ConditionalOnBean(TransactionManager.class)</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnableTransactionManagementConfiguration</span> &#123;<br><br>        <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>        <span class="hljs-meta">@EnableTransactionManagement(proxyTargetClass = false)</span><br>        <span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,</span><br><span class="hljs-meta">                               matchIfMissing = false)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDynamicAutoProxyConfiguration</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>        <span class="hljs-meta">@EnableTransactionManagement(proxyTargetClass = true)</span><br>        <span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span><br><span class="hljs-meta">                               matchIfMissing = true)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibAutoProxyConfiguration</span> &#123;<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2021/09/18/Spring/"/>
    <url>/2021/09/18/Spring/</url>
    
    <content type="html"><![CDATA[<h3 id="1、IOC"><a href="#1、IOC" class="headerlink" title="1、IOC"></a>1、IOC</h3><h4 id="（1）控制反转"><a href="#（1）控制反转" class="headerlink" title="（1）控制反转"></a>（1）控制反转</h4><blockquote><ul><li><p>传统的业务开发中，A对象需要B对象，是由A对象去new创建B对象，并管理者B对象的生命周期；</p></li><li><p>使用IOC后，对象的管理权交给ioc，A对象需要B对象时，直接从IOC容器中注入B对象到A中，A无需知道B对象是怎么创建的，也不用管理B对象的生命周期；</p><img src="/2021/09/18/Spring/1.jpg" class="" title="spring"></li></ul></blockquote><h4 id="（2）IOC优点"><a href="#（2）IOC优点" class="headerlink" title="（2）IOC优点"></a>（2）IOC优点</h4><blockquote><ul><li><p>降低对象之间的依赖程度；</p></li><li><p>可以很好实现单例bean；</p></li><li><p>在传统开发中，UserServiceImpl中，需要应用UserDao实现类，需要new一个实现类UserDaoImpl，当dao实现类需要修改为另外一个时，service中依赖该dao的new代码，都需要修改（如果由100个service类依赖该dao，就要修改100次），代码耦合度过高；</p><img src="/2021/09/18/Spring/2.jpg" class="" title="spring"></li></ul></blockquote><blockquote><ul><li>对象交给SpringIOC控制后，代码的依赖性大大降低，在修改dao实现类时，由于dao对象已经交由ioc容器管理，service层代码不需要修改任何代码，直接和IOC容器要即可；</li></ul><img src="/2021/09/18/Spring/3.jpg" class="" title="spring"></blockquote><h3 id="2、AOP"><a href="#2、AOP" class="headerlink" title="2、AOP"></a>2、AOP</h3><blockquote><ol><li>SpringAOP是依赖于动态代理模式实现的，有使用接口则是JDK动态代理，没有使用接口的则是CGLib代理；</li><li>SpringAOP依赖于IOC容器来管理；</li><li>他只能作用于容器中的Bean；</li></ol></blockquote><h4 id="（1）AOP解决的问题"><a href="#（1）AOP解决的问题" class="headerlink" title="（1）AOP解决的问题"></a>（1）AOP解决的问题</h4><blockquote><ul><li><p>在OOP编程中，可以解决大部分纵向垂直代码的重复问题，但无法解决父类多个方法中，同一个位置出现重复代码的问题；</p></li><li><p>如下实例，Student类和Teacher类继承Person类，可以自动获得父类Person中的方法，这样可以减少重复代码的出现；但是Person多个方法中出现多个同样逻辑，oop无法解决代码重复问题</p><img src="/2021/09/18/Spring/4.jpg" class="" title="spring"><img src="/2021/09/18/Spring/5.jpg" class="" title="spring"></li></ul></blockquote><blockquote><ul><li><p>AOP将与业务无关的代码，与业务代码分离出来。在不改变原有业务逻辑的情况下，将增强逻辑代码织入到业务代码中，从而减少大量重复代码；</p><img src="/2021/09/18/Spring/6.jpg" class="" title="spring"></li></ul></blockquote><h4 id="（2）AOP术语"><a href="#（2）AOP术语" class="headerlink" title="（2）AOP术语"></a>（2）AOP术语</h4><blockquote><ul><li>@Aspect：使用该注解的bean会被当作用于实现AOP的配置类；</li><li>@Pointcut：指定那些方法需要被增强或拦截；</li><li><ul><li>within：指定某个类或包下方法，如@Pointcut（”within（com.service.impl.*）”）</li><li>annotation：方法上具有特定注解，标识需要被增强，如：@Pointcut（”@annotation(注解名)”）</li><li>bean：匹配bean的名字，@Pointcut（”bean（beanName）”）</li></ul></li><li>JoinPoint：获取原业务逻辑方法参数，对于@Around注解，使用的是子类ProceedingJoinPoint，他有proceed方法（用于执行原业务逻辑）。</li><li>Advice：增强的逻辑代码，即拦截连接点后需要做的事；</li><li>Aspect（切面）：拦截点（JoinPoint）+通知（Advice）</li></ul></blockquote><h4 id="（3）AOP拦截链（示例）"><a href="#（3）AOP拦截链（示例）" class="headerlink" title="（3）AOP拦截链（示例）"></a>（3）AOP拦截链（示例）</h4><blockquote><ul><li><p>MethodInvocation接口：封装被代理方法的相关信息，包括方法参数、方法本身，被代理对象等；</p></li><li><p>MethodInterceptor接口：作为拦截器的实现接口，里面有invoke方法（拦截器执行增强逻辑）；</p></li><li><p>AopInterceptorChain：拦截器链，addInterceptor实现添加拦截器，，executeChain方法依次执行拦截器链中的拦截器；</p></li><li><p>InvocationWrapper：拦截器链的递归调用，proceed方法执行目标方法；</p><img src="/2021/09/18/Spring/7.jpg" class="" title="spring"><img src="/2021/09/18/Spring/8.jpg" class="" title="spring"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//封装被代理类信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInvocation</span> &#123;<br>    Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable;<br>    Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span>;<br>    Object[] getArgs();<br>    Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br><br><br><span class="hljs-comment">//封装拦截链和MethodInvocation</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvocationWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInvocation</span>&#123;<br><br>    <span class="hljs-keyword">private</span> AopInterceptorChain chain;<br>    <span class="hljs-keyword">private</span> MethodInvocation invocation;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InvocationWrapper</span><span class="hljs-params">(AopInterceptorChain chain,MethodInvocation invocation)</span>&#123;<br>        <span class="hljs-built_in">this</span>.chain=chain;<br>        <span class="hljs-built_in">this</span>.invocation=invocation;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//递归调用拦截器</span><br>        <span class="hljs-keyword">return</span> chain.executeChain(invocation);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> invocation.getMethod();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] getArgs() &#123;<br>        <span class="hljs-keyword">return</span> invocation.getArgs();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> invocation.getThis();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//拦截链</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopInterceptorChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;MethodInterceptor&gt; chain=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">(MethodInterceptor interceptor)</span>&#123;<br>        chain.add(interceptor);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">executeChain</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (chain.isEmpty())&#123;<br>            <span class="hljs-comment">//执行业务逻辑</span><br>            <span class="hljs-keyword">return</span> invocation.proceed();<br>        &#125;<br>        <span class="hljs-comment">//获取代理链</span><br>        <span class="hljs-type">MethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> chain.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//执行拦截器逻辑，并将拦截链和invocation封装到  InvocationWrapper</span><br>        <span class="hljs-keyword">return</span> interceptor.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationWrapper</span>(<span class="hljs-built_in">this</span>,invocation));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟日志拦截器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;日志打印前记录时间&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;日志打印后，记录时间&quot;</span>);<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//也无代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;日志打印&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AopInterceptorChain</span> <span class="hljs-variable">aopInterceptorChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInterceptorChain</span>();<br>        <span class="hljs-comment">//添加拦截器</span><br>        aopInterceptorChain.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>());<br>        aopInterceptorChain.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>());<br><br>        UserService userService=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        MethodInvocation methodInvocation=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInvocation</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                userService.log();<span class="hljs-comment">//执行真正的业务逻辑</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> MethodUtils.getAccessibleMethod(UserService.class,<span class="hljs-string">&quot;log&quot;</span>,<br>                                                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object[] getArgs() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//开始执行拦截链方法</span><br>            aopInterceptorChain.executeChain(methodInvocation);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            throwable.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、DI"><a href="#3、DI" class="headerlink" title="3、DI"></a>3、DI</h3><blockquote><ol><li>组件之间的依赖关系由容器运行期决定的，即由容器动态的将某个依赖对应关系注入到组件中；通过依赖注入，我们只需通过简单的配置文件，而无需代码就可以指定目标需要的资源，完成自身逻辑，不需要关心具体的资源来自何处；</li><li>谁依赖谁：应用程序依赖于ioc容器；</li><li>为什么需要依赖：应用程序需要ioc容器来提供对象需要的外部资源；</li><li>谁注入谁：ioc容器注入应用程序某个对象，应用程序依赖的对象；</li><li>注入什么：注入对象所需的外部资源（对象，资源，常量数据）；</li></ol></blockquote><h3 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h3><h4 id="（1）事务基本使用"><a href="#（1）事务基本使用" class="headerlink" title="（1）事务基本使用"></a>（1）事务基本使用</h4><blockquote><ul><li>事务四大特性：原子性（要么都做，要么都不做）、隔离性（事务之间相互不影响）、持久性（一个事务提交，在数据库中他的数据改变是永久的）、一致性（执行事务前后，数据保持一致）；</li><li>编程式事务管理：手动管理事务；</li><li>声明式事务管理：通过aop实现，代码侵入性最低；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<br>    count++;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//抛出异常，事务回滚</span><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>PlatformTransactionManager事务管理器，为接口，提供了获取事务，提交事务，事务回滚的接口方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> &#123;<br>    <span class="hljs-comment">//获得事务，TransactionDefinition为事务的属性，即一些配置属性</span><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）事务传播"><a href="#（2）事务传播" class="headerlink" title="（2）事务传播"></a>（2）事务传播</h4><blockquote><p>事务传播：当事务方法被另外一个事务方法调用时，必须指定事务传播类型；</p><p>事务A的方法调用事务B：</p><p>事务传播参数（Propagation）：</p><ol><li>REQUIRED：默认使用事务，当前如果没有事务，则创建一个新的事务，有事务存在，则加入当前事务，只要其中一个事务回滚，整个事务都会回滚；</li><li>REQUIRES_NEW：不管外面的方法是否有事务开启，内部方法都会创建一个新的事务，若外部事务A回滚，B事务不会回滚，若事务B抛出异常回滚，事务A也会回滚；</li><li>NESTED：外部有事务方法，内部开启一个新的事务，作为嵌套事务存在，如：A回滚，B会回滚。B回滚，A不会回滚；</li><li>MANDATORY：当前有事务，加入事务，无事务，抛出异常</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    B b;<br>    <span class="hljs-meta">@Transactional</span>（(propagation = Propagation.xxx）<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>        b.b();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-meta">@Transactional</span>（(propagation = Propagation.xxx）<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）事务隔离级别"><a href="#（3）事务隔离级别" class="headerlink" title="（3）事务隔离级别"></a>（3）事务隔离级别</h4><blockquote><ul><li><p>ISOLATION_READ_UNCOMMITTED：读未提交，允许读取事务未提交的数据，可能会造成脏读，不可重复读，幻读；</p></li><li><p>ISOLATION_READ_COMMITTED：读提交，允许读取事务提交的数据，可能会造成不可重复读，幻读；</p></li><li><p>ISOLATION_REPEATABLE_READ：可重复读，对数据读取结果都是一致的，除非被本事务修改，可能会造成幻读，MYSQL默认隔离级别；</p></li><li><ul><li>该事务级别，每次会生成一份快照数据（所有已提交事务已修改但未提交的数据），当数据量大时会影响性能；</li><li>减小事务范围，减少生成快照量；</li><li>使用压缩算法，压缩生成的快照数据；</li><li>使用增量快照：只生成最近有一次生成快照修改的数据，减少快照数据量的生成；</li><li>根据应用需求，考虑更低的隔离级别，如读提交级别；</li></ul></li><li><p>ISOLATION_SERIALIZABLE：串行化，所有事务依次执行，性能差，不建议使用；</p></li></ul></blockquote><h4 id="（4）Transation事务失效"><a href="#（4）Transation事务失效" class="headerlink" title="（4）Transation事务失效"></a>（4）Transation事务失效</h4><blockquote><ul><li><p>作用于静态方法上会失效：springIOC管理的是对象，而静态方法是属于类方法，不由ioc管理，事务是通过aop来进行代理实现的，springAOP只能依赖于SpringIOC容器；</p></li><li><p>异常被处理或吞噬：@Transaction作用的方法抛出异常，异常被捕获吞噬了，spring无法检测到该异常，导致事务失效；如下面代码：</p></li><li><ul><li>若是事务可以正常处理，结果要么为23，要么回滚为22，因为事务失效，出现22结果；</li><li>可以使用**TransactionAspectSupport.currentTransactionStatus()**，标记事务回滚（需要激活事务管理器才可以使用该方法）；</li><li>若想自定义异常回滚，可以使用如下：@Transactional(rollbackFor&#x3D; MyException.class)</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<span class="hljs-comment">//传入20</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//模拟异常</span><br>    <span class="hljs-comment">//由于上面出现错误，不会执行此处</span><br>        count++;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;捕获异常，不处理&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//上面出现错误，按道理，spring捕获异常，事务回滚，不会执行下面这句</span><br><span class="hljs-comment">//由于异常被捕获，spring无法检测到，事务不会回滚，还是会执行以下语句</span><br>    count+=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> count;<span class="hljs-comment">//最终结果为22，</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>作用在非public方法会失效，SpringAOP代理只会代理public方法，非public方法无法实现代理；</li><li>同一个类中，没有Transaction注解的方法调用 有Transaction注解的方法，有Transaction的方法会导致事务失效，如下代码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span>&#123;<br>    <span class="hljs-meta">@Transaction</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>        A();<span class="hljs-comment">//A事务失效</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、MVC"><a href="#5、MVC" class="headerlink" title="5、MVC"></a>5、MVC</h3><h4 id="（1）执行流程"><a href="#（1）执行流程" class="headerlink" title="（1）执行流程"></a>（1）执行流程</h4><blockquote><ol><li><p>用户请求–&gt;DispatchServlet：前端控制器收到请求后，委托给统一控制器进行处理，作为统一访问点，进行全局流程控制；</p></li><li><p>DispatchServlet–&gt;HandlerMapping：HandlerMapping将请求映射为HandlerExecutionChain对象，即将url和controller进行映射；</p></li><li><p>DispatchServlet–&gt;HandlerAdapter：HandlerAdapter会把处理器包装为适配器，从而支持多种类型的处理器；</p></li><li><p>HandlerAdapter–&gt;处理器方法调用：HandlerAdapter会根据请求的url选择合适的handler，进行真正业务逻辑处理，返回ModelAndView；</p></li><li><p>ModelAndView–&gt;ViewResolver：将逻辑视图解析为具体的View；</p></li><li><p>View–&gt;渲染：根据model数据获取渲染的View；</p></li><li><p>返回DispatchServlet，由DispatchServlet将数据展示给用户；</p><img src="/2021/09/18/Spring/9.jpg" class="" title="spring"></li></ol></blockquote><h4 id="（2）HandlerMapping"><a href="#（2）HandlerMapping" class="headerlink" title="（2）HandlerMapping"></a>（2）HandlerMapping</h4><blockquote><ul><li><p>HandlerMapping是一个映射器（url和controller的映射），为用户发送请求找到合适的HandlerAdapter控制器；</p></li><li><p>会将请求映射为一个HandlerExecutionChain，包含一个handler对象，多个拦截器对象；</p></li><li><ul><li>Handler：Object类型(Controller类)，可以将其理解为HandlerMethod对象（注解@RequestMapping标注的方法会被解析为该对象），包含了一个方法的所有信息，通过该对象可以执行该方法；</li><li>HandlerInterceptor：拦截处理器，对请求方法进行增强逻辑，可以作用于方法前或方法后；</li></ul></li><li><p>主要包括三部分：映射注册，根据url获取控制器，注册拦截器；</p></li><li><p>可以通过实现HandlerMapping接口，实现自己的映射规则（一般不需要自己实现）；</p></li></ul></blockquote><h5 id="①初始化HandlerMapping（initHandlerMappings（））："><a href="#①初始化HandlerMapping（initHandlerMappings（））：" class="headerlink" title="①初始化HandlerMapping（initHandlerMappings（））："></a>①初始化HandlerMapping（initHandlerMappings（））：</h5><blockquote><ul><li><p>若开启探测功能，扫描已注册HandlerMapping的Bean，添加到HandlerMappings中，默认开启；</p></li><li><p>若关闭探测功能，获得Bean名称为“handleringMapping”的bean，添加到HandlerMappings中；</p></li><li><p>若上面未获取到对应的HandlerMapping，则添加默认默认的实现类；RequestHandlerMapping根据注解RequestMapping获取对应的控制器；BeanNameUrlHandlerMapping则是根据xml配置的url和name获取控制器；</p><img src="/2021/09/18/Spring/10.jpg" class="" title="spring"></li></ul></blockquote><h5 id="②AbstractHandlerMapping"><a href="#②AbstractHandlerMapping" class="headerlink" title="②AbstractHandlerMapping"></a>②AbstractHandlerMapping</h5><blockquote><p>初始化：</p><ul><li>其父类WebApplicationObjectSupport实现了ApplicationContextAware，在初始化该bean时，调用setApplicationContext（）方法，再这个方法中会调用initApplicationContext（）方法；</li><li>detectMappedInterceptors()方法：扫描所有的MappedInterceptor，添加到adaptedInterceptors；</li><li>initInterceptors（）方法：将interceptor转换为HandlerInterceptor，添加到adaptedInterceptors；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//空实现</span><br>    extendInterceptors(<span class="hljs-built_in">this</span>.interceptors);<br>    <span class="hljs-comment">//扫描已经注册的MappedInterceptor</span><br>    detectMappedInterceptors(<span class="hljs-built_in">this</span>.adaptedInterceptors);<br>    <span class="hljs-comment">//将interceptor转换为HandlerInterceptor</span><br>    initInterceptors();<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initInterceptors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.interceptors.isEmpty()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.interceptors.size(); i++) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptors.get(i);<br>            <span class="hljs-keyword">if</span> (interceptor == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Entry number &quot;</span> + i + <span class="hljs-string">&quot; in interceptors array is null&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//拦截器类型转换</span><br><span class="hljs-keyword">protected</span> HandlerInterceptor <span class="hljs-title function_">adaptInterceptor</span><span class="hljs-params">(Object interceptor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> HandlerInterceptor) &#123;<br>        <span class="hljs-keyword">return</span> (HandlerInterceptor) interceptor;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> WebRequestInterceptor) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebRequestHandlerInterceptorAdapter</span>((WebRequestInterceptor) interceptor);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Interceptor type not supported: &quot;</span> + interceptor.getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>getHandler（）方法：获取HandlerExecutionChain拦截链，包括控制器和拦截器，拦截器需要进行路径匹配才可以添加到拦截链中；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ?<br>                                   (HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerExecutionChain</span>(handler));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">lookupPath</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.urlPathHelper.getLookupPathForRequest(request);<br>    <span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-built_in">this</span>.adaptedInterceptors) &#123;<br>        <span class="hljs-comment">//为拦截器</span><br>        <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;<br>            <span class="hljs-type">MappedInterceptor</span> <span class="hljs-variable">mappedInterceptor</span> <span class="hljs-operator">=</span> (MappedInterceptor) interceptor;<br>            <span class="hljs-comment">//拦截器于url匹配</span><br>            <span class="hljs-keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="hljs-built_in">this</span>.pathMatcher)) &#123;<br>                chain.addInterceptor(mappedInterceptor.getInterceptor());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//不是拦截器类型，直接添加</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            chain.addInterceptor(interceptor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③HandlerInterceptor"><a href="#③HandlerInterceptor" class="headerlink" title="③HandlerInterceptor"></a>③HandlerInterceptor</h5><blockquote><ul><li>通过实现WebMvcConfigurer配置类的addInterceptors（InterceptorRegistry registry）方法，添加拦截器；</li><li>拦截器执行顺序为添加拦截器时的顺序；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><span class="hljs-comment">//前置处理器</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, </span><br><span class="hljs-params">                              Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">//后置处理器</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, </span><br><span class="hljs-params">                            Object handler, <span class="hljs-meta">@Nullable</span> ModelAndView modelAndView)</span> <br>    <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">//完成后处理</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response</span><br><span class="hljs-params">                                 ,Object handler, <span class="hljs-meta">@Nullable</span> Exception ex)</span> <br>    <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）HandlerAdapter"><a href="#（3）HandlerAdapter" class="headerlink" title="（3）HandlerAdapter"></a>（3）HandlerAdapter</h4><blockquote><ul><li><p>handler为Object类型，用户处理器可以通过实现Controller接口、HttpRequestHandler接口、@RequestMapping注解来实现，因此springMVC无法直接执行该处理器，需要通过一个适配器HandlerAdapter来执行该方法；</p></li><li><p>ServletInvocationHandlerMethod：封装了HandlerMethod对象，主题业务调用其invokeAndHandle（）方法，最终调用其父类InvocationHandle中的invokeForRequest（）方法，其中包括了参数解析器（HandlerMethodArgumentResolver）和返回值处理器（HandlerMethodReturnValueResolver）；</p></li><li><p>HandlerMethodArgumentResolver：参数解析器，包含多种不同类型的参数解析器，存储在LinkedList中，因此是有序解析，排在前解析器若解析到该参数，后面解析器不会执行；</p></li><li><p>HandlerMethodReturnValueResolver：返回值解析器，包含多种不同类型的参数解析器；</p></li><li><ul><li>RequestResponseBodyMethodProccessor（即是参数解析器，也是返回结果处理器）：处理添加了@RequestBody注解的入参，处理添加了@ResponseBody注解的返回值；会将ModelAndViewContainer的requestHandler设置为true，表示返回视图为null，不会进行视图渲染，从而实现前后分离；</li><li>ViewNameMethodReturnHandler：处理返回结果为视图的类，返回值为void或字符串时，该类都可以将结果设置为视图名；</li><li>当返回的类型为字符串，且不是视图类型，由于RequestResponseBodyMethodProccessor的添加顺序先于ViewNameMethodReturnHandler，因此交给RequestResponseBodyMethodProccessor处理返回值；</li></ul></li></ul></blockquote><h4 id="（4）MultipartResolver"><a href="#（4）MultipartResolver" class="headerlink" title="（4）MultipartResolver"></a>（4）MultipartResolver</h4><blockquote><ul><li>请求头中Content-type类型为：multipart&#x2F;*，MutlipartResolver会将HttpServletRequest解析成MultipartHttpServletRequest对象，以便获取Mutlipart对象；</li><li>MutlipartResolver类型有两种，分别为StandardServletMultipartResolver和CommonMultipartResolver，springboot中默认为StandardServletMutlipartRedolver，会将文件封装为StandardMutlipart；</li></ul></blockquote><h4 id="（5）HandlerExceptionResovler"><a href="#（5）HandlerExceptionResovler" class="headerlink" title="（5）HandlerExceptionResovler"></a>（5）HandlerExceptionResovler</h4><h5 id="①ExceptionHandlerExceptionResolver"><a href="#①ExceptionHandlerExceptionResolver" class="headerlink" title="①ExceptionHandlerExceptionResolver"></a>①ExceptionHandlerExceptionResolver</h5><blockquote><ul><li>基于@ExceptionHandler注解配置HandlerMethod的HandlerExceptionResolver的实现类；</li><li>该类实现了InitializingBean接口，Spring初始化Bean时会调用afterPropertiesSet（）方法进行初始化，将有@ContorllerAdvice注解的bean:异常处理器，添加到map集合（exceptionHandlerAdviceCache），同时初始化参数解析器和返回值解析器；</li></ul></blockquote><h5 id="②ExceptionHandlerMethodResolver"><a href="#②ExceptionHandlerMethodResolver" class="headerlink" title="②ExceptionHandlerMethodResolver"></a>②ExceptionHandlerMethodResolver</h5><blockquote><ul><li>添加@ControllerAdvice注解的bean，用于解析@ExceptionHandler注解的方法；</li><li>将异常类：@ExceptionHandler注解的方法，添加到map中（mappedMethods）；</li><li>resolveMethod(Exception exception)：获取异常对应的方法，会从exceptionLookupCache中查找，查找不到则到mappedMethods中排序获取第一个匹配方法，添加到exceptionLookupCahce中；</li><li>doResolveHandlerMethodException（）：真正执行处理异常的逻辑；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Method <span class="hljs-title function_">resolveMethod</span><span class="hljs-params">(Exception exception)</span> &#123;<br><span class="hljs-keyword">return</span> resolveMethodByThrowable(exception);<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Method <span class="hljs-title function_">resolveMethodByThrowable</span><span class="hljs-params">(Throwable exception)</span> &#123;<br>    <span class="hljs-comment">//获取异常对应的方法</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> resolveMethodByExceptionType(exception.getClass());<br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> exception.getCause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>            method = resolveMethodByExceptionType(cause.getClass());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> method;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Method <span class="hljs-title function_">resolveMethodByExceptionType</span><span class="hljs-params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.exceptionLookupCache.get(exceptionType);<br>    <span class="hljs-comment">//获取不到，则从mappedMethods中获取，并添加到exceptionLookupCache中</span><br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">null</span>) &#123;<br>        method = getMappedMethod(exceptionType);<br>        <span class="hljs-built_in">this</span>.exceptionLookupCache.put(exceptionType, method);<br>    &#125;<br>    <span class="hljs-keyword">return</span> method;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③ResponseStatusExceptionResolver"><a href="#③ResponseStatusExceptionResolver" class="headerlink" title="③ResponseStatusExceptionResolver"></a>③ResponseStatusExceptionResolver</h5><blockquote><ul><li>基于@ResponseStatus注解提供错误响应的HandlerExceptionResolver实现类；</li><li>applyStatusAndReason（）方法：设置错误响应；</li></ul></blockquote><h5 id="④DefaultHandlerExceptionResolver"><a href="#④DefaultHandlerExceptionResolver" class="headerlink" title="④DefaultHandlerExceptionResolver"></a>④DefaultHandlerExceptionResolver</h5><blockquote><p>默认HandlerExceptionResolver的实现类，针对不同异常，设置不同的错误响应码；</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
