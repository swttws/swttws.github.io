<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、工作模型"><a href="#1、工作模型" class="headerlink" title="1、工作模型"></a>1、工作模型</h3><p>①vhost：实现资源的隔离和权限的监控，不同的vhost可以有相同的队列交换机;</p><p>②Broke：消息代理服务</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="图片1"><h3 id="2、直连交换机（Direct）"><a href="#2、直连交换机（Direct）" class="headerlink" title="2、直连交换机（Direct）"></a>2、直连交换机（Direct）</h3><p>①一个队列通过一个具体的routingKey绑定交换机；</p><p>②主要用于循环分发任务给工作者，负载均衡是在消费者之间</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="图片1"><h3 id="3、扇形交换机"><a href="#3、扇形交换机" class="headerlink" title="3、扇形交换机"></a>3、扇形交换机</h3><p>①消息发送给扇形交换机，扇形交换机广播给所有与之绑定的队列；</p><p>②使用场景</p><blockquote><ul><li>大规模多用户在线游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。</li></ul></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="图片1"><h3 id="4、主题交换机"><a href="#4、主题交换机" class="headerlink" title="4、主题交换机"></a>4、主题交换机</h3><p>①交换机与队列绑定的路由键可以使用通配符，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者&#x2F;多应用的时候，主题交换机都可以被列入考虑范围；</p><p>②路由匹配规则</p><blockquote><p>（1）#代表匹配0个或多个规则</p><p>（2）*匹配一个单词</p><p>（3）单词之间用 . 分开</p></blockquote><p>③适用于一些根据业务场景和消息类型过滤消息的场景</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="图片1"><h3 id="5、可靠性投递"><a href="#5、可靠性投递" class="headerlink" title="5、可靠性投递"></a>5、可靠性投递</h3><h4 id="①交换机，队列绑定配置，以及消费者"><a href="#①交换机，队列绑定配置，以及消费者" class="headerlink" title="①交换机，队列绑定配置，以及消费者"></a>①交换机，队列绑定配置，以及消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">------ 配置RabbitMQConfig.class -----------<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String exchangeName=<span class="hljs-string">&quot;test_exchange_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String queueName=<span class="hljs-string">&quot;test_queue_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String routingKey=<span class="hljs-string">&quot;test_key&quot;</span>;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(routingKey);<br>    &#125;<br>&#125;<br><br>-------------消费者Consumer.class------------------------------------------<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-comment">//消费消息</span><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.queueName)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费消息:&quot;</span>+name);<br>    &#125;<br>&#125;<br><br>-------------yml配置-----------------------------------------<br>spring:<br>  rabbitmq:<br>    host: localhost<br>    port: <span class="hljs-number">5672</span><br>    username: admin<br>    password: admin<br>    <span class="hljs-comment">//开启消息确认机制，一定要开启</span><br>    publisher-confirm-type: correlated<br>    publisher-returns: <span class="hljs-literal">true</span><br>    template:<br>      mandatory: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="②消息到RabbitMQ服务端"><a href="#②消息到RabbitMQ服务端" class="headerlink" title="②消息到RabbitMQ服务端"></a>②消息到RabbitMQ服务端</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="图片1"><p>（1）问题：生产者发送消息给MQ服务器时，可能由于网络原因或Broke故障导致发送失败，生产者无法确定是否发送成功；</p><p>（2）事务确认模式：通过channel.txCommit提交事务，若发生异常，使用channel.txRollback回滚事务，我们可以捕捉处理异常，会阻塞后面所有消息的消费；</p><p>（3）Confirm确认模式</p><blockquote><p>correlationData：消息的唯一标识；</p><p>ack：消息发送成功返回true，发送失败返回false;</p><p>cause：消息发送失败原因</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;confirm&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">confirm</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开启消息确认机制，correlationData1为消息标识,</span><br><span class="hljs-comment">     * ack消息是否发送成功（true标识发送成功），cause:发送失败原因</span><br><span class="hljs-comment">     */</span><br>    rabbitTemplate.setConfirmCallback((correlationData1,ack,cause)-&gt;&#123;<br>        <span class="hljs-keyword">if</span> (ack)&#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送失败，&quot;</span>+<span class="hljs-string">&quot;失败原因为：&quot;</span>+cause);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//发送五条消息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//消息的唯一标识</span><br>        CorrelationData correlationData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(String.valueOf(i));<br>        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//消息发送失败</span><br>            Map&lt;String,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;correlationData&quot;</span>, i);<br>            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;无法找到交换机的消息&quot;</span>);<br>            rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;notQueue&quot;</span>, String.valueOf(i),map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            rabbitTemplate.convertAndSend(RabbitMQConfig.queueName,i,correlationData);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③消息从交换机到路由队列"><a href="#③消息从交换机到路由队列" class="headerlink" title="③消息从交换机到路由队列"></a>③消息从交换机到路由队列</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="图片1"><p>（1）问题：交换机到队列的路由或队列不存在，发送消息丢失</p><p>（2）重发消息到新的队列消费</p><blockquote><p>message：回退消息</p><p>replayCode：错误状态码</p><p>replayText：错误内容</p><p>exchange：交换机</p><p>routingKey:路由</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;returnBack&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">returnBack</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//设置消息重发机制</span><br>    rabbitTemplate.setReturnCallback((message, replyCode, replyText,exchange, routingKey)-&gt;&#123;<br>        System.out.println(<span class="hljs-string">&quot;回退消息：&quot;</span>+message);<br>        System.out.println(<span class="hljs-string">&quot;不通路由：&quot;</span>+routingKey);<br>        System.out.println(<span class="hljs-string">&quot;交换机:&quot;</span>+exchange);<br>        System.out.println(<span class="hljs-string">&quot;replayText:&quot;</span>+replyText);<br>        <span class="hljs-comment">//重发消息到备份队列</span><br>        rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                      RabbitMQConfig.backKey,message.getBody());<br>    &#125;);<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                  <span class="hljs-string">&quot;no&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④消息从队列到消费者"><a href="#④消息从队列到消费者" class="headerlink" title="④消息从队列到消费者"></a>④消息从队列到消费者</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="图片1"><p>（1）问题：消息到达队列后，等待消费者消费，消费者未消费，服务宕机，队列消息丢失；</p><p>（2）队列和交换机设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④消息从队列到消费者-1"><a href="#④消息从队列到消费者-1" class="headerlink" title="④消息从队列到消费者"></a>④消息从队列到消费者</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1680333647662-75e519cd-217f-4e20-9e7a-1e315e94dd2f.jpeg" alt="img"></p><p>（1）问题：消息到达队列后，等待消费者消费，消费者未消费，服务宕机，队列消息丢失；</p><p>（2）队列和交换机设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤消息到消费者-消费失败、"><a href="#⑤消息到消费者-消费失败、" class="headerlink" title="⑤消息到消费者 消费失败、"></a>⑤消息到消费者 消费失败、</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="图片1"><p>（1）消费者从MQ中获取消息后，MQ会删除消息，消费者异常消费失败，消息丢失</p><p>（2）消费者消费消息完成后，手动发送ack给服务端</p><blockquote><p>none：自动ACK，默认</p><p>maunal：手动ACK</p><p>auto：方法未抛出异常，自动发送ACK，抛出异常（不是AmqpRejectAndDontReueueException）则发送nack，重新入队列</p><p>开启了maunal后，一定要手动basicACK，否则消息会无限消费</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#设置手动ack<br>listener:<br>direct:<br>acknowledge-mode: manual<br></code></pre></td></tr></table></figure><blockquote><p>【1】void basicAck(long deliveryTag, boolean multiple) ：</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息，如</p><p>发送消息1，2，3，未应答，发送消息4，应答1，2，3，4</p><p>【2】void basicNack(long deliveryTag, boolean multiple, boolean requeue)</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息</p><p>requeue：是否重新入队列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.backQueue)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerAck</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(String msg, Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟故障</span><br>            <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;消息消费：&quot;</span>+msg);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 应答消息消费成功，参数2：true开启批量应答</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ioException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;发送失败，消息丢失&quot;</span>);<br>            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h4 id="1、进程："><a href="#1、进程：" class="headerlink" title="1、进程："></a>1、进程：</h4><p>（1）运行的程序，例如使用QQ，就启动一个进程，操作系统为该进程分配内存空间；<br>（2）进程是程序的一次执行过程，是动态过程；</p><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.jpeg" class="" title="java线程"><h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><p>（1）线程有进程创建，是进程实体；<br>（2）一个进程可以拥有多个线程；</p><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.jpeg" class="" title="java线程"><h4 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h4><p>同一时刻，多个任务交替执行，单核CPU实现任务就是并发；</p><h4 id="4、并行"><a href="#4、并行" class="headerlink" title="4、并行"></a>4、并行</h4><p>同一时刻，多个任务同时执行，多核CPU可以实现并行；</p><h4 id="5、线程执行机制"><a href="#5、线程执行机制" class="headerlink" title="5、线程执行机制"></a>5、线程执行机制</h4><p>（1）主线程结束，其他子线程还在运行，进程就会继续存活；<br>（2）所有线程挂掉，进程才会挂掉；<br>（3）run()方法为一个普通方法，并不会真正启动线程，会等run执行完毕后才会继续执行下面代码；<br>（4）start（）方法才会启动线程；</p><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.jpeg" class="" title="java线程"><h4 id="6、线程启动"><a href="#6、线程启动" class="headerlink" title="6、线程启动"></a>6、线程启动</h4><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.jpeg" class="" title="java线程"><p>（1）执行start（）方法<br>同时执行两个线程，一个执行start的线程，一个执行run的线程</p><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" class="" title="java线程"><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png" class="" title="java线程"><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png" class="" title="java线程"><p>（2）本地方法，JVM调用，底层为c&#x2F;c++实现，真正实现多线程</p><img src="/2023/03/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png" class="" title="java线程"><h4 id="7、线程终止唤醒阻塞状态线程"><a href="#7、线程终止唤醒阻塞状态线程" class="headerlink" title="7、线程终止唤醒阻塞状态线程"></a>7、线程终止唤醒阻塞状态线程</h4><p>（1）interrupt：设置共享变量为true，唤醒阻塞线程<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1675926364932-6eacf187-9efa-4710-bf45-445546682238.jpeg"></p><h4 id="8、join方法"><a href="#8、join方法" class="headerlink" title="8、join方法"></a>8、join方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676267502535-9309d534-a412-430c-b201-642bc2e27446.jpeg"></p><h2 id="二、Thread线程常用方法"><a href="#二、Thread线程常用方法" class="headerlink" title="二、Thread线程常用方法"></a>二、Thread线程常用方法</h2><p>1、join（）方法：线程插队，线程一旦插队成功，肯定先执行完插入的线程的所有任务；<br>2、yield：让出CPU，让其他1线程执行，礼让时间不确定，不一定礼让成功<br>3、守护线程：当所有的用户线程结束，守护线程就会结束；<br>例：垃圾回收机制</p><h2 id="三、线程状态"><a href="#三、线程状态" class="headerlink" title="三、线程状态"></a>三、线程状态</h2><p>（1）java线程中有6种状态；<br>（2）操作系统中有5种状态；<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1675920420437-7282ca5d-d62d-4a3f-a13a-53265fc34c67.jpeg"></p><h2 id="四、线程同步与锁"><a href="#四、线程同步与锁" class="headerlink" title="四、线程同步与锁"></a>四、线程同步与锁</h2><p>1、线程同步机制：使用同步机制保证数据在任何同一时刻，最多只有一个线程访问，以保证数据完整；<br>2、Synchronized同步原理：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1663597347225-6a950e69-21b7-46ad-8398-a80b91508881.jpeg"><br>3、互斥锁：<br>（1）每个对象都有一个可称为“互斥锁”的标记，这个标记只能保证任意时刻只有一个线程访问该对象；<br>（2）影响程序执行效率；<br>（3）同步方法（非静态的）的锁可以是this对象，也可以是其他对象；<br>（4）同步方法（静态的）的锁为当前类本身；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1663598355812-9c4ba65e-e464-45ba-8edd-2de7ff8a31c0.png#averageHue=%23fdf7f6&clientId=ud347ab26-9edb-4&from=paste&height=322&id=u50b3b34e&name=image.png&originHeight=483&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50106&status=done&style=none&taskId=ub5a5ae6b-b36a-4564-9c05-4bf59d289ed&title=&width=576" alt="image.png"><br>4、线程死锁：多个线程占用对方资源，不肯相让，导致形成死锁；<br>5、释放锁：<br>（1）线程同步方法，同步代码块执行结束；<br>（2）线程同步方法、同步代码块遇到break、return；<br>（3）出现未处理的error或Exception，导致异常结束；<br>（4）执行线程中wait（）方法，线程暂停，释放锁<br>sleep（），yield（），suspend（）不会释放锁</p><hr><h2 id="1、Object-wait"><a href="#1、Object-wait" class="headerlink" title="1、Object.wait()"></a>1、Object.wait()</h2><p>（1）一定要持有到调wait方法那个对象的锁，wait代码段放在synchronized块中；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669012336135-927735dd-d945-4708-a036-21b644198a2a.png#averageHue=%23322b2a&clientId=u29abe8d5-ad10-4&from=paste&height=95&id=u398bb217&name=image.png&originHeight=143&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20713&status=done&style=none&taskId=uf7b75fbc-2889-4a20-a90d-5b0e524e20b&title=&width=465.3333333333333" alt="image.png"><br>（2）持有该对象锁的线程，执行notify或notifyAll方法可以唤醒等待线程；<br>（3）调用wait后，会将该对象锁释放，进入等待状态，线程加入waitSet集合，waitSet底层是双向链表；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669277852051-6501a786-7fe1-4771-a09e-57976b5c7c3f.png#averageHue=%23f6f5f3&clientId=u503e4b85-1a4e-4&from=paste&height=77&id=uf78a2668&name=image.png&originHeight=115&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14728&status=done&style=none&taskId=ue4b79aa7-be5f-4e10-af7f-8081cc278fd&title=&width=531.3333333333334" alt="image.png"><br>（4）该线程被唤醒后，会与其他线程公平竞争该对象锁，只有该线程获取到对象锁后，才会继续往下执行；</p><hr><h2 id="2、Object-notify-、notifyAll（）"><a href="#2、Object-notify-、notifyAll（）" class="headerlink" title="2、Object.notify()、notifyAll（）"></a>2、Object.notify()、notifyAll（）</h2><p>（1）当调用对象notify方法时，会随机唤醒等待集合中一个线程，唤醒线程与其他线程公平竞争锁；<br>  从WaitSet集合中选出一个线程，加入到EntryLsit集合中<br>（2）当调用notifyAll方法时，唤醒等待集合所有线程；<br>（3）在某一时刻，只有唯一线程可以获取对象锁；</p><hr><h2 id="3、synchronized关键字"><a href="#3、synchronized关键字" class="headerlink" title="3、synchronized关键字"></a>3、synchronized关键字</h2><p>（1）同一个对象，多个synchronized方法，多个线程某一个时刻同时访问，只能先执行一个方法；（锁为对创建的对象锁）<br>（2）synchronized修饰的静态方法，多个对象中，多个线程只能访问一个线程去访问（对该对象的Class对象加锁）；<br>（3）synchroinzed修饰代码块，通过 monitorenter和monitorexit来获取锁和释放锁；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669273053301-3d2cf3c2-41ba-458b-a1c1-64cb4c82eff5.png#averageHue=%23464a4c&clientId=u503e4b85-1a4e-4&from=paste&height=195&id=u159bd0a5&name=image.png&originHeight=292&originWidth=469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38141&status=done&style=none&taskId=u7c119d1c-ffbe-438d-b2ad-aecf95710ea&title=&width=312.6666666666667" alt="image.png"><br>（4）JVM同步基于进入与退出监视器对象（Monitor）来实现，每个对象实例·会有个Monitor对象，monitor对象和java对象一并创建并销毁，monitor由c++创建；<br>（5）多个线程访问一段同步代码块，获取不到锁的线程会放入Entrylist集合，处于阻塞的线程会被放入该集合中，当线程获取到Monitor对象时，monitor对象依赖于底层操作系统的mutex_lock（互斥锁），线程获取成功后，会持有mutex，其他线程无法获取mutex；<br>（6）基于底层操作系统的mutex_Lock来实现，每次锁的获取与释放都会带来用户态与内核态的切换，并发量高时，synchronized锁性能非常差；<br>（7）调用wait方法的线程会进入waitset集合，处于阻塞状态的线程会进入EntryList集合中，waitset中的线程被notify唤醒后，若争抢不到锁，线程会加入EntryList集合，进而进入内核状态；<br>解决上述方法：自旋，其原理：发生岁monitor的争用时，若Owner能够很短时间内释放该锁，则那些正在争用的线程可以自旋，在Owner释放锁后，会立即获取到锁，从而避免阻塞，争用一段时间后若无法获取锁，则进入阻塞状态。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669278054710-22a6c144-7d13-49ee-9b43-b2478c102282.png#averageHue=%23f4f2f1&clientId=u503e4b85-1a4e-4&from=paste&height=107&id=uefb485c1&name=image.png&originHeight=160&originWidth=965&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21825&status=done&style=none&taskId=u6ef43aec-822a-46ad-ada2-ca0deb50d71&title=&width=643.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669278235515-1e534b92-6898-4549-812b-433bedf282cb.png#averageHue=%23f5edec&clientId=u503e4b85-1a4e-4&from=paste&height=153&id=ue5894cfa&name=image.png&originHeight=230&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26270&status=done&style=none&taskId=u611fc02d-582e-40e9-b48c-f68037d4858&title=&width=442" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669340997918-00e443eb-c5fb-4a70-8903-f9ad350b62f9.jpeg"><br>（8）互斥锁属性<br>【1】P_THREAD_MUTEX_TMIED_NP：普通锁，当一个线程加锁后，其余线程进入等待队列，并且在解锁后按照优先级获取锁，从而确保资源分配的公平性；<br>【2】P_THREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并通过unlock进行解锁，如果是不同新城请求，可通过加锁线程解锁后重新进行竞争；<br>【3】P_THREAD_MUTEX_ERRORCHECK_NP：检错锁，一个线程请求同一个锁，则返回EDEADLK，否则与【1】锁一样，不允许多次加锁时不会出现死锁；<br>【4】P_THREAD_MUTEX_ADAPTIVE_NP：适应锁，仅仅等待解锁后重新竞争；</p><hr><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>（1）对于锁的访问与java对象头相关，java对象头包括Mark Word、指向类指针、数组长度；<br>（2）Mark Word记录了对象、锁及垃圾回收相关信息，包括如下组成部分：<br>【1】无锁标记<br>【2】偏向锁标记<br>【3】轻量级锁标记<br>【4】重量级锁标记：synchroinzed标记<br>【5】GC标记<br>（3）锁演化阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<br>（4）偏向锁：<br>对于一个线程，主要作用是优化同一个线程多次获取同一个一个锁的情况，如果一个synchroinzed方法被一个线程访问，synchroinzed方法所在对象就会在起Mark Word中将偏向锁标记，同时还有一个字段存储线程id，，当这个线程继续访问同一个synchroinzed方法时，他会检查这个对象的Mark Word偏向锁标记以及是否指向该id：(建议关闭偏向锁)<br>【1】如果是同一个线程，线程无须进入内核态，而是直接进入方法中；<br>【2】如果是另外一个线程访问synchroinzed方法，偏向锁取消；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669343590093-fc6e0478-40d7-4e43-bdb7-b99ee97ce6b6.jpeg"><br>（5）轻量级锁：（适合两个线程轮流访问），如自旋锁<br>若第一个线程已经获取到当前对象锁，这时第二个线程尝试争抢该对象锁，由于该对象的锁已经被第一个线程获取到，因此他是偏向锁。第二个线程在争抢时，会发现对象头中的Mark Word已经是偏向锁标记，，但里面存储的id并不是自己，则会进行CAS，从而获取到锁。两种情况：<br>【1】获取锁成功：会将Mark Word里的线程id由第一个线程变成自己的，这样对象依旧保持偏向锁状态；<br>【2】获取失败：则表示这可能有多个线程争抢对象锁，那么偏向锁升级，升级为轻量锁；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669356490091-2362fe46-20c5-4611-ab43-3f7366e53d79.jpeg"><br>（6）重量级锁<br>若自旋失败，锁会转换为重量级锁，无法获取到锁的对象都会进入Monitor（内核态）；自旋可以避免线程从用户态进入内核态；</p><hr><h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>（1）死锁线程1等待线程2互斥持有的资源，线程2等待线程1互斥持有的资源，两个线程无法继续执行；<br>（2）活锁：线程持续重试一个总是失败的操作，导致无法继续操作；<br>（3）饿死：线程一直被调度器延迟访问其可执行的资源，调度器先于优先级低的线程而执行高优先级线程，则总是执行高优先级线程，导致该线程一直无法执行；</p><hr><h2 id="6、Lock锁机制"><a href="#6、Lock锁机制" class="headerlink" title="6、Lock锁机制"></a>6、Lock锁机制</h2><p>（1）lock与synchroinzed区别：<br>【1】锁释放：lock必须通过unlock方法在finally中手动释放，synchroinzed通过jvm释放，synchroinzed锁的释放是按照加锁时的相反顺序释放，如加A锁，再加B锁，先释放B锁，再释放A锁，Lock锁的释放可以以任意顺序释放；<br>【2】锁获取：lock通过代码手工获取锁，synchroinzed通过jvm获取锁，无需开发者干预；<br>【3】具体实现方式：lock通过java代码实现，synchroinzed通过jvm底层实现；<br>【4】锁类型：lock提供多种，如公平锁，非公平锁，synchroinzed与lock均提供可重入锁；<br>（2）tryLock（）方法：获取到锁会返回true，获取不到则会放回false<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669427639306-f74f3a7f-d3dd-4319-96d8-a00d7142df08.png#averageHue=%232b2b2b&clientId=u503e4b85-1a4e-4&from=paste&height=181&id=u6a8d9373&name=image.png&originHeight=271&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18993&status=done&style=none&taskId=u00f9a3bd-395e-40b8-b812-3732e596ff4&title=&width=448" alt="image.png"><br>（3）ReentrantLock 可重入锁：一个线程可以重复获取同一个锁，即使锁没有释放；</p><hr><h2 id="7、Condition"><a href="#7、Condition" class="headerlink" title="7、Condition"></a>7、Condition</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676446706496-9fe24858-050a-4d89-81a8-b6a35dc737ec.jpeg"><br>（1）await<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676442911205-bb46214b-e047-4888-b157-32af1e23b508.jpeg"><br>（2）condition.signal()<br>①原tail结点是CANCELLED状态；<br>②condition的结点transfer到AQS队列之后，通过lock.unlock()去唤醒；<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676443832559-c3dc6db0-cc75-41f7-bae9-999d954b3322.jpeg"><br>（3）传统可以通过synchroinzed+wait+notify&#x2F;notigyAll来实现多个线程之间的通信，整个过程由JVM实现，开发者无需了解底层实现细节；<br>（4）从jdk1.5后，并发包提供lock和Condition（await与signal&#x2F;signalAll）来实现多个线程之间通信，整个过程由开发者控制；<br>（5）Conditidion支持一个对象拥有多个waitset等待集合，而传统方式只允许有一个waitset集合；<br>（6）Condition必须关联一个lock,一个lock可以生成多个condition对象；<br>（7）await（）方法为避免被假唤醒，应当放入while循环中，调用await后会释放锁，需要signal（）方法唤醒才能继续执行；</p><hr><h2 id="8、volatile关键字（保证可见性）"><a href="#8、volatile关键字（保证可见性）" class="headerlink" title="8、volatile关键字（保证可见性）"></a>8、volatile关键字（保证可见性）</h2><p>（1）实现long&#x2F;double类型变量的原子操作，变量不会从寄存器获取变量，而是从内存（高速缓存）中获取；要实现原子性，等号右侧的赋值变量中不能出现被多线程所共享的变量，即使这个变量被volatile修饰也不行；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669623594040-8db80380-2767-44c7-89ec-603f0abe83c0.jpeg"><br>（2）指令重排序<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676095797644-f2f37d2a-e6a4-4dcf-9f90-163e5a393e05.jpeg"><br>（3）内存屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-comment">//volatile会自动生成屏障</span><br><br>CPU0&#123;<br>a=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//storeMemoryBarrier()写屏障，写入到内存中</span><br>b=<span class="hljs-number">1</span>;<br>&#125;<br><br>CPU1&#123;<br><span class="hljs-keyword">while</span>(b==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//true</span><br>        <span class="hljs-comment">//loadMemoryBarrier();读屏障</span><br>        <span class="hljs-keyword">assert</span>(a==<span class="hljs-number">1</span>)<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676103938473-c284c76a-55f8-4587-8366-871c3d20b310.jpeg"><br>（4）防止指令重排序，实现变量的可见性的手段：内存屏障<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669626324264-4afc3f12-5530-4ac0-85ee-21f73bba08bd.jpeg"></p><hr><h2 id="9、java内存模型（JMM）"><a href="#9、java内存模型（JMM）" class="headerlink" title="9、java内存模型（JMM）"></a>9、java内存模型（JMM）</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676179306578-a5ebf24b-92e7-4ef0-96da-7dff44a0ca29.jpeg"><br>（1）顺序执行（限定在当个线程之上）:该线程的每个动作都happen-before它的后面动作；<br>（2）隐式锁（monitor）规则：unlock happen-before lock，之前的线程对于同步代码块的所有执行结果对于后序获取锁的线程来说都是可见的；<br>（3）volatile读写规则：对于一个volatile变量的写操作一定会happen-before后续对该变量的读操作；<br>（4）多线程启动规则：Thread对象的start方法happen-before该线程run方法中的任何一个动作，包括其中启动的任何子线程；<br>（5）多线程的终止规则：一个线程启动一个子线程，并且调用子线程join方法等待其结束那么当子线程结束后，父线程接下来的所有操作都可以看到子线程run方法中的执行结果；<br>（6）线程中断规则:可以用interrupt方法来中断线程，这个调用happen-before对该线程中断的检查；</p><hr><h2 id="10、CountDownLatch"><a href="#10、CountDownLatch" class="headerlink" title="10、CountDownLatch"></a>10、CountDownLatch</h2><p>（1）countDown（）方法：计数器不为0，计数器值减减，计数器最小值为0；<br>（2）await（）方法：调用该方法的线程，判断计数器是否为0，不为0，则阻塞，为0，直接继续执行线程；<br>（3）计数器为一次性的；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669773465087-ff2b5371-a20f-4b4a-ab52-66f4b3871b04.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676530914333-3cbc0448-497a-407a-9a14-ef2d3737778b.jpeg"><br>（4）唤醒线程源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>   <span class="hljs-comment">//s为null，并行操作中，添加时，可能还没有执行next=线程，导致head.next=null</span><br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>           s = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//往尾结点找head.next</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                   s = t;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>           LockSupport.unpark(s.thread);<br>   &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="11、CyclicBarrier"><a href="#11、CyclicBarrier" class="headerlink" title="11、CyclicBarrier"></a>11、CyclicBarrier</h2><p>（1）await（int count）方法，等待线程达到指定数量count，才能继续执行；<br>（2）计数器可以重用，计数器值为0后，值置为初始值；<br>（3）CyclicBarrier(int parties, Runnable barrierAction)，barrierAction在最后一个线程抵达屏障后，会执行；<br>（4）会出现并发情况；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669773652009-849f8573-34cf-4ad4-882e-e8080b58c463.jpeg"><br>（4）底层执行流程：<br>【1】初始化各种成员变量，包括parties，count以及Runable；<br>【2】调用await方法时，底层会先检查是否已经归0，如果是，执行可选的Runable，接下来进行下一个generation；<br>【3】在下一个分代中，将会重置count为parties，并且创建新的Generation实例；<br>【4】接下来signalAll方法，唤醒所有在屏障前面等待线程，让其继续开始执行；<br>【5】计数器没有归0，调用线程将会通过Condition的await方法在屏障前等待；<br>【6】执行过程在lock锁内，不会出现并发情况；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669776732350-2baa3e99-946f-4d5a-888d-4f33d5f1d0f5.png#averageHue=%232f2d2c&clientId=u255c88af-d038-4&from=paste&height=137&id=H8ua4&name=image.png&originHeight=206&originWidth=775&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32179&status=done&style=none&taskId=ue00e1972-ebe1-4d27-be1f-70ecff5c3a3&title=&width=516.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669776837579-e5e891d5-3201-450b-80f2-10cf851d5bc8.png#averageHue=%232f2d2c&clientId=u255c88af-d038-4&from=paste&height=50&id=SlaN9&name=image.png&originHeight=75&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8589&status=done&style=none&taskId=u4a463ed0-db26-4720-887d-01f5542d916&title=&width=348.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669776861471-7e8ecde2-bc57-42bc-94a8-97fa218a33d2.png#averageHue=%232c2b2b&clientId=u255c88af-d038-4&from=paste&height=51&id=djdl2&name=image.png&originHeight=77&originWidth=580&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5695&status=done&style=none&taskId=u28e3a00c-65ef-4e6b-bf3f-73090ab3043&title=&width=386.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669777390385-be76dc98-8844-40c2-9f58-1254eaae2327.png#averageHue=%232f2b2a&clientId=u255c88af-d038-4&from=paste&height=329&id=UwEG2&name=image.png&originHeight=494&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55092&status=done&style=none&taskId=u8b0bac8d-476e-4690-b20b-b133ce97207&title=&width=569.3333333333334" alt="image.png"></p><hr><p><strong>12、CAS（Compare And Swap）</strong><br>（1）synchronized关键字与lock锁等锁机制都是悲观锁：无论任何操作，首先要获取锁，再执行后续操作，从而确保所有操作都是由当前这个线程来执行的；<br>（2）乐观锁：线程操做之前不会做任何预先处理，而是直接执行，当在最后执行变量更新的时候，当前线程需要由一种机制确保当前被操作的变量没有被其他线程修改；<br>（3）CAS为乐观锁的一种实现方式，比较与交换，不断循环，直到变量被成功修改为止，CAS本身通过硬件指令来提供支持，硬件通过一个指令来实现交换与比较，因此CAS可以确保变量操作的原子性；<br>（4）CAS操作数涉及如下：<br>【1】需要被操作的内存值V；<br>【2】需要进行比较的值A；<br>【3】需要进行写入的值B；<br>【4】只有当V&#x3D;&#x3D;A时，CAS才会通过原子操作的手段来将V的值更新为B；<br>（5）问题：<br>【1】循环开销问题：并发量大的情况下会导致线程一直自旋；<br>【2】只能保证一个变量的原子操作：可以通过AtomicReference来实现对多个变量的原子操作；<br>【3】ABA问题：1-&gt;3-&gt;1</p><hr><h2 id="13、CompletableFuture"><a href="#13、CompletableFuture" class="headerlink" title="13、CompletableFuture"></a>13、CompletableFuture</h2><p>异步执行，whenComplete（）等待任务执行返回结果，不会阻塞主线程的执行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669795981615-1f60179e-d4af-4969-b037-2e87542845e9.png#averageHue=%232c2c2c&clientId=u255c88af-d038-4&from=paste&height=425&id=uf945a856&name=image.png&originHeight=638&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89049&status=done&style=none&taskId=ucb2a8134-421f-425a-bb83-7a52866bf5f&title=&width=866.6666666666666" alt="image.png"></p><hr><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><p>（1）本质上·，ThreadLocal是通过空间换取时间，从而实现每一个线程中间都会有一个变量的副本，这样每个线程都会操作该变量副本，从而避免多线程并发问题；<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676275172642-7ff5f4cd-b8a4-4f95-a50a-7efc6dbaf132.jpeg"><br>（2）ThreadLocl与该运行的线程相绑定，每个线程对应不同ThreadLocal；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669861193612-a0decb5a-f8e4-430b-9010-fe0c801ae751.jpeg"><br>（3）java四种类型引用<br>【1】强引用：new一个实例，GC不会回收new出来实例对象；<br>【2】软引用：如果GC内存空间回收时，空间不够，会清除软引用，空间够，则不会清楚；<br>【3】弱引用：下一次GC回收，会被清理；<br>【4】虚引用：指向队列的元素被清理时，会收到通知<br>（4）Entry使用弱引用为了避免内存泄漏<br>【1】若Entry中使用强引用，当栈中ThreadLocal引用销毁时，Entry中的kv一直存在，导致Entry的kv一直增加，导致内存泄漏；<br>【2】使用弱引用可以保证，当堆中的ThreadLocal对象只被弱引用所指向，会被GC回收，Entry中的Key置为null；<br>【3】当调用ThreadLocal的set和get方法时，会清除键为null的Entry对象；也可以通过调用remove方法删除指定key的Entry对象<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669863366146-b975518c-7640-45eb-bc64-ede5c7b1cd70.jpeg"></p><hr><h2 id="15、AQS（AbstractQueuedSynchronizer）"><a href="#15、AQS（AbstractQueuedSynchronizer）" class="headerlink" title="15、AQS（AbstractQueuedSynchronizer）"></a>15、AQS（AbstractQueuedSynchronizer）</h2><h4 id="（1）组成"><a href="#（1）组成" class="headerlink" title="（1）组成"></a>（1）组成</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669885825342-d8d20b6d-e45c-43c2-a0ce-2899b952687d.jpeg"></p><h4 id="（2）可重入锁（ReentrantLock）源码分析"><a href="#（2）可重入锁（ReentrantLock）源码分析" class="headerlink" title="（2）可重入锁（ReentrantLock）源码分析"></a>（2）可重入锁（ReentrantLock）源码分析</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676359742239-7ac39c9d-6e61-407a-bee8-e1b7f61c72a3.jpeg"><br>【1】尝试获取对象锁，获取不到（其他线程已经持有锁，并且尚未释放）,该线程会进入AQS阻塞队列中；<br>【2】如果获取到锁，那么根据是公平锁还是非公平锁进行不同处理：<br>①如果是公平锁，线程直接放入AQS队列尾部；<br>②如果是非公平锁，线程会先进行CAS计算，，如果成功直接获取锁，如果失败，则与公锁一致，被放入阻塞队列末尾；<br>③当锁被释放（调用unlock），那么会调用release方法对static成员变量值一直减一操作，如果减一后，state为0，那么relaease执行完毕，并且调用LockSupport的unpark方法唤醒该线程后的等待队列中的第一个后继线程，将其唤醒，使之获取到对象锁；锁可以重入，多次调用lock锁，导致每一次调用，state都会加1；<br>【3】本质上是对AQS的state成员变量操作，对该成员变量加1，表示上锁，减1，表示释放锁；<br>公平锁上锁<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669868498270-1d53cf93-b0e2-477b-a24c-0a5109039412.png#averageHue=%23332b2a&clientId=u71c289cb-14c3-4&from=paste&height=407&id=uac7065cb&name=image.png&originHeight=610&originWidth=1081&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97569&status=done&style=none&taskId=ue687876f-ceaa-4a43-a350-b90212ddb44&title=&width=720.6666666666666" alt="image.png"><br>非公平锁上锁<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669868633448-3fbc5163-e744-4f67-bead-ce858e75f66d.png#averageHue=%23312b2b&clientId=u71c289cb-14c3-4&from=paste&height=396&id=u8b9bb789&name=image.png&originHeight=594&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86832&status=done&style=none&taskId=ucb5596fa-1380-4a80-ac34-aff6353ef64&title=&width=716.6666666666666" alt="image.png"></p><h4 id="（3）可重入读写锁（ReentrantReadWriteLock）"><a href="#（3）可重入读写锁（ReentrantReadWriteLock）" class="headerlink" title="（3）可重入读写锁（ReentrantReadWriteLock）"></a>（3）可重入读写锁（ReentrantReadWriteLock）</h4><p>【1】读锁：获取读锁时，会尝试判断当前对象是否拥有写锁，如果已经拥有写锁，直接失败，如果没有写锁，则表示当前对象没有排他锁，则当前线程会尝试对象加锁，，如果当前线程已经拥有该对象的锁，直接将读锁数量加1；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669879276855-302eebb7-3980-463a-9676-6668aeb219c6.png#averageHue=%23705439&clientId=u71c289cb-14c3-4&from=paste&height=81&id=ub5d2c37f&name=image.png&originHeight=121&originWidth=1048&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32782&status=done&style=none&taskId=u3901d3dc-65d8-475b-9196-29f839172c9&title=&width=698.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669879601438-67d9a47d-2b25-4574-b860-8e3fe9fd6f46.png#averageHue=%232f2b2b&clientId=u71c289cb-14c3-4&from=paste&height=299&id=u9fcd4dad&name=image.png&originHeight=448&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61815&status=done&style=none&taskId=u17d05c4b-47b2-4a98-8cf6-aaec828fb8c&title=&width=664.6666666666666" alt="image.png"><br>【2】写锁：获取写锁时，会尝试当前对象是否拥有锁（读锁与写锁），如果已拥有锁并且线程并非当前线程，直接失败；如果当前对象没有加锁，就会为当前对象上锁，并且将写锁数量加1，将当前对象的排他锁线程持有者设为自己；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669879840178-ad194c35-e241-4f8c-be8e-2af8466c9f99.png#averageHue=%23372b2a&clientId=u71c289cb-14c3-4&from=paste&height=221&id=ue74210e6&name=image.png&originHeight=331&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66640&status=done&style=none&taskId=udfb2ee38-2fcd-4650-aaa5-d4f1987e937&title=&width=713.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669880085073-b255c06a-0db2-4c6b-970e-cadffc662561.png#averageHue=%233a2a29&clientId=u71c289cb-14c3-4&from=paste&height=59&id=u5755f595&name=image.png&originHeight=88&originWidth=1026&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16144&status=done&style=none&taskId=u5902bb6e-9e0a-4f0c-8c80-9610fe86ccc&title=&width=684" alt="image.png"><br>【3】读锁释放：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669881180052-96edc6c8-520d-4a2e-9874-303509917b38.png#averageHue=%233a2c2a&clientId=u71c289cb-14c3-4&from=paste&height=137&id=u6e319411&name=image.png&originHeight=205&originWidth=1116&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53965&status=done&style=none&taskId=uebfffe4e-8a74-4706-87ee-4f6cc4d7691&title=&width=744" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669881660126-5a88cfac-c7d5-41de-b9c6-61f3b8a19ee8.png#averageHue=%23342b2a&clientId=u71c289cb-14c3-4&from=paste&height=259&id=u9335c009&name=image.png&originHeight=389&originWidth=1133&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68097&status=done&style=none&taskId=u83989128-13f6-46c7-94f8-7d60de9adec&title=&width=755.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669881934552-8e172bc4-ff56-4db6-947f-0e48a8824398.png#averageHue=%23322c2b&clientId=u71c289cb-14c3-4&from=paste&height=205&id=u89dabdb5&name=image.png&originHeight=299&originWidth=978&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42573&status=done&style=none&taskId=u22f90868-7505-4960-adf2-6fe5e1c83dd&title=&width=670" alt="image.png"><br>【4】写锁释放<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669883725695-5e6d16ff-829a-44e8-84de-4ade94c25a0e.png#averageHue=%23342b2a&clientId=u71c289cb-14c3-4&from=paste&height=234&id=u8e4bf411&name=image.png&originHeight=351&originWidth=1160&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66039&status=done&style=none&taskId=u9b2a6204-0c74-466b-8109-f51a9bf36c4&title=&width=773.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669883823728-8c3d6ad0-ca10-4599-b0f3-6e97ca05df18.png#averageHue=%23322c2a&clientId=u25dde710-cfe6-4&from=paste&height=208&id=ud1b2ed7b&name=image.png&originHeight=289&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43747&status=done&style=none&taskId=u2447ee7c-6d64-4f7a-8194-5eb8f773845&title=&width=658.6666870117188" alt="image.png"></p><h4 id="（4）条件队列与阻塞队列"><a href="#（4）条件队列与阻塞队列" class="headerlink" title="（4）条件队列与阻塞队列"></a>（4）条件队列与阻塞队列</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1669888497977-2462c318-5983-427e-b146-9ea3ba7341c6.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669886246010-cd214b97-2e63-4867-bbf6-2e53e2f27bb9.png#averageHue=%232f2c2b&clientId=u25dde710-cfe6-4&from=paste&height=331&id=u6944d053&name=image.png&originHeight=497&originWidth=1041&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66147&status=done&style=none&taskId=u3f267e99-63ac-45aa-9c9a-046a4b89c5e&title=&width=694" alt="image.png"></p><h4 id="（5）阻塞队列（BlockingQueue）"><a href="#（5）阻塞队列（BlockingQueue）" class="headerlink" title="（5）阻塞队列（BlockingQueue）"></a>（5）阻塞队列（BlockingQueue）</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676527231792-13a49395-1971-453e-88ea-c020570fdc5b.jpeg"></p><h4 id="（5）AQS与synchronized关系"><a href="#（5）AQS与synchronized关系" class="headerlink" title="（5）AQS与synchronized关系"></a>（5）AQS与synchronized关系</h4><p>【1】synchronized在实现<br>①存在两个数据结构：waitset，EntryList，waitset中存放的是调用了Object的wait方法的线程对象，EntryList存放的陷入到阻塞状态，需要获取monitor线程对象<br>②当一个线程被notify后，线程会从waitset中移动到EntryList中，进入到EntryList后，该线程依旧需要与其他线程争抢monitor对象，如果争抢到，就获取到锁，可以执行；<br>【2】AQS实现<br>①存放两种数据结构：Conditiojn对象上的条件队列，以及AQS的阻塞队列，这两个对象每一个都是Node实例（封装线程对象）<br>②当位于condition条件队列的线程被其他线程signal后，该线程会被移动到阻塞队列中，位于AQS阻塞队列中的Node对象本质上由一个双向队列构成；<br>③在获取AQS锁中，这些进入阻塞队列的线程会按照队列顺序先后尝试获取；<br>④当AQS阻塞队列中线程获取到锁后表示该线程可以正常执行；<br>⑤陷入对等或阻塞状态的线程，依然需要进入操作系统内核态，进入阻塞（park方法实现）；</p><hr><h2 id="16、ConcurrentHashMap"><a href="#16、ConcurrentHashMap" class="headerlink" title="16、ConcurrentHashMap"></a>16、ConcurrentHashMap</h2><h3 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676613284516-be0880d7-422a-4c51-8a08-8dafbba78574.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676613581440-5c976a2e-6ae1-429c-ab86-7cc79e45a93d.jpeg"></p><h3 id="（2）put方法"><a href="#（2）put方法" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676616320722-ee1e5594-ac45-4580-8c5f-126e6d545ecf.jpeg"></p><h4 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<span class="hljs-comment">//初始化</span><br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//添加位置结点为空</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<span class="hljs-comment">//添加结点</span><br>                    <span class="hljs-keyword">break</span>;                  <br>              &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>       Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>        <span class="hljs-comment">//多个线程操作，需要不断自旋判断数组是否尾空</span><br>       <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>               Thread.<span class="hljs-keyword">yield</span>(); <br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//只有一个线程进入</span><br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<span class="hljs-comment">//默认长度16</span><br>                       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                       table = tab = nt;<br>                       sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<span class="hljs-comment">//扩容因子  16*0.75</span><br>                   &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   sizeCtl = sc;<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> tab;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）put阶段存在hash冲突"><a href="#（2）put阶段存在hash冲突" class="headerlink" title="（2）put阶段存在hash冲突"></a>（2）put阶段存在hash冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>        binCount = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录链表长度，用于后面判断是否需要树华</span><br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>            K ek;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                ((ek = e.key) == key ||<br>                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="hljs-comment">//key的值与存在结点的key一样，直接替换</span><br>                oldVal = e.val;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                    e.val = value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Node&lt;K,V&gt; pred = e;<span class="hljs-comment">//记录前驱结点</span><br>            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//直到下一个结点为null，添加新结点到位部</span><br>                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                          value, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）元素个数统计与更新（addCount）"><a href="#（3）元素个数统计与更新（addCount）" class="headerlink" title="（3）元素个数统计与更新（addCount）"></a>（3）元素个数统计与更新（addCount）</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676619132077-b168b9cf-e8c9-4904-98f6-2b28e39d3e53.jpeg"></p><h5 id="①初始化"><a href="#①初始化" class="headerlink" title="①初始化"></a>①初始化</h5><blockquote><p>private transient volatile long baseCount; 没有竞争情况下，通过CAS更新元素个数<br>private transient volatile CounterCell[] counterCells;  多线程竞争情况下，存储元素个数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterCell</span> &#123;<br>       <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>       CounterCell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>   &#125;<br><br><span class="hljs-comment">//求总和</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>       CounterCell[] as = counterCells; CounterCell a;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>       <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>               <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                   sum += a.value;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>直接访问baseCount累加元素个数；</li><li>找到CounterCell[]随机下标位置，累加个数</li><li>如果前面失败，进入fullAddCount（）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> ||<br>     <span class="hljs-comment">//CAS修改元素个数，修改成功则不进入if</span><br>    !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>    CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>     <span class="hljs-comment">//counterCells数组为空</span><br>    <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>        <span class="hljs-comment">//CAS修改对应CounterCells，修改成功，不进入if</span><br>        !(uncontended =<br>          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>        fullAddCount(x, uncontended);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    s = sumCount();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②元素个数并发更新（fullAddCount）"><a href="#②元素个数并发更新（fullAddCount）" class="headerlink" title="②元素个数并发更新（fullAddCount）"></a>②元素个数并发更新（fullAddCount）</h5><blockquote><ol><li>CountCell为null</li><li>已经初始化，然后存在竞争，CAS进行更新-&gt;失败触发CounterCell扩容</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">CounterCell[] as; CounterCell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br><span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;            <br>            <span class="hljs-type">CounterCell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x); <br>            <span class="hljs-comment">//修改cellBusy为1，表示只有一个线程操作</span><br>            <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; <br>                U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                    CounterCell[] rs; <span class="hljs-type">int</span> m, j;<br>                    <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                        (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                        rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                        rs[j] = r;<br>                        created = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (created)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>            &#125;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>        wasUncontended = <span class="hljs-literal">true</span>;      <br>    <span class="hljs-comment">//存在，CAS修改</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>        collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>        collide = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//容量不够，需要扩容</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>             U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>                CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<span class="hljs-comment">//n为原本as的长度</span><br>                    rs[i] = as[i];<br>                counterCells = rs;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cellsBusy = <span class="hljs-number">0</span>;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>    &#125;<br>    h = ThreadLocalRandom.advanceProbe(h);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp; <span class="hljs-comment">//cellsBusy互斥变量</span><br>         U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//类似加锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                          <br>        <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<span class="hljs-comment">//x元素个数</span><br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">//释放</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, v = baseCount, v + x))<br>       <span class="hljs-keyword">break</span>;    <br></code></pre></td></tr></table></figure><h4 id="（4）扩容阶段"><a href="#（4）扩容阶段" class="headerlink" title="（4）扩容阶段"></a>（4）扩容阶段</h4><blockquote><ul><li>元素个数大于数组长度</li><li>此时正在扩容，扩容阶段进入的线程会协助扩容</li><li>数组长度大于64，链表长度大于等于8</li></ul></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676623721593-aa8ae0d6-3506-4f56-bb2b-83a03790508c.jpeg"><br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676625648415-a3614e4e-425d-4dda-bde7-8566d7b696f7.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>    Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>     <span class="hljs-comment">//添加元素大于阈值，需要扩容</span><br>    <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>           (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">    rs二进制：</span><br><span class="hljs-comment">    0000 0000 0000 0000  1000 0000 0001 1100</span><br><span class="hljs-comment">        rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2：</span><br><span class="hljs-comment">        1000 0000 0001 1100（扩容标记）  0000 0000 0000 0010（参与扩容线程数）</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>        <span class="hljs-comment">//表示已经有线程正在扩容</span><br>        <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//表示不需要协助扩容</span><br>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//需要协助扩容，sc记录参与扩容的线程数</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<span class="hljs-comment">//sc二进制运算</span><br>                transfer(tab, nt);<br>        &#125;<br>        <span class="hljs-comment">//没有线程在扩容，第一次扩容+2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                     (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<span class="hljs-comment">//左移16位，最高位为1</span><br>            transfer(tab, <span class="hljs-literal">null</span>);<span class="hljs-comment">//第一次扩容</span><br>        s = sumCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        nextTable = <span class="hljs-literal">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        finishing = advance = <span class="hljs-literal">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//tab获取数组下标</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br></code></pre></td></tr></table></figure><hr><h2 id="17、线程池"><a href="#17、线程池" class="headerlink" title="17、线程池"></a>17、线程池</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676881404884-9dabf803-5f24-4524-bfbf-a229ae7ebc26.jpeg"></p><h4 id="（1）线程池构建（ThreadPoolExecutor）"><a href="#（1）线程池构建（ThreadPoolExecutor）" class="headerlink" title="（1）线程池构建（ThreadPoolExecutor）"></a>（1）线程池构建（ThreadPoolExecutor）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>【1】int corePoolSize：线程池中一直维护的线程数量，如果线程池处于任务空闲期间，该线程不会被回收调掉；<br>【2】int maximumPoolSize：线程池中所维护线程数的最大数量；<br>【3】long keepAlivePoolSize：临时线程存活时间，超过corePoolSize的线程在金经过KeepAliveTime时间后如果一直处于空闲状态，那么超过的线程将会被回收掉；<br>【4】TimeUnit unit： keepAlivePoolSize的时间单位；<br>【5】BlockingQueue<Runable> workQueue：向先池所提交的任务位于的阻塞队列，实现有多种；<br>【6】ThreadFactory threadFactory：线程工厂，用于创建新的线程并被线程池管理，默认线程工厂所创建的线程都是用户线程且优先级为正常优先级；<br>【7】RejectdExecutionHandler hadler：表示当前线程都在忙于执行任务，并且阻塞队列已满的情况下,新到来的任务该如何对待和处理（拒绝策略）；</p><h4 id="（2）拒绝策略："><a href="#（2）拒绝策略：" class="headerlink" title="（2）拒绝策略："></a>（2）拒绝策略：</h4><p>【1】AbortPolicy：直接抛出一个运行异常；<br>【2】DiscardPolicy：默默丢弃提交任务，不做任何处理，且不抛出异常<br>【3】DiscardOldestPolicy：丢弃阻塞队列中存放时间久的任务（队头元素），并且为当前所提交的任务留出一个队列空闲空间，将其放入队列；<br>【4】CallerRunsPolicy：直接由提交任务的线程来运行这个提交的任务（调用run方法）；</p><h4 id="（3）线程池总体策略"><a href="#（3）线程池总体策略" class="headerlink" title="（3）线程池总体策略"></a>（3）线程池总体策略</h4><p>【1】如果线程池正在执行的线程数&lt;corePoolSize，那么线程池就会优先选择新创建的线程来执行任务，而非将提交的任务加到阻塞队列中；<br>【2】如果线程中正在执行的线程数&gt;&#x3D;corePoolSize，那么线程池就会优先选择对提交的任务进行阻塞排队，而非创建新的线程；<br>【3】如果提交的任务无法加入到阻塞队列中，那么线程池就会创建新的线程，如果创建的线程数超过maximumPoolSize，那么拒绝策略起作用；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670121958931-07f8a0f8-28a7-4e81-825c-8232593fd147.jpeg"></p><h4 id="（4）线程池维护状态"><a href="#（4）线程池维护状态" class="headerlink" title="（4）线程池维护状态"></a>（4）线程池维护状态</h4><p>【1】线程池本身状态：ctl高三位来表示<br>【2】线程池中所运行线程数量：ctl其余29位表示；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669970187950-8b76846b-f686-4037-badc-f4697b6876e2.png#averageHue=%23312c2b&clientId=u25dde710-cfe6-4&from=paste&height=333&id=u636c975e&name=image.png&originHeight=499&originWidth=1236&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111066&status=done&style=none&taskId=u267e61fc-3ef3-4514-b2bb-b43dc75876e&title=&width=824" alt="image.png"><br>【3】RUNNING ：线程池可以接收新的任务提交，并且可以正常处理阻塞队列中的任务；<br>【4】SHUTDOWN ：不再接收新的任务提交，不过线程池可以正常处理阻塞队列中的任务；<br>【5】STOP ：不在接收新的任务，同时丢弃阻塞队列中的任务，中断正在处理中的任务；<br>【6】TIDYING ：所有任务都执行完毕后（包括阻塞队列中的任务），当前线程中的活动的线程数量降为0，调用terminated方法；<br>【7】TERMINATED ：线程终止状态，当terminated方法执行完毕后，线程池会处于该状态之下；<br>【8】RUNNING  -&gt;  SHUTDOWN :当调用线程池shutdown方法时，或者调用finalize方法后（该放啊内部调用shutdown方法）；<br>【9】RUNNING， SHUTDOWN  -&gt; STOP：当调用线程池shutdownNow方法；<br>【10】SHUTDOWN -&gt; TIDYING：在线程池与阻塞队列均为空时；<br>【11】STOP -&gt; TIDYING：线程池为空时；<br>【12】TIDYING -&gt; TERMINATED：在terminated方法执行完毕后。</p><h4 id="（5）线程池任务提交"><a href="#（5）线程池任务提交" class="headerlink" title="（5）线程池任务提交"></a>（5）线程池任务提交</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1676965819589-aaa286ce-593a-4435-bd3e-d076f839f7ed.jpeg"><br>【1】两种提交方式：submit和execute<br>【2】submit三种提交方式，无论哪种方式，最终将转换来的任务转换为一个Callable对象来处理；<br>【3】当Callable对象构造完毕后，最终会调用Executor接口声明的execute方法执行；<br>【4】execute方法源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//创建线程</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//线程执行体添加到阻塞队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//线程没有running，移除任务成功</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//队列满，线程超过最大值，拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669972706060-70e0316e-8a01-4138-9039-84cba22e6e6a.png#averageHue=%233c2a29&clientId=u25dde710-cfe6-4&from=paste&height=156&id=VmxPh&name=image.png&originHeight=213&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52387&status=done&style=none&taskId=ucad5ed71-b5c3-4d53-937d-038bdb194c4&title=&width=661.3333740234375" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669972977105-1a7e85dc-8dea-45c3-86b9-1ea70124e53b.png#averageHue=%233b2b29&clientId=u25dde710-cfe6-4&from=paste&height=151&id=SsQps&name=image.png&originHeight=226&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59038&status=done&style=none&taskId=uba3cdabc-b359-48a7-81e9-18a38f7addf&title=&width=714.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669973182483-f35fa7c7-4537-4e6b-b1bf-7379e7e274ce.png#averageHue=%23372b29&clientId=u25dde710-cfe6-4&from=paste&height=66&id=Ek0b3&name=image.png&originHeight=99&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16832&status=done&style=none&taskId=uba6cafc1-343d-4e26-997e-5a678a0d8f7&title=&width=681.3333333333334" alt="image.png"><br>【5】addWorker（）方法分析：创建线程并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">//增加线程数量</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">//判断线程是否处于终止状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<span class="hljs-comment">//获取线程数量</span><br>            <span class="hljs-comment">//判断线程数量是否超出</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//false表示阻塞队列满</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//修改线程数量</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//创建一个线程</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            <span class="hljs-comment">//加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    <span class="hljs-comment">//hashSet存储工作线程</span><br>                    workers.add(w);<br>                    <span class="hljs-comment">//更新线程最大数量</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">//添加失败，删除线程</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669974720384-49450031-dcaa-4579-83dc-62fa3ed22396.png#averageHue=%23372b2a&clientId=u25dde710-cfe6-4&from=paste&height=249&id=KT9nk&name=image.png&originHeight=373&originWidth=1112&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69700&status=done&style=none&taskId=u3612d9df-1a11-4d2a-bac1-130d37a1634&title=&width=741.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669975033802-f68e03ba-5035-48c1-af9f-20b4e2becb7b.png#averageHue=%23342b2a&clientId=u25dde710-cfe6-4&from=paste&height=293&id=nywvK&name=image.png&originHeight=440&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75543&status=done&style=none&taskId=u35c54005-91fa-4368-ad0d-07cd1ce7ea8&title=&width=696.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669975635302-eee9bee7-0f10-4533-9d38-72e5dfc618e9.png#averageHue=%232e2b2b&clientId=u25dde710-cfe6-4&from=paste&height=424&id=RZKrH&name=image.png&originHeight=636&originWidth=1193&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91649&status=done&style=none&taskId=u78e95b9c-c07c-4c0a-984a-d6a3fee5d8f&title=&width=795.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669975684605-f54f5a24-406e-4efc-8673-edc291cb42a1.png#averageHue=%23362a29&clientId=u25dde710-cfe6-4&from=paste&height=104&id=fKjf8&name=image.png&originHeight=137&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18171&status=done&style=none&taskId=u0fbc3536-6ec0-4bb0-89a0-707c0040c9e&title=&width=663.3333740234375" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1669975879037-41800bed-72a5-4871-862f-ff0015da6f7e.png#averageHue=%23352a29&clientId=u25dde710-cfe6-4&from=paste&height=95&id=Yayxy&name=image.png&originHeight=143&originWidth=1073&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20417&status=done&style=none&taskId=u03fd4db4-a20b-439b-accf-423bb8ed569&title=&width=715.3333333333334" alt="image.png"></p><h4 id="（6）线程池任务的执行流程（Worker的run方法）"><a href="#（6）线程池任务的执行流程（Worker的run方法）" class="headerlink" title="（6）线程池任务的执行流程（Worker的run方法）"></a>（6）线程池任务的执行流程（Worker的run方法）</h4><p>getTask（）从阻塞队列获取队头任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 线程数量大于核心数量，返回null，回收线程</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">//工作线程大于最大线程或核心线程数，工作线程减1</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//工作线程减一</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                <span class="hljs-comment">//阻塞队列为空，</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                <span class="hljs-comment">//获取不到数据，线程阻塞（工作线程数小于核心线程数）</span><br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runWorker（）执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//任务不为空，为空，线程结束（线程销毁）</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//任务执行，任务为实现Runable的run方法</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670121153322-91d2184e-9a45-45c6-b35e-4c66ff5b3ec7.png#averageHue=%233a2c2a&clientId=ubcda59a6-d1c5-4&from=paste&height=199&id=u3abb8469&name=image.png&originHeight=298&originWidth=993&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62143&status=done&style=none&taskId=u3fce06dd-00b4-4f62-9c88-88c127b8497&title=&width=662" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670122455105-ab6ac25b-633b-4324-b43b-1313b310f505.png#averageHue=%23312b2a&clientId=ubcda59a6-d1c5-4&from=paste&height=308&id=u718ffaac&name=image.png&originHeight=462&originWidth=1026&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62175&status=done&style=none&taskId=ued251ef2-cd84-4d8f-b7ee-1fbd88b9eca&title=&width=684" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670123734061-0fbc2d42-05be-4eea-8cd7-e6e0bb3c6cb3.png#averageHue=%232e2b2a&clientId=ubcda59a6-d1c5-4&from=paste&height=217&id=u26b22d8f&name=image.png&originHeight=326&originWidth=1054&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33992&status=done&style=none&taskId=u0bcb28bf-4b7b-471f-b600-f34f5a70292&title=&width=702.6666666666666" alt="image.png"></p><h4 id="（7）线程池终止"><a href="#（7）线程池终止" class="headerlink" title="（7）线程池终止"></a>（7）线程池终止</h4><p>【1】shutdown（）方法：拒绝新任务提交，会继续执行完阻塞队列中的任务后，才会进入终止状态；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670125866010-06fdfda4-bda2-4ed8-83d8-f15e216282ac.png#averageHue=%232f2c2b&clientId=ubcda59a6-d1c5-4&from=paste&height=280&id=u0e003a91&name=image.png&originHeight=420&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55027&status=done&style=none&taskId=ua49fff4b-fec8-448d-be72-8455a5a4317&title=&width=697.3333333333334" alt="image.png">interruptIdleWorkers()方法<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670125977119-c29d7e86-a4e1-4e42-b476-5c39a9e680c4.png#averageHue=%232f2b2b&clientId=ubcda59a6-d1c5-4&from=paste&height=451&id=u2356a4d6&name=image.png&originHeight=676&originWidth=1154&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74959&status=done&style=none&taskId=uc392fc02-be34-4d33-86d4-525f7ff978d&title=&width=769.3333333333334" alt="image.png"><br>tryTerminate()方法<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670126228798-5b52b5b0-ceb4-4702-a4eb-7aeb3502881b.png#averageHue=%232e2b2a&clientId=ubcda59a6-d1c5-4&from=paste&height=326&id=uf9eb4599&name=image.png&originHeight=489&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53626&status=done&style=none&taskId=u367c06ff-b236-45a9-921b-8c0bb5a3abb&title=&width=649.3333333333334" alt="image.png"><br>【2】shutdownNow（）方法：拒绝新任务提交，停止所有正在执行任务的线程；<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670126474385-b007a026-dbc2-49ff-91fe-d80ace8924de.png#averageHue=%23322b2b&clientId=ubcda59a6-d1c5-4&from=paste&height=327&id=u015ac2e6&name=image.png&originHeight=491&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71222&status=done&style=none&taskId=u212a5099-ea0a-486f-85c7-79074cbfffb&title=&width=758" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670126529629-af783a19-dcf5-4ea9-9a7b-e0515dfef822.png#averageHue=%232f2c2b&clientId=ubcda59a6-d1c5-4&from=paste&height=255&id=u61f23055&name=image.png&originHeight=383&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50889&status=done&style=none&taskId=u5d8a8c88-816a-4e83-ae60-07254063ba7&title=&width=695.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29496365/1670126587417-9f6e2672-0fb3-4262-85a7-f8fe9e1ffd60.png#averageHue=%23302b2a&clientId=ubcda59a6-d1c5-4&from=paste&height=221&id=u0b432a74&name=image.png&originHeight=331&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38267&status=done&style=none&taskId=u76298200-be9c-42bb-aa8e-12731c88adc&title=&width=689.3333333333334" alt="image.png"></p><h4 id="（8）ForkJoinPool线程池"><a href="#（8）ForkJoinPool线程池" class="headerlink" title="（8）ForkJoinPool线程池"></a>（8）ForkJoinPool线程池</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670139123804-e4dec0e9-c1dd-421b-b116-0eeb1b740a41.jpeg"></p><h4 id="（9）CompletableFuture"><a href="#（9）CompletableFuture" class="headerlink" title="（9）CompletableFuture"></a>（9）CompletableFuture</h4><h5 id="①thenApply源码"><a href="#①thenApply源码" class="headerlink" title="①thenApply源码"></a>①thenApply源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">uniApplyStage</span><span class="hljs-params">(</span><br><span class="hljs-params">    Executor e, Function&lt;? <span class="hljs-built_in">super</span> T,? extends V&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;V&gt; d =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;V&gt;();<br>    <span class="hljs-comment">//e:一步调用直接执行</span><br>    <span class="hljs-comment">//uniApply任务执行失败，需要入栈</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniApply(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniApply&lt;T,V&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        <span class="hljs-comment">//尝试执行任务</span><br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> &lt;S&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniApply</span><span class="hljs-params">(CompletableFuture&lt;S&gt; a,</span><br><span class="hljs-params">                           Function&lt;? <span class="hljs-built_in">super</span> S,? extends T&gt; f,</span><br><span class="hljs-params">                           UniApply&lt;S,T&gt; c)</span> &#123;<br>    Object r; Throwable x;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || (r = a.result) == <span class="hljs-literal">null</span> || f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    tryComplete: <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> AltResult) &#123;<br>            <span class="hljs-keyword">if</span> ((x = ((AltResult)r).ex) != <span class="hljs-literal">null</span>) &#123;<br>                completeThrowable(x, r);<br>                <span class="hljs-keyword">break</span> tryComplete;<br>            &#125;<br>            r = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; !c.claim())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) r;<br>            <span class="hljs-comment">//执行任务，并将结果写入result</span><br>            completeValue(f.apply(s));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            completeThrowable(ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②thenAcceptAsync源码（异步执行）"><a href="#②thenAcceptAsync源码（异步执行）" class="headerlink" title="②thenAcceptAsync源码（异步执行）"></a>②thenAcceptAsync源码（异步执行）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">uniAcceptStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                               Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;Void&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;Void&gt;();<br>    <span class="hljs-comment">//异步调用，e不为null，执行压入栈顶</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniAccept(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniAccept&lt;T&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,Void&gt; &#123;<br>    Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn;<br>    UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,<br>              CompletableFuture&lt;T&gt; src, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn) &#123;<br>        <span class="hljs-built_in">super</span>(executor, dep, src); <span class="hljs-built_in">this</span>.fn = fn;<br>    &#125;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">tryFire</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span> &#123;<br>        CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;<br>         <span class="hljs-comment">//dep为null，任务已经执行过</span><br>        <span class="hljs-comment">//uniAccept为false表示任务可能已被其他线程执行</span><br>        <span class="hljs-keyword">if</span> ((d = dep) == <span class="hljs-literal">null</span> ||<br>            !d.uniAccept(a = src, fn, mode &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : <span class="hljs-built_in">this</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dep = <span class="hljs-literal">null</span>; src = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//任务已经完成，继续执行前一个任务</span><br>        <span class="hljs-keyword">return</span> d.postFire(a, mode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">postFire</span><span class="hljs-params">(CompletableFuture&lt;?&gt; a, <span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; a.stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//前一个任务执行完毕</span><br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span> || a.result == <span class="hljs-literal">null</span>)<br>            a.cleanStack();<span class="hljs-comment">//任务出栈</span><br>        <span class="hljs-keyword">else</span><br>            a.postComplete();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span><br>            postComplete();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③supplyAsync源码"><a href="#③supplyAsync源码" class="headerlink" title="③supplyAsync源码"></a>③supplyAsync源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                                 Supplier&lt;U&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncSupply</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, AsynchronousCompletionTask &#123;<br>        CompletableFuture&lt;T&gt; dep;<span class="hljs-comment">//</span><br>        Supplier&lt;T&gt; fn;<span class="hljs-comment">//执行逻辑</span><br>        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;<br>            <span class="hljs-built_in">this</span>.dep = dep; <span class="hljs-built_in">this</span>.fn = fn;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123; run(); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;<br>            <span class="hljs-keyword">if</span> ((d = dep) != <span class="hljs-literal">null</span> &amp;&amp; (f = fn) != <span class="hljs-literal">null</span>) &#123;<br>                dep = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//result为任务执行完后的结果，为null表示未完成结果</span><br>                <span class="hljs-keyword">if</span> (d.result == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        d.completeValue(f.get());<span class="hljs-comment">//等待任务结束并设置结果</span><br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                        d.completeThrowable(ex);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//任务执行完成，执行所有依赖改任务的所有任务</span><br>                d.postComplete();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postComplete</span><span class="hljs-params">()</span> &#123;<br>    CompletableFuture&lt;?&gt; f = <span class="hljs-built_in">this</span>; <br>    Completion h;<br>    <span class="hljs-keyword">while</span> ((h = f.stack) != <span class="hljs-literal">null</span> ||<br>           (f != <span class="hljs-built_in">this</span> &amp;&amp; (h = (f = <span class="hljs-built_in">this</span>).stack) != <span class="hljs-literal">null</span>)) &#123;<br>        CompletableFuture&lt;?&gt; d; <br>        Completion t;<span class="hljs-comment">//保存的是依靠当前CompletableFuture的任务</span><br>        <span class="hljs-keyword">if</span> (f.casStack(h, t = h.next)) &#123;<span class="hljs-comment">//获取栈中下一个Completion</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当前的CompletableFuture不是this的，将所有Completion加入当前栈中</span><br>                <span class="hljs-keyword">if</span> (f != <span class="hljs-built_in">this</span>) &#123;<br>                    pushStack(h);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                h.next = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 为当前CompletableFuture，解除联系</span><br>            &#125;<br>            f = (d = h.tryFire(NESTED)) == <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span> : d;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个CompletableFuture持有一个Completion栈stack, 每个Completion持有一个CompletableFuture， 如此递归循环下去，是层次很深的树形结构，所以想办法将其变成链表结构。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29496365/1677058693628-12e94f36-1114-40b6-9864-1fe0b9ff1b35.webp#averageHue=%23f6ebdc&clientId=udc49f82a-3194-4&from=paste&id=u46e4d02d&originHeight=923&originWidth=1775&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u15af37ce-ea8e-4b6e-a061-db981afb536&title="><br>首先取出头结点，下图中灰色Completion结点，它会返回一个CompletableFuture, 同样也拥有一个stack，策略是遍历这个CompletableFuture的stack的每个结点，依次压入到当前CompletableFuture的stack中，关系如下箭头所示，灰色结点指的是处理过的结点。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29496365/1677058706103-db065756-9b0e-43b9-acd4-05afa156fc69.webp#averageHue=%23f6ecde&clientId=udc49f82a-3194-4&from=paste&id=u7c089b54&originHeight=933&originWidth=1775&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ue810852b-f463-4699-aae7-c38c376c2ca&title="><br>第一个Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29496365/1677058717485-4eabee00-7b40-417b-9950-774107d7f9d1.webp#averageHue=%23f5ede2&clientId=udc49f82a-3194-4&from=paste&id=uaef38460&originHeight=950&originWidth=1775&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud3b50550-cb0e-4d9b-a849-d08269145b1&title="><br>后续的Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面，重新构成了一个链表结构，后续也按照前面的逻辑操作，如此反复，便会遍历完所有的CompletableFuture, 这些CompletableFuture(叶子结点)的stack为空，也是结束条件。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29496365/1677058730044-52d6f0ed-8896-4a49-86dc-51d8c17aa13e.webp#averageHue=%23f1efed&clientId=udc49f82a-3194-4&from=paste&id=uad13c6ba&originHeight=950&originWidth=1718&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u2bfe8877-080b-4587-b1c3-1ca2543e36a&title="></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java遗传算法组卷</title>
    <link href="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/"/>
    <url>/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<p>遗传算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/17/hello-world/"/>
    <url>/2023/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
