<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2023/04/10/Netty/"/>
    <url>/2023/04/10/Netty/</url>
    
    <content type="html"><![CDATA[<h3 id="1、I-x2F-O模型"><a href="#1、I-x2F-O模型" class="headerlink" title="1、I&#x2F;O模型"></a>1、I&#x2F;O模型</h3><h4 id="（1）同步阻塞I-x2F-O（BIO）"><a href="#（1）同步阻塞I-x2F-O（BIO）" class="headerlink" title="（1）同步阻塞I&#x2F;O（BIO）"></a>（1）同步阻塞I&#x2F;O（BIO）</h4><blockquote><ol><li><p>应用进程向内核发起I&#x2F;O请求，发起调用后一直等待内核数据返回；</p></li><li><p>一次请求对应一个线程，创建过多线程会增加线程切换开销；</p></li><li><p>BIO在异步操作下，只能使用多线程模型；</p><img src="/2023/04/10/Netty/1.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（2）同步非阻塞（NIO）"><a href="#（2）同步非阻塞（NIO）" class="headerlink" title="（2）同步非阻塞（NIO）"></a>（2）同步非阻塞（NIO）</h4><blockquote><ol><li><p>应用进程向内核发起请求后，不会同步等待结果，而是立即返回，通过轮询获取请求结果；</p></li><li><p>轮询过程中会导致大量的性能开销，单独使用NIO性能不高；</p></li><li><p>并发量大的情况下，存在严重的IO性能浪费；</p><img src="/2023/04/10/Netty/2.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（3）IO多路复用"><a href="#（3）IO多路复用" class="headerlink" title="（3）IO多路复用"></a>（3）IO多路复用</h4><blockquote><ol><li><p>多路指多个数据通道，一个或多个固定线程来处理每一个socket链接；</p></li><li><p>线程一次select可以获取内核中多个数据通道的数据状态；</p><img src="/2023/04/10/Netty/3.jpg" class="" title="Netty"></li></ol></blockquote><h4 id="（4）异步IO（AIO）"><a href="#（4）异步IO（AIO）" class="headerlink" title="（4）异步IO（AIO）"></a>（4）异步IO（AIO）</h4><blockquote><p>由内核缓冲区拷贝到用户缓冲区是由系统异步完成的，应用进程只需在指定的数组中引用数据即可；</p><img src="/2023/04/10/Netty/4.jpg" class="" title="Netty"></blockquote><h4 id="（5）Netty-IO模型"><a href="#（5）Netty-IO模型" class="headerlink" title="（5）Netty IO模型"></a>（5）Netty IO模型</h4><blockquote><ol><li><p>所有I&#x2F;O事件都注册到一个Selector上，当I&#x2F;O事件就绪后，有一个事件分发处理器，负责将读写请求分发给对应的读写事件处理器；</p></li><li><p>该线程模型避免了同步问题和线程切换带来的开销问题，实现高性能，低延迟；</p></li><li><p>可定制化线程模型，可扩展事件驱动模型；</p><img src="/2023/04/10/Netty/5.jpg" class="" title="Netty"></li></ol></blockquote><h3 id="2、Netty逻辑架构"><a href="#2、Netty逻辑架构" class="headerlink" title="2、Netty逻辑架构"></a>2、Netty逻辑架构</h3><img src="/2023/04/10/Netty/6.jpg" class="" title="Netty"><h4 id="（1）网络通信层"><a href="#（1）网络通信层" class="headerlink" title="（1）网络通信层"></a>（1）网络通信层</h4><blockquote><ul><li>网络通信层支持多种网络协议和I&#x2F;O操作连接，当网络数据读取到内核缓冲区后，会触发各种网络事件，网络事件会分发事件调度层处理；</li><li>三大核心组件为Bootstrap、ServerBootstrap、Channel；</li><li>Bootstrap用于客户端启动引导，可用户连接远端服务器，只绑定一个EventLoopGroup；</li><li>ServerBootstrap用于服务端启动引导，绑定本地端口，绑定两个EventLoopGroup，一个用于接收请求转发，另一个用于请求事件处理；</li><li>Channel为网络通信的载体，channel有多种状态，如连接建立、连接注册、数据读写、连接销毁，随着状态变化，Channel处于不同的生命周期，会绑定不同的回调事件；</li></ul></blockquote><h4 id="（2）事件调度层"><a href="#（2）事件调度层" class="headerlink" title="（2）事件调度层"></a>（2）事件调度层</h4><blockquote><ul><li>通过Reactor线程模型对各类事件进行聚合处理，通过Selector主循环线程集成多种事件，实际相关业务由服务编排层中相应的Handler进行处理；</li><li>事件调度层核心组件为EventLoopGroup和EventLoop，EventLoopGroup本质是一个线程池，负责接收I&#x2F;O请求，并分配线程执行请求；</li><li>EventLoop、EventLoopGroup、Channel关系：</li></ul><ol><li><ol><li><p>一个EvntLoopGroup中包含多个EventLoop，EventLoop负责处理Channel生命周期内所有的I&#x2F;O事件；</p></li><li><p>EventLoop同一时间会绑定一个线程，负责处理多个Channel；</p></li><li><p>每一个新建的Channel，EventLoopGroup会选择一个EventLoop与其绑定，Channel生命周期内可以多次对EventLoop进行解绑和绑定；</p><img src="/2023/04/10/Netty/7.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><h4 id="（3）服务编排层"><a href="#（3）服务编排层" class="headerlink" title="（3）服务编排层"></a>（3）服务编排层</h4><blockquote><ul><li>负责组装各类服务，是Netty的核心处理链，用于实现网络的动态编排和有序传播；</li><li>ChannelPipeline</li></ul><ol><li><ol><li><p>负责组装各类ChannelHandler，实际数据的编码以及数据加工处理都是由ChannelHandler执行的；</p></li><li><p>是ChannelHandler实例列表，通过双向链表将不同ChannelHandler连接起来，当I&#x2F;O事件触发时，ChannelPipeline会依次调用ChannelHandler列表对Channel数据依次处理；</p></li><li><p>ChannelPipeline是线程安全的，一个EventLoop对应一个ChannelPipeline，一个EventLoop绑定一个线程；</p></li><li><p>ChannelPipeline包含入站ChannelInboundHandler和出站ChannelOutboundHandler处理器，服务端和客户端依次完整的数据请求响应：客户端出战（请求数据）-&gt;服务端入站（服务端业务处理）-&gt;服务端出站（响应结果）；</p><img src="/2023/04/10/Netty/8.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><blockquote><ul><li>ChannelHandler和ChannelHandlerContext：</li></ul><ol><li><ol><li><p>每创建一个Channel，会绑定一个CHannelPipeline；</p></li><li><p>ChannelPipeline每加入一个ChannelHandler都会绑定一个ChannelHandlerContext；</p></li><li><p>ChannelHandlerContext保存了ChannelHandler上下文（即运行环境），ChannelHandlerContext包含ChannelHandler生命周期所有事件（减少代码冗余）；</p><img src="/2023/04/10/Netty/9.jpg" class="" title="Netty"></li></ol></li></ol></blockquote><h4 id="（4）组件协作协作流程"><a href="#（4）组件协作协作流程" class="headerlink" title="（4）组件协作协作流程"></a>（4）组件协作协作流程</h4><blockquote><ol><li><p>服务启动时，创建Boss EventLoopGroup和Work EventLoopGroup，Boss负责监听网络事件，当有连接到达时，会将channel注册到work中；</p></li><li><p>work分配一个EventLoop负责处理Channel读写事件，每隔EventLoop是单线程，通过selector进行事件循环；</p></li><li><p>当客户端发起I&#x2F;O读写事件时，EventLoop会读取客户端数据，然后通过pipeLine触发各种监听器进行数据处理；</p></li><li><p>客户端数据被传入到ChannelPipeline的第一个ChannelInBoundHandler进行处理，然后传递给下一个；</p></li><li><p>服务端响应数据，通过ChannelOutBoundHandler传播，最终到达客户端；</p><img src="/2023/04/10/Netty/10.jpg" class="" title="Netty"></li></ol></blockquote><h3 id="3、Netty启动流程"><a href="#3、Netty启动流程" class="headerlink" title="3、Netty启动流程"></a>3、Netty启动流程</h3><h4 id="（1）配置线程池"><a href="#（1）配置线程池" class="headerlink" title="（1）配置线程池"></a>（1）配置线程池</h4><blockquote><ul><li>单线程模式：配置时，指定NioEventLoopGroup参数为1，只有一个线程完成；</li><li>多线程模型：采用多个线程处理请求，NioEventLoopGroup参数不指定，线程数默认为CPU核数*2；</li><li>主从多线程模型：采用两个NioEventLoopGroup，主Reactor负责接收请求，将Channel主从到从Reactor中，从Reactor负责处理Channel生命周期内的所有I&#x2F;O事件；</li></ul></blockquote><h4 id="（2）Channel初始化"><a href="#（2）Channel初始化" class="headerlink" title="（2）Channel初始化"></a>（2）Channel初始化</h4><blockquote><ul><li>设置Channel类型，服务端推荐NioServerSocketChannel；</li><li>注册ChannelHandler，通过设置ServerBootstrap的childHandler参数。ChannelInitalizer是实现ChannelHandler的内部匿名类，主要用于初始化和注册各ChannelHandler；</li><li>设置Channel参数，option和childOption，option参数设置Boss线程组，childOption设置Worker线程组，具体设置参数如下：</li></ul></blockquote><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>SO_KEEPALIVE</td><td>TCP主动探测状态，连接保活</td></tr><tr><td>SO_BACKLOG</td><td>已完成三次握手的最大长度，同一时刻可能处理多个连接，歌颂并发下该参数应该调大</td></tr><tr><td>CONNECT_TIMEOUT_MILLIS</td><td>建立连接的超时时间</td></tr></tbody></table><h4 id="（3）端口绑定"><a href="#（3）端口绑定" class="headerlink" title="（3）端口绑定"></a>（3）端口绑定</h4><blockquote><p>serverGroup.bind(端口).sync()，bind真正触发启动，sync会阻塞，直至整个启动完成；</p></blockquote><h3 id="4、EventLoop"><a href="#4、EventLoop" class="headerlink" title="4、EventLoop"></a>4、EventLoop</h3><blockquote><ul><li><p>是一种事件等待和处理的模型，可以解决多线程资源消耗高的问题；</p></li><li><p>事件发生时，应用程序会将事件放入到事件队列中，EventLoop会进行轮询，取出已经准备好的事件并分发给对应的事件处理器处理，事件分为：立即执行，延迟执行和定期执行；</p></li><li><p>每个EventLoop都维护一个Selector选择器和任务队列taskQueue，主要负责处理处理I&#x2F;O事件，普通任务，定时任务；</p><img src="/2023/04/10/Netty/11.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（1）事件处理机制"><a href="#（1）事件处理机制" class="headerlink" title="（1）事件处理机制"></a>（1）事件处理机制</h4><blockquote><ul><li><p>NioEventLoop事件处理机制采用无锁串行化，保证线程安全；</p></li><li><p>BossEventLoopGroup和WorkEventGroup包含多个NipEventLoop；</p></li><li><p>Boss负责监听客户端连接事件，一旦连接建立，Boss将channel注册到Work中的一个NioEventLoop，channel生命周期所有事件处理是线程独立的；</p></li><li><p>NioEventLoop读取完数据后，会调用绑定的ChannelPipelie，ChannelPIpeline是串行化执行，不会发生线程上下文切换，所以是线程安全的；</p></li><li><p>NioEventLoop不能执行事件过长的I&#x2F;O事件，一旦I&#x2F;O阻塞，会阻塞后面所有I&#x2F;O，造成事件积压；</p><img src="/2023/04/10/Netty/12.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）任务处理机制"><a href="#（2）任务处理机制" class="headerlink" title="（2）任务处理机制"></a>（2）任务处理机制</h4><blockquote><ol><li>普通任务：通过NioEvenLoop的execute（）方法，向任务队列taskQueue中添加任务，任务队列是FIFO。taskQueue是多生产者单消费者，在多线程下可以保证线程安全；</li><li>定时任务：通过NIoEventLoop的schduled（）方法，向定时任务队列SchduledQueue添加任务，任务队列是优先队列，用于周期性执行，如心跳检查机制；</li><li>尾部队列：相比普通队列，优先级较低，每次执行完taskQueue后，会取出taskQueue最后一个任务执行，该任务主要是负责收尾工作，如：监控信息上报等；</li></ol></blockquote><h4 id="（3）最佳实践"><a href="#（3）最佳实践" class="headerlink" title="（3）最佳实践"></a>（3）最佳实践</h4><blockquote><ol><li>网络连接建立三次握手比较耗费时间，采用Boos和Work可以，有助于缓解Reactor压力；</li><li>I&#x2F;O事件处理时间较长的，采用线程池进行异步处理，防止阻塞后边I&#x2F;O事件；</li><li>不要设计过多ChannelHandler；</li></ol></blockquote><h3 id="5、ChannelPipeline"><a href="#5、ChannelPipeline" class="headerlink" title="5、ChannelPipeline"></a>5、ChannelPipeline</h3><blockquote><ul><li><p>ChannelPipeline是ChannelHandler的容器载体，内部通过双向链表将ChannelHandler关联在一起；</p></li><li><p>当有IO读写时，会依次调用ChannelHandler对Channel拦截，进行数据处理；</p></li><li><p>一个Channel对应一个ChannelPipeline，一个ChannelPIpeline对应多个ChannelHandler；</p></li><li><p>ChannelHandlerContext保存了ChannelHandler的上下文（运行环境），同时包含了ChannelHandler的生命周期所有事件，如connect，bind等（减少2代码冗余，不用每一个ChannelHandler都写重复写conncet等生命周期事件）；</p><img src="/2023/04/10/Netty/13.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（1）ChannelPipeline链表结构"><a href="#（1）ChannelPipeline链表结构" class="headerlink" title="（1）ChannelPipeline链表结构"></a>（1）ChannelPipeline链表结构</h4><blockquote><ul><li><p>HeadContext既是Inboud处理器，又是Outbound处理器，网络操作数据的入口是HeadContext，进行Inbound事件传播。数据处理完后，会反方向经过Outbound处理器，最终到达HeadContext，即OutBound最后一站；HeadContext还会进行一些事件前置处理</p></li><li><p>TailContext是Outbound处理器，inbound事件的终止，将outbound事件传给上一站；</p></li><li><p>事件触发可以在中间的ChannelHandlerContext触发，事件执行不一定会从头到尾，提高程序性能；</p><img src="/2023/04/10/Netty/14.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）ChannelHandler事件传播机制"><a href="#（2）ChannelHandler事件传播机制" class="headerlink" title="（2）ChannelHandler事件传播机制"></a>（2）ChannelHandler事件传播机制</h4><blockquote><ul><li>inbound传播方向是从headContext-&gt;tailContext，客户端向服务端发送请求时，，会触发Inbound事件ChannelRead（）方法，最终调用writeAndFlush（）方法向客户端写回数据；</li><li>outbound传播方向是从tailContext-&gt;headContext，服务端写回数据时，会触发outbound事件的write()方法；</li></ul></blockquote><h4 id="（3）异常传播机制"><a href="#（3）异常传播机制" class="headerlink" title="（3）异常传播机制"></a>（3）异常传播机制</h4><blockquote><ul><li><p>发送异常时，若用户没有进行处理，最终会从Head传播到Tail，由tail进行处理；</p></li><li><p>处理异常的最好方法是，自定义处理器的末端加上统一异常处理器；</p><img src="/2023/04/10/Netty/15.jpg" class="" title="Netty"></li></ul></blockquote><h3 id="6、解码器"><a href="#6、解码器" class="headerlink" title="6、解码器"></a>6、解码器</h3><h4 id="（1）粘包和拆包"><a href="#（1）粘包和拆包" class="headerlink" title="（1）粘包和拆包"></a>（1）粘包和拆包</h4><blockquote><ul><li><p>MTU：链路层一次传输数据的最大单元，默认1500字节；</p></li><li><p>MSS：传输层一次传输数据的最大单元，即TCP报文；</p></li><li><p>MTU&lt;MSS+TCP首部+IP首部，就会进行拆包；</p></li><li><p>一次传输的数据单元过小，会进行批量发送；</p></li><li><p>TCP是面向流的，没有数据边界，客户端发送数据时，可能是拆分为多个包，，或者合并为一个包进行发送，接收方不知道数据的边界，无法得到有效数据；</p><img src="/2023/04/10/Netty/23.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li>滑动窗口：数据接收方设置的窗口大小，每次都会告知发送方自己的窗口大小，限制发送方发送数据的大小；数据发送不会每一个报文都回复ACK，是一段进行回复的，如发送A，B，C，报文A丢失，B，C到达，此时B，C报文会丢掉，当A，B，C都到达时，回复一个ACK；</li><li>Nagle算法：批量发送，发送数据时，数据还未确认，会先写入到缓冲区中，等到数据确认了或达到一定长度后就发送数据包，发送的数据会有一定的延迟性；</li></ul></blockquote><h4 id="（2）固定长度解码器FixedLengthFrameDecoder"><a href="#（2）固定长度解码器FixedLengthFrameDecoder" class="headerlink" title="（2）固定长度解码器FixedLengthFrameDecoder"></a>（2）固定长度解码器FixedLengthFrameDecoder</h4><blockquote><p>指定固定长度，无论接收方依次获取多大长度，都会按照指定长度进行解码</p></blockquote><h4 id="（3）特殊分割符解码器（DelimiterBasedFrameDecoder）"><a href="#（3）特殊分割符解码器（DelimiterBasedFrameDecoder）" class="headerlink" title="（3）特殊分割符解码器（DelimiterBasedFrameDecoder）"></a>（3）特殊分割符解码器（DelimiterBasedFrameDecoder）</h4><blockquote><ul><li>delimiter：指定分割符，可以同时指定多个分隔符，但最终只会选择最短的分隔符进行分割，如下：</li></ul><p>​      字符串：abc\njhg\n\r，指定分割符：\n,\n\r，最终字符：【abc,jhg】</p><ul><li>maxFrameLength：指定最大长度，若超过最大长度还没有进行字符分割，会抛出异常；</li><li>failFast：true，再超出maxFrameLength时，直接抛出异常否则等到解码出一个完整字符后，才抛出异常；</li><li>stripDelimiter：true为取出风格符，不加入编码，false加入编码</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DelimiterBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maxFrameLength, <span class="hljs-type">boolean</span> stripDelimiter, <span class="hljs-type">boolean</span> failFast,</span><br><span class="hljs-params">            ByteBuf delimiter)</span>&#123;.....&#125;<br></code></pre></td></tr></table></figure><h4 id="（4）长度域解码器LengthFielBasedFrameDecoder"><a href="#（4）长度域解码器LengthFielBasedFrameDecoder" class="headerlink" title="（4）长度域解码器LengthFielBasedFrameDecoder"></a>（4）长度域解码器LengthFielBasedFrameDecoder</h4><blockquote><ul><li>长度域解码器是解决粘包&#x2F;拆包最常用的解码器；</li><li>基于消息长度+消息内容解码：报文消息只有长度字段和具体消息，长度字段占两个字节，length中的0x000c表示Content占用12字节；</li></ul><img src="/2023/04/10/Netty/16.jpg" class="" title="Netty"><ul><li>解码结果需要截断：解码的结果只保留内容，将长度去除；</li></ul><img src="/2023/04/10/Netty/17.jpg" class="" title="Netty"><ul><li>长度包括消息长度和消息内容长度：length长度包含了length存储长度+消息内容长度（2+14），需要将length长度修正-2，才可以得消息内容的真正长度；</li></ul><img src="/2023/04/10/Netty/18.jpg" class="" title="Netty"><ul><li>基于长度字段的偏移：头部除了长度，还有header数据，所以length长度需要跳过Header 2字节，才是length的开始地址；</li></ul><img src="/2023/04/10/Netty/19.jpg" class="" title="Netty"><ul><li>长度字段与内容字段的长度不相邻：length字段记录的长度不会记录Header长度，</li></ul><p>​       length（2字节）+lengthFieldLength（12字节）&#x3D;Header1+Content（14字节）</p><img src="/2023/04/10/Netty/20.jpg" class="" title="Netty"><ul><li>基于长度偏移和长度修正解码：长度length的开始位置需要跳过HDR1，length的长度需要加上HDR2才能表示后面字段长度，结果需要跳过HDR1（1字节）+Length（2字节）&#x3D;3字节；</li></ul><img src="/2023/04/10/Netty/21.jpg" class="" title="Netty"><ul><li><p>长度字段包含所有字段长度解码：HDR2+Context长度需要减去length长度和HDR1长度</p><p>Length（16字节）&#x3D;HDR1（1字节）+Length（2字节）+HDR2（1字节）+Context（12字节）</p></li></ul><img src="/2023/04/10/Netty/22.jpg" class="" title="Netty"></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxFrameLength;<span class="hljs-comment">//最大限制长度</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldOffset;<span class="hljs-comment">//长度字段的偏移地址，即存放长度数据的开始地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldLength;<span class="hljs-comment">//长度字段占用的地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthFieldEndOffset;<span class="hljs-comment">//长度字段结束的偏移地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lengthAdjustment;<span class="hljs-comment">//消息体的长度修正值</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> initialBytesToStrip;<span class="hljs-comment">//消息体的开始地址</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> failFast;<span class="hljs-comment">//结合maxFrameLength使用，判断是否需要立即抛出异常</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> discardingTooLongFrame;<span class="hljs-comment">//是否处于丢弃模式</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> tooLongFrameLength;<span class="hljs-comment">//需要丢弃的字节数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> bytesToDiscard;<span class="hljs-comment">//累计丢弃的字节数</span><br></code></pre></td></tr></table></figure><h3 id="7、writeAndFlush"><a href="#7、writeAndFlush" class="headerlink" title="7、writeAndFlush"></a>7、writeAndFlush</h3><blockquote><ul><li>write只是将数据写入ChannelOutBoundBuffer中，并没有写入socket缓冲区中，buffer是链表结构存储；</li><li>flush最终将数据写入到socket缓冲区；</li></ul></blockquote><h4 id="（1）writeAndFlush源码分析"><a href="#（1）writeAndFlush源码分析" class="headerlink" title="（1）writeAndFlush源码分析"></a>（1）writeAndFlush源码分析</h4><blockquote><ul><li>findContextOutBound：寻找下一个ChannelHandler（双向链表结构，直接获取prev指针即可获取到）；</li><li>inEventLoop：判断当前的线程和EventLoop分配给channel的线程是否一样，一样的化继续立即执行，不一样，如果不一样，则是将任务加入到任务队列中；</li><li>invokeWritAndFlush：执行下一个ChannelHandler中的write方法，即我们自定义的handler处理器中的write方法，需要继续传递给下一个执行器执行，需要调用父类write方法，最终依旧调用以下write方法；</li><li>从tail开始调用，一次往前执行到head；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>代码忽略<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(flush ?<br>                                                                   (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pipeline.touch(msg, next);<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            next.invokeWriteAndFlush(m, promise);<span class="hljs-comment">//执行write</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    代码忽略<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeWriteAndFlush</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>            invokeWrite0(msg, promise);<span class="hljs-comment">//write</span><br>            invokeFlush0();<span class="hljs-comment">//flush</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            writeAndFlush(msg, promise);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）写Buffer队列："><a href="#（2）写Buffer队列：" class="headerlink" title="（2）写Buffer队列："></a>（2）写Buffer队列：</h4><blockquote><ul><li>所有数据写完，最终到head节点，由head节点将数据写给客户端；</li><li>filterOutboundMessage(msg)：判断msg类型是否DirectByteBuff，不是进行转换为DirectByteBuff；</li><li>addMessage(msg, size, promise)：往buffer中添加数据；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//HeadContext</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> &#123;<br>    assertEventLoop();<br>    <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>    <span class="hljs-comment">//代码忽略。。。。</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">try</span> &#123;<br>        msg = filterOutboundMessage(msg);<span class="hljs-comment">//过滤消息</span><br>        <span class="hljs-comment">//代码忽略。。。。。。。。。。。。</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       <span class="hljs-comment">//代码忽略。。。。。。。。。。。。</span><br>    &#125;<br>    outboundBuffer.addMessage(msg, size, promise);<span class="hljs-comment">//buffer中添加数据</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Buffer：</strong></p><ul><li><p>一个链表结构，消息会被封装为Entry对象，添加到链表中；</p></li><li><p>flushedEntry：第一个写入缓冲区指针；</p></li><li><p>unflushedEntry：第一个未写入缓冲区的指针；</p></li><li><p>tailEntry：最后一个未写入缓冲区的指针；</p><img src="/2023/04/10/Netty/24.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li>每次写都会累加字节数，判断是否超过64字节，超过则设置为不可写状态，直到恢复为32字节以下，才可以继续写</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addMessage</span><span class="hljs-params">(Object msg, <span class="hljs-type">int</span> size, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.newInstance(msg, size, total(msg), promise);<br>    <span class="hljs-keyword">if</span> (tailEntry == <span class="hljs-literal">null</span>) &#123;<br>        flushedEntry = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> tailEntry;<br>        tail.next = entry;<br>    &#125;<br>    tailEntry = entry;<br>    <span class="hljs-keyword">if</span> (unflushedEntry == <span class="hljs-literal">null</span>) &#123;<br>        unflushedEntry = entry;<br>    &#125;<br>    incrementPendingOutboundBytes(entry.pendingSize, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> invokeLater)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">newWriteBufferSize</span> <span class="hljs-operator">=</span> TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-built_in">this</span>, size);<br>    <span class="hljs-keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;<br>        setUnwritable(invokeLater);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）刷新Buffer队列"><a href="#（3）刷新Buffer队列" class="headerlink" title="（3）刷新Buffer队列"></a>（3）刷新Buffer队列</h4><blockquote><ul><li><p>add Flush（）：将unflushedEntry指向的数据写入到flushEntry指针处，flushedEntry指针指向的数据为真正发送到socket缓冲区的数据</p></li><li><p>decrementPendingOutboundBytes：减去待发送的数据，待发送数据总字节数小于规定值，恢复为可写状态；</p><img src="/2023/04/10/Netty/25.jpg" class="" title="Netty"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFlush</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> unflushedEntry;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (flushedEntry == <span class="hljs-literal">null</span>) &#123;<br>            flushedEntry = entry;<br>        &#125;<br>        <span class="hljs-keyword">do</span> &#123;<br>            flushed ++;<br>            <span class="hljs-keyword">if</span> (!entry.promise.setUncancellable()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pending</span> <span class="hljs-operator">=</span> entry.cancel();<br>                <span class="hljs-comment">//减去即将刷新数据，总字节数低，则设置为可写状态</span><br>                decrementPendingOutboundBytes(pending, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>            &#125;<br>            entry = entry.next;<br>        &#125; <span class="hljs-keyword">while</span> (entry != <span class="hljs-literal">null</span>);<br>        unflushedEntry = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>flush0：</strong></p><ul><li>getWriteSpinCount（）:获取最大自旋数（16），当数据过大时，需要分批写入，而写入过程太长的化，EventLoop线程会一直处于等待状态，可能会阻塞后面请求，所以当自旋数为0时，写会被暂时中断；</li><li>doWriteInternal(in, msg)：发送数据，每发送一次，自旋数减1；</li><li>incompleteWrite（）：确保数据全部发送完毕，数据没有写完，注册OP_WRITE事件；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">writeSpinCount</span> <span class="hljs-operator">=</span> config().getWriteSpinCount();<span class="hljs-comment">//获取自旋最大数（）</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> in.current();<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            clearOpWrite();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        writeSpinCount -= doWriteInternal(in, msg);<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、Netty堆外内存"><a href="#8、Netty堆外内存" class="headerlink" title="8、Netty堆外内存"></a>8、Netty堆外内存</h3><h4 id="（1）堆外内存与堆内内存区别"><a href="#（1）堆外内存与堆内内存区别" class="headerlink" title="（1）堆外内存与堆内内存区别"></a>（1）堆外内存与堆内内存区别</h4><blockquote><ul><li><p>堆内内存由JVM管理，GC回收内存会耗费一定的时间；堆外内存不受JVM管理，可以降低GC回收内存对应用运行带来的影响；</p></li><li><p>堆外内存需要手动释放内存，不释放会造成内存泄漏；</p></li><li><p>堆内内存需要IO读写时，需要将堆内内存转换位堆外内存，才可以与底层设备交互，堆外内存可以减少一次内存拷贝；</p></li><li><p>堆外内存可以实现进程间，JVM多实例间数据共享；</p><img src="/2023/04/10/Netty/26.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）堆外内存分配"><a href="#（2）堆外内存分配" class="headerlink" title="（2）堆外内存分配"></a>（2）堆外内存分配</h4><blockquote><ul><li><p>ByteBuffer.allocateDirect（）：通过directByteBuffer（堆内内存中）分配的内存，directByteBuffer存储堆外内存的地址，大小等属性，当directByteBuffer被JVM回收时，Cleaner对象会回收堆外内存；</p></li><li><p>unsafe.allocateMemory（）：directByteBuffer调用该方法进行堆外内存分配，该方法分配堆外内存后，需要手动释放，不然会造成内存泄漏；</p><img src="/2023/04/10/Netty/27.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（3）堆外内存回收"><a href="#（3）堆外内存回收" class="headerlink" title="（3）堆外内存回收"></a>（3）堆外内存回收</h4><blockquote><ul><li><p>DirectByteBuffer分配内存时，会创建Cleaner对象，Cleaner对象是虚引用，双向链表结构；</p></li><li><p>当堆内DirectByteBuffer被回收后，等到下一次GC回收，会将Cleaner对象添加到ReferneceQueue，并执行Cleaner中的clean方法；</p></li><li><p>clean方法主要执行将Cleaner对象从双向链表中移除，以及调用unsafe.freeMemory释放堆外内存；</p><img src="/2023/04/10/Netty/28.jpg" class="" title="Netty"></li></ul></blockquote><h3 id="9、ByteBuf"><a href="#9、ByteBuf" class="headerlink" title="9、ByteBuf"></a>9、ByteBuf</h3><h4 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h4><blockquote><ul><li><p>readIndex：读取位置的开始指针，读取n个字节，readIndex+n，readIndex等于writeIndex时，表示无字节，则不能进行读；</p></li><li><p>writeIndex：写入位置的开始指针，写入n个指针，writeIndex加n个位置，当writeIndex等于capacity时，需要进行扩容；</p></li><li><p>capacity：ByteBuf容量，当writeIndex&#x3D;&#x3D;capacity时，进行扩容；</p></li><li><p>maxCapacity：最大容量，表示扩容后容量不能超过maxCapacity，超过该容量再写入就会报错；</p><img src="/2023/04/10/Netty/29.jpg" class="" title="Netty"></li></ul></blockquote><h4 id="（2）引用计数"><a href="#（2）引用计数" class="headerlink" title="（2）引用计数"></a>（2）引用计数</h4><blockquote><ul><li>创建一个ByteBuf时，引用计数器为1，当调用ByteBuf.release（）后，引用计数器为0；</li><li>当ByteBuf引用计数器为0时，会将ByteBuf放入对象池，可以直接使用，避免重复创建ByteBuf；</li><li>可以用来做内存泄漏检测工具，当ByteBuf不可达时，JVM会回收ByteBuf，通过判断ByteBuf是否不可达且引用计数器大于0，判断内存泄漏的位置；</li></ul></blockquote><h4 id="（3）ByteBuf分类"><a href="#（3）ByteBuf分类" class="headerlink" title="（3）ByteBuf分类"></a>（3）ByteBuf分类</h4><blockquote><ul><li>Heap&#x2F;Direct：Heap指JVM堆内分配内存，底层依赖字节数据，Direct指堆外内存，不受JVM限制，由ByteBuffer进行内存分配；</li><li>Pooled&#x2F;UnPooled：Pooled指从预先分配好的内存取出，用完放回，等待下一次分配，UnPooled则是每次都是系统调用申请内存，确保能够被JVM的GC回收；</li><li>Unsafe&#x2F;非Unsafe：Unsafe是利用offset+index进行操作，非Unsafe则是利用数组，直接操作下标；</li></ul></blockquote><h3 id="10、内存管理"><a href="#10、内存管理" class="headerlink" title="10、内存管理"></a>10、内存管理</h3><h4 id="（1）内存规格"><a href="#（1）内存规格" class="headerlink" title="（1）内存规格"></a>（1）内存规格</h4><blockquote><ul><li>Chunk：为Netty向操作系统申请内存的基本单位，所有内存分配是基于Chunk来实现的，Chunk是页的集合，每个Chunk大小为16M</li><li>Page：是Chunk用于管理内存的基本单位，大小为8k；</li><li>Subpage：分配的空间远小于Page时，会将Page划分为多个相同的子块进行分配大小不固定，根据用户分配的缓冲区大小决定，如：分配1k的内存，Page会划分为8个Subpage；</li><li>tiny：16-496B，small：512-4096B，normal：8k-16M，hug：&gt;16M</li></ul></blockquote><h4 id="（2）Netty内存池架构"><a href="#（2）Netty内存池架构" class="headerlink" title="（2）Netty内存池架构"></a>（2）Netty内存池架构</h4><blockquote><ul><li><p>PoolArean:</p></li><li><ul><li>tinySubpagePools数组：用于分配tiny规格内存大小；smallSubpagePools数组：用于分配small规格内存大小，如分配20B大小空间，也会向上取整32B；</li><li>PoolChunkList：一共六种不同内存使用率的PoolChunkList，之间通过双向链表组合，每次会检查每个chunk内存使用率，并放入对应的位置；qInit内存被完全释放也不会回收，避免chunk重复初始化；</li><li>Chunk：内存真正存储数据地方，每个chunk大小16M，page的集合，会有内存使用上限和下限，当内存分配后大于上限，会将Chunk从当前PoolChunkList移除，添加到下一个PoolChunkList，下限同理；</li></ul></li><li><p>PoolThreadCache：当内存释放时，Netty并不会将缓存归还给chunk，而是下一次使用时，直接取出用即可；内部有MemoryRegionCache，本质是一个队列，分别存放tiny，small，normal三种规格的数据；</p><img src="/2023/04/10/Netty/30.jpg" class="" title="Netty"></li></ul></blockquote><blockquote><ul><li><p>PoolSubpage：</p></li><li><ul><li><p>通过bitmap记录是否被访问过；</p></li><li><p>分配小内存时，会先去tinySubpagePools或smallSubpagePools数组中先查看对应下标元素的next节点是否有内存，存在则直接分配；</p><img src="/2023/04/10/Netty/31.jpg" class="" title="Netty"><img src="/2023/04/10/Netty/32.jpg" class="" title="Netty"></li></ul></li></ul></blockquote><h4 id="（3）内存分配和回收"><a href="#（3）内存分配和回收" class="headerlink" title="（3）内存分配和回收"></a>（3）内存分配和回收</h4><blockquote><ul><li>内存分配的大小大于8k；采用page为单位进行内存分配；</li><li>内存分配的大小小于8K：先去PoolThreadCahce中查找是否有内存可以分配，没有则采用Subage为单位进行分配，并且用完空间后，不会回收，而是缓存到PoolThreadCache中；</li><li>PoolThreadCache：申请内存小于8K时，会到PoolThreadCache中的tiny，small中找是否有合适内存分配；申请内存大于8k，小于16M时，会冲PoolThreadCache中的normal中查找是否有符合的内存；大于16M的内存则直接分配；</li></ul></blockquote><h3 id="4、零拷贝"><a href="#4、零拷贝" class="headerlink" title="4、零拷贝"></a>4、零拷贝</h3><blockquote><ul><li>零拷贝：不需要将数据从一个内存位置拷贝到另外一个内存位置，减少内存拷贝损耗；</li></ul></blockquote><h4 id="（1）堆外内存"><a href="#（1）堆外内存" class="headerlink" title="（1）堆外内存"></a>（1）堆外内存</h4><blockquote><ul><li>JVM内部执行IO时，需要将堆内内存拷贝到堆外内存，JVM操作的堆内内存与操作系统分配的内存是不一样的，而且同一个对象在堆内内存的地址是不固定的，GC会通过压缩来减少内存碎片的产生；</li><li>Netty执行IO是在堆外内存操作的，可以避免由堆内内存拷贝到堆外内存</li></ul></blockquote><h4 id="（2）CompositeByteBuf"><a href="#（2）CompositeByteBuf" class="headerlink" title="（2）CompositeByteBuf"></a>（2）CompositeByteBuf</h4><blockquote><ul><li><p>调用addCompoments（）方法来合并两个ByteBuf，底层的byte数组还是复用的，不会进行拷贝；</p></li><li><p>内部维护一个Compoment数组，每一个Compoment对应一个ByteBuf，每一个ByteBuf维护各自的索引；</p></li><li><p>通过Compoment中的offset和endOffset，可以直到一个ByteBuf的开始读取位置到结束位置，从而形成一个逻辑整体；</p><img src="/2023/04/10/Netty/33.jpg" class="" title="Netty"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">final</span> ByteBuf srcBuf; <span class="hljs-comment">// 原始ByteBuf</span><br>    <span class="hljs-keyword">final</span> ByteBuf buf; <span class="hljs-comment">// srcBuf取出包装后的ByteBuf</span><br>    <span class="hljs-type">int</span> srcAdjustment; <span class="hljs-comment">// CompositeByteBuf 的起始索引相对于 srcBuf 读索引的偏移</span><br>    <span class="hljs-type">int</span> adjustment; <span class="hljs-comment">// CompositeByteBuf 的起始索引相对于 buf 的读索引的偏移</span><br>    <span class="hljs-type">int</span> offset; <span class="hljs-comment">// 相对CompositeByteBuf开始索引</span><br>    <span class="hljs-type">int</span> endOffset; <span class="hljs-comment">// 相对CompositeByteBud的结束索引</span><br>    <span class="hljs-comment">//省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/10/Netty/34.jpg" class="" title="Netty"><h4 id="（3）Unpooled-WrappedBuffer操作"><a href="#（3）Unpooled-WrappedBuffer操作" class="headerlink" title="（3）Unpooled.WrappedBuffer操作"></a>（3）Unpooled.WrappedBuffer操作</h4><blockquote><p>将一个或多个ByteBuf包装为一个大的ByteBuf，底层同样是共享byte数组，不会发生数据拷贝；</p></blockquote><h4 id="（4）ByteBuf-slice（）操作"><a href="#（4）ByteBuf-slice（）操作" class="headerlink" title="（4）ByteBuf.slice（）操作"></a>（4）ByteBuf.slice（）操作</h4><blockquote><p>将一个大的ByteBuf拆分为多个小的ByteBuf，每一个小的ByteBuf都会生成一个读写指针，底层的byte数组依旧与原来的ByteBuf共享;</p><img src="/2023/04/10/Netty/35.jpg" class="" title="Netty"></blockquote><h4 id="（5）文件传输FileRegiion"><a href="#（5）文件传输FileRegiion" class="headerlink" title="（5）文件传输FileRegiion"></a>（5）文件传输FileRegiion</h4><blockquote><p>FileRegion的对FileChannel的封装，底层使用JDK的NIO的FileChannel的transferTo（）方法实现文件传输，所以为零拷贝；</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、工作模型"><a href="#1、工作模型" class="headerlink" title="1、工作模型"></a>1、工作模型</h3><p>①vhost：实现资源的隔离和权限的监控，不同的vhost可以有相同的队列交换机;</p><p>②Broke：消息代理服务</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="图片1"><h3 id="2、直连交换机（Direct）"><a href="#2、直连交换机（Direct）" class="headerlink" title="2、直连交换机（Direct）"></a>2、直连交换机（Direct）</h3><p>①一个队列通过一个具体的routingKey绑定交换机；</p><p>②主要用于循环分发任务给工作者，负载均衡是在消费者之间</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="图片1"><h3 id="3、扇形交换机"><a href="#3、扇形交换机" class="headerlink" title="3、扇形交换机"></a>3、扇形交换机</h3><p>①消息发送给扇形交换机，扇形交换机广播给所有与之绑定的队列；</p><p>②使用场景</p><blockquote><ul><li>大规模多用户在线游戏可以使用它来处理排行榜更新等全局事件</li><li>体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li><li>分发系统使用它来广播各种状态和配置更新</li><li>在群聊的时候，它被用来分发消息给参与群聊的用户。</li></ul></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="图片1"><h3 id="4、主题交换机"><a href="#4、主题交换机" class="headerlink" title="4、主题交换机"></a>4、主题交换机</h3><p>①交换机与队列绑定的路由键可以使用通配符，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者&#x2F;多应用的时候，主题交换机都可以被列入考虑范围；</p><p>②路由匹配规则</p><blockquote><p>（1）#代表匹配0个或多个规则</p><p>（2）*匹配一个单词</p><p>（3）单词之间用 . 分开</p></blockquote><p>③适用于一些根据业务场景和消息类型过滤消息的场景</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="图片1"><h3 id="5、可靠性投递"><a href="#5、可靠性投递" class="headerlink" title="5、可靠性投递"></a>5、可靠性投递</h3><h4 id="①交换机，队列绑定配置，以及消费者"><a href="#①交换机，队列绑定配置，以及消费者" class="headerlink" title="①交换机，队列绑定配置，以及消费者"></a>①交换机，队列绑定配置，以及消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">------ 配置RabbitMQConfig.class -----------<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String exchangeName=<span class="hljs-string">&quot;test_exchange_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String queueName=<span class="hljs-string">&quot;test_queue_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String routingKey=<span class="hljs-string">&quot;test_key&quot;</span>;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(routingKey);<br>    &#125;<br>&#125;<br><br>-------------消费者Consumer.class------------------------------------------<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-comment">//消费消息</span><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.queueName)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费消息:&quot;</span>+name);<br>    &#125;<br>&#125;<br><br>-------------yml配置-----------------------------------------<br>spring:<br>  rabbitmq:<br>    host: localhost<br>    port: <span class="hljs-number">5672</span><br>    username: admin<br>    password: admin<br>    <span class="hljs-comment">//开启消息确认机制，一定要开启</span><br>    publisher-confirm-type: correlated<br>    publisher-returns: <span class="hljs-literal">true</span><br>    template:<br>      mandatory: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="②消息到RabbitMQ服务端"><a href="#②消息到RabbitMQ服务端" class="headerlink" title="②消息到RabbitMQ服务端"></a>②消息到RabbitMQ服务端</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="图片1"><p>（1）问题：生产者发送消息给MQ服务器时，可能由于网络原因或Broke故障导致发送失败，生产者无法确定是否发送成功；</p><p>（2）事务确认模式：通过channel.txCommit提交事务，若发生异常，使用channel.txRollback回滚事务，我们可以捕捉处理异常，会阻塞后面所有消息的消费；</p><p>（3）Confirm确认模式</p><blockquote><p>correlationData：消息的唯一标识；</p><p>ack：消息发送成功返回true，发送失败返回false;</p><p>cause：消息发送失败原因</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;confirm&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">confirm</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开启消息确认机制，correlationData1为消息标识,</span><br><span class="hljs-comment">     * ack消息是否发送成功（true标识发送成功），cause:发送失败原因</span><br><span class="hljs-comment">     */</span><br>    rabbitTemplate.setConfirmCallback((correlationData1,ack,cause)-&gt;&#123;<br>        <span class="hljs-keyword">if</span> (ack)&#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息:&quot;</span>+correlationData1+<span class="hljs-string">&quot;发送失败，&quot;</span>+<span class="hljs-string">&quot;失败原因为：&quot;</span>+cause);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">//发送五条消息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-comment">//消息的唯一标识</span><br>        CorrelationData correlationData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(String.valueOf(i));<br>        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//消息发送失败</span><br>            Map&lt;String,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;correlationData&quot;</span>, i);<br>            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;无法找到交换机的消息&quot;</span>);<br>            rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;notQueue&quot;</span>, String.valueOf(i),map);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            rabbitTemplate.convertAndSend(RabbitMQConfig.queueName,i,correlationData);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③消息从交换机到路由队列"><a href="#③消息从交换机到路由队列" class="headerlink" title="③消息从交换机到路由队列"></a>③消息从交换机到路由队列</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="图片1"><p>（1）问题：交换机到队列的路由或队列不存在，发送消息丢失</p><p>（2）重发消息到新的队列消费</p><blockquote><p>message：回退消息</p><p>replayCode：错误状态码</p><p>replayText：错误内容</p><p>exchange：交换机</p><p>routingKey:路由</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;returnBack&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">returnBack</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//设置消息重发机制</span><br>    rabbitTemplate.setReturnCallback((message, replyCode, replyText,exchange, routingKey)-&gt;&#123;<br>        System.out.println(<span class="hljs-string">&quot;回退消息：&quot;</span>+message);<br>        System.out.println(<span class="hljs-string">&quot;不通路由：&quot;</span>+routingKey);<br>        System.out.println(<span class="hljs-string">&quot;交换机:&quot;</span>+exchange);<br>        System.out.println(<span class="hljs-string">&quot;replayText:&quot;</span>+replyText);<br>        <span class="hljs-comment">//重发消息到备份队列</span><br>        rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                      RabbitMQConfig.backKey,message.getBody());<br>    &#125;);<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                  <span class="hljs-string">&quot;no&quot;</span>,<span class="hljs-string">&quot;23&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④消息从队列到消费者"><a href="#④消息从队列到消费者" class="headerlink" title="④消息从队列到消费者"></a>④消息从队列到消费者</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="图片1"><p>（1）问题：消息到达队列后，等待消费者消费，消费者未消费，服务宕机，队列消息丢失；</p><p>（2）队列和交换机设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(queueName).build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤消息到消费者-消费失败"><a href="#⑤消息到消费者-消费失败" class="headerlink" title="⑤消息到消费者 消费失败"></a>⑤消息到消费者 消费失败</h4><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="图片1"><p>（1）消费者从MQ中获取消息后，MQ会删除消息，消费者异常消费失败，消息丢失</p><p>（2）消费者消费消息完成后，手动发送ack给服务端</p><blockquote><p>none：自动ACK，默认</p><p>maunal：手动ACK</p><p>auto：方法未抛出异常，自动发送ACK，抛出异常（不是AmqpRejectAndDontReueueException）则发送nack，重新入队列</p><p>开启了maunal后，一定要手动basicACK，否则消息会无限消费</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#设置手动ack<br>listener:<br>direct:<br>acknowledge-mode: manual<br></code></pre></td></tr></table></figure><blockquote><p>【1】void basicAck(long deliveryTag, boolean multiple) ：</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息，如</p><p>发送消息1，2，3，未应答，发送消息4，应答1，2，3，4</p><p>【2】void basicNack(long deliveryTag, boolean multiple, boolean requeue)</p><p>deliverTag：标识消息的唯一标识，重发后会自动增加标识</p><p>multiple：设置为true，表示可以批量应答所有小于当前deliverTag的消息</p><p>requeue：是否重新入队列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.backQueue)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerAck</span> &#123;<br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(String msg, Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟故障</span><br>            <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;消息消费：&quot;</span>+msg);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 应答消息消费成功，参数2：true开启批量应答</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ioException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;发送失败，消息丢失&quot;</span>);<br>            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、消息幂等性"><a href="#6、消息幂等性" class="headerlink" title="6、消息幂等性"></a>6、消息幂等性</h3><h4 id="①问题"><a href="#①问题" class="headerlink" title="①问题"></a>①问题</h4><p>对于同一个系统中，一次请求或重复多次请求对资源的影响是一致性的。如：同一笔订单中，由于网络延迟，消费者重新支付，如果没有幂等性，则会造成多次消费，有幂等性，对同个订单支付多次时，只会支付一次；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" title="图片1"><h4 id="②解决方案"><a href="#②解决方案" class="headerlink" title="②解决方案"></a>②解决方案</h4><blockquote><p>发送消息时，带上全局唯一id，每次消费消息时，前往redis中判断是否存在该消费消息，存在，消息丢弃，不存在，消费消息，将id写入redis中。</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" title="图片1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>    redis:<br>        port: <span class="hljs-number">6379</span><br>        password: <span class="hljs-number">123456</span><br>        host: localhost<br>    rabbitmq:<br>        host: localhost<br>        port: <span class="hljs-number">5672</span><br>        username: admin<br>        password: admin<br>        publisher-confirm-type: correlated<br>        publisher-returns: <span class="hljs-literal">true</span><br>        template:<br>        mandatory: <span class="hljs-literal">true</span><br>        #设置手动ack<br>        listener:<br>            simple:<br>                acknowledge-mode: manual<br>                #重试次数<br>                retry:<br>                enabled: <span class="hljs-literal">true</span><br>                max-attempts: <span class="hljs-number">3</span> #重试次数最多三次<br>                initial-interval: <span class="hljs-number">2000</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String exchangeName=<span class="hljs-string">&quot;test_exchange_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String idempotent_queue=<span class="hljs-string">&quot;idempotent_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String idempotent_key=<span class="hljs-string">&quot;idempotent_key&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(idempotentQueue())<br>        .to(directExchange()).with(idempotent_key);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">idempotentQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(idempotent_queue).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(exchangeName).durable(<span class="hljs-literal">true</span>).build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>生产者发送消息：</p><p>设置messageId为唯一id，做为key，存储到redis中，用于判断消息是否消费过</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/idempotent&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">idempotent</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//设置唯一标识</span><br>    CorrelationData correlationData=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    correlationData.setId(String.valueOf(<span class="hljs-number">1</span>));<br>    <span class="hljs-comment">//消息体</span><br>    String msg=<span class="hljs-string">&quot;hello&quot;</span>;<br>    Message message= MessageBuilder.withBody(msg.getBytes())<br>    .setMessageId(UUID.randomUUID()+<span class="hljs-string">&quot;&quot;</span>)<br>    .setContentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    .build();<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.exchangeName,<br>                                  RabbitMQConfig.idempotent_key,message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>消费者消费消息：</p><p>消费时，判断redis中，该id的值是否存在，存在则消费过，丢弃消息，否则消费消息，将id写入redis；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.idempotent_queue)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumers</span><span class="hljs-params">(Message message,Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费次数：&quot;</span>+message.getMessageProperties().getDeliveryTag());<br>    <span class="hljs-comment">/** 根据用户唯一标识+deliverTag，设置key */</span><br>    String key=message.getMessageProperties().getMessageId();<br>    <span class="hljs-comment">/** redis中不存在 */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (s==<span class="hljs-literal">null</span>)&#123;<br>        String msg=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        System.out.println(<span class="hljs-string">&quot;消费消息&quot;</span>+msg);<br>        stringRedisTemplate.opsForValue().set(key,key);<br>    &#125;<br>    <span class="hljs-comment">/** 模拟消费者消费消息后故障， */</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/** 应答消息 */</span><br>    channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="hljs-literal">true</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="7、消息的顺序性"><a href="#7、消息的顺序性" class="headerlink" title="7、消息的顺序性"></a>7、消息的顺序性</h3><h4 id="①问题-1"><a href="#①问题-1" class="headerlink" title="①问题"></a>①问题</h4><blockquote><p>生产者按顺序发送A，B，C消息，多个消费者消费消息时，由于各消费者消费速度不一样，可能造成消费的顺序不为A，B，C，从而导致数据错乱</p></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" class="" title="图片1"><h4 id="②解决方案-1"><a href="#②解决方案-1" class="headerlink" title="②解决方案"></a>②解决方案</h4><blockquote><p>一个消费者对应一个队列，同一个业务的消息发送到同一个队列中</p></blockquote><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" class="" title="图片1"><h3 id="8、延迟消息"><a href="#8、延迟消息" class="headerlink" title="8、延迟消息"></a>8、延迟消息</h3><h4 id="①死信队列"><a href="#①死信队列" class="headerlink" title="①死信队列"></a>①死信队列</h4><p>队列中配置了dead-letter-exchange属性，指定交换机，则队列中的死信就会投递到该交换机中；</p><p>死信：</p><p>（1）消息被拒绝或返回nack，且requeue设置为false；</p><p>（2）消息超时，无人消费；</p><p>（3）消息堆积，最早消息成为死信</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" class="" title="图片1"><p>队列配置死信交换机如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">test_queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(test_queue_dead)<br>    <span class="hljs-comment">//设置死信交换机</span><br>    .deadLetterExchange(dead_exchange)<br>    .deadLetterRoutingKey(dead_key)<br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②延迟交换机"><a href="#②延迟交换机" class="headerlink" title="②延迟交换机"></a>②延迟交换机</h4><p>指定交换机延迟时间，交换机时间到后会发送消息给队列消费；消息头需要携带x-delay参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/dead&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dead</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//消息体</span><br>    String msg=<span class="hljs-string">&quot;hello&quot;</span>;<br>    Message message= MessageBuilder.withBody(msg.getBytes())<br>    .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>,<span class="hljs-number">10000</span>)<span class="hljs-comment">//设置延迟时间</span><br>    .build();<br>    rabbitTemplate.convertAndSend(RabbitMQConfig.test_exchange_dead,<br>                                  RabbitMQConfig.test_key,message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;发送成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置延迟交换机，需要先去下载延迟交换机插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">directExchange_test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ExchangeBuilder<br>    .directExchange(test_exchange_dead)<br>    .delayed()<span class="hljs-comment">//设置延迟交换机</span><br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、消息堆积（惰性队列）"><a href="#9、消息堆积（惰性队列）" class="headerlink" title="9、消息堆积（惰性队列）"></a>9、消息堆积（惰性队列）</h3><p>①生产者消费消息速度超过消费者消费速度，就会堆积消息；</p><p>②解决：增加消费者；消费者内部采用线程池处理；扩大堆积队列</p><p>③惰性队列：接收到消息后，会直接存入磁盘，消费者消费时，才会加载到内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">test_queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(test_queue_dead)<br>    .lazy()<span class="hljs-comment">//配置为延迟队列</span><br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10、消息中间件四种消息投递模型"><a href="#10、消息中间件四种消息投递模型" class="headerlink" title="10、消息中间件四种消息投递模型"></a>10、消息中间件四种消息投递模型</h3><h4 id="①点对点（PTP）模型"><a href="#①点对点（PTP）模型" class="headerlink" title="①点对点（PTP）模型"></a>①点对点（PTP）模型</h4><blockquote><ul><li><p>点对点通信，一个队列可以有多个生产者和多个消费者；</p></li><li><p>消息按照接收消息的顺序，先后放入队列中，一个消息只能有一个消费者消费；</p></li><li><p>消息消费后，会从队列中删除；</p></li><li><p>虽然采用队列，但是消息的消费可能是无序的，队列可以将消息给多个消费者消费，所以队列保证分发是有序的，但消费顺序取决于消费者的处理速度；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" class="" title="图片1"></li></ul></blockquote><h4 id="②发布订阅（Pub-x2F-Sub）模型"><a href="#②发布订阅（Pub-x2F-Sub）模型" class="headerlink" title="②发布订阅（Pub&#x2F;Sub）模型"></a>②发布订阅（Pub&#x2F;Sub）模型</h4><blockquote><p>生成者发送消息到一个主题中，订阅了该主题的所有消费者，都可以收到消息；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" class="" title="图片1"></blockquote><h4 id="③分区（Partition）模型"><a href="#③分区（Partition）模型" class="headerlink" title="③分区（Partition）模型"></a>③分区（Partition）模型</h4><blockquote><ul><li><p>生产者根据主题类型发送消息到对应的分区（Partition），一个分区可以理解为一个队列，且分区中队列存储的数据只是一部分，而PTP模型中，队列存储的数据是全部数据；</p></li><li><p>每个分区（Partition）会对应一组消费者，消费者只能消费由自己所在分区派发的消息；</p></li><li><p>每个分区只能发送给一个消费者,消费者数量不能多余分区；</p></li><li><p>分区模型，将点对点模型和发布订阅模式结合起来；</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" class="" title="图片1"></li></ul></blockquote><h4 id="④transfer模型"><a href="#④transfer模型" class="headerlink" title="④transfer模型"></a>④transfer模型</h4><blockquote><ul><li><p>生产者发送消息到topic上，会转发到每一个队列；</p></li><li><p>队列中拥有消息的全量数据，一个队列的消息可以被多个消费者消费；</p></li><li><p>队列同样不保证消息消费的顺序性;</p><img src="/2023/03/31/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" class="" title="图片1"></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2023/03/24/ElasticSearch/"/>
    <url>/2023/03/24/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h3 id="1、ElasticSearch基本概念"><a href="#1、ElasticSearch基本概念" class="headerlink" title="1、ElasticSearch基本概念"></a>1、ElasticSearch基本概念</h3><h4 id="（1）Node节点"><a href="#（1）Node节点" class="headerlink" title="（1）Node节点"></a>（1）Node节点</h4><blockquote><p>一个节点是一个集群的服务器，存储集群的数据，参与集群的索引和搜索功能。像集群有名字，节点也有自己的名称，默认在启动时会以一个随机的UUID的前七个字符作为节点的名字，你可以为其指定任意的名字。通过集群名在网络中发现同伴组成集群。一个节点也可是集群。</p></blockquote><h4 id="（2）index索引"><a href="#（2）index索引" class="headerlink" title="（2）index索引"></a>（2）index索引</h4><blockquote><p>一个索引是文档的集合，类比mysql中的数据库，每个索引有唯一名称（全为小写字母），我们对文档进行搜索，增删改时，都要用到这个名字。</p></blockquote><h4 id="（3）Type类型"><a href="#（3）Type类型" class="headerlink" title="（3）Type类型"></a>（3）Type类型</h4><blockquote><p>一个索引中可以存放不同数据，类比mysql中的表，6.0版本以上已废弃。</p></blockquote><h4 id="（4）Document文档"><a href="#（4）Document文档" class="headerlink" title="（4）Document文档"></a>（4）Document文档</h4><blockquote><p>索引中的一条数据，类比msql中的一行数据，插入索引以文档为单位，以JSON格式存储。</p></blockquote><h4 id="（5）Shard分片"><a href="#（5）Shard分片" class="headerlink" title="（5）Shard分片"></a>（5）Shard分片</h4><blockquote><p>数据量过大时，ElasticSearch索引过慢，因此将索引划分成多份，这些份就是分片。分片允许水平扩容；同时支持分布式，并行操作。</p></blockquote><h4 id="（6）Replication复制"><a href="#（6）Replication复制" class="headerlink" title="（6）Replication复制"></a>（6）Replication复制</h4><blockquote><p>一个分片可以有多个备份，分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p></blockquote><h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><h4 id="（1）索引创建"><a href="#（1）索引创建" class="headerlink" title="（1）索引创建"></a>（1）索引创建</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /test-index-users<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;number_of_shards&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//设置分片数量</span><br>    <span class="hljs-attr">&quot;number_of_replicas&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">//指定映射关系</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;long&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;remarks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="（2）倒排索引"><a href="#（2）倒排索引" class="headerlink" title="（2）倒排索引"></a>（2）倒排索引</h4><blockquote><p>ElasticSearch会为下面的数据创建两个索引树，ID不指定会自动生成，以Name和Age生成的索引树就为倒排索引</p></blockquote><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Age</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Kate</td><td align="center">24</td></tr><tr><td align="center">2</td><td align="center">John</td><td align="center">24</td></tr><tr><td align="center">3</td><td align="center">Bill</td><td align="center">29</td></tr><tr><td align="center">4</td><td align="center">Kate</td><td align="center">26</td></tr><tr><td align="center">5</td><td align="center">Brand</td><td align="center">29</td></tr></tbody></table><blockquote><p>以Name字段建立的索引树</p></blockquote><table><thead><tr><th align="center">Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td align="center">Kate</td><td align="center">1,4</td></tr><tr><td align="center">Brand</td><td align="center">5</td></tr><tr><td align="center">John</td><td align="center">2</td></tr><tr><td align="center">Bill</td><td align="center">3</td></tr></tbody></table><blockquote><p>以Age创建索引树</p></blockquote><table><thead><tr><th align="center">Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td align="center">24</td><td align="center">1,2</td></tr><tr><td align="center">26</td><td align="center">4</td></tr><tr><td align="center">29</td><td align="center">3,5</td></tr></tbody></table><blockquote><p>①每个字段对应一组Term，每个Term对应一个Posting List，他是一组id，根据id到磁盘查找速度会快很多；</p><p>②Term存放于有序表Term DIctionary（磁盘中）中，Term按序存放，每次查找term时，根据二分查找，时间复杂度为LogN；</p><p>③对于Term中大量重复前缀，ElasticSearch会把每一个Term的前缀取出来放入树种，这颗树就是Term Index。</p></blockquote><img src="/2023/03/24/ElasticSearch/1.png" class="" title="ElasticSearch"><blockquote><p>Posting List压缩：</p><p>①bitmap是一种数据结构，其用0&#x2F;1代表值是否存在，如</p><p>{1，2，3，5},对应bitmap为：[1，0，1，1，1]</p><p>②但bitmap随着元素的增加，bitmap存储空间也是线性增加，会占用大量空间；</p><p>③Roardings bitmap：</p><p>将posting List按照65535分块，0-65535为第一块，65536-131071为第二块，再用&lt;商，余数&gt;表示一组id，商表示在第几组，余数则表示在组中位置，如下图：</p></blockquote><img src="/2023/03/24/ElasticSearch/2.png" class="" title="ElasticSearch"><h3 id="3、DSL查询"><a href="#3、DSL查询" class="headerlink" title="3、DSL查询"></a>3、DSL查询</h3><blockquote><ul><li>match查询，会将查询池进行分词，包含分词后的词，数据可以被查到，如：</li></ul><p>查询词：苹果橘子，只要包含苹果、橘子的文档都会被查出</p><ul><li>term查询，需要包含和查询值一样的文档，数据才可以被查到（查询词若为英文单词，全部字母需要小写，否则匹配不到），如：</li></ul><p>数据：【Apple ，oragne】，查询词：apple  可以被查到的数据：Apple</p></blockquote><h4 id="（1）复合查询"><a href="#（1）复合查询" class="headerlink" title="（1）复合查询"></a>（1）复合查询</h4><h6 id="①布尔查询（bool-query）"><a href="#①布尔查询（bool-query）" class="headerlink" title="①布尔查询（bool query）"></a>①布尔查询（bool query）</h6><blockquote><ul><li>子查询可以任意顺序出现</li><li>可以嵌套多个查询，包括bool查询</li><li>如果bool查询中没有must条件，should中必须至少满足一条才会返回结果，不满足不反回数据。</li><li>四种操作符must、should、must_not、filter</li></ul></blockquote><img src="/2023/03/24/ElasticSearch/3.png" class="" title="ElasticSearch"><blockquote><p>must与filter区别</p></blockquote><img src="/2023/03/24/ElasticSearch/4.png" class="" title="ElasticSearch"><h6 id="②提高查询（boosting-query）"><a href="#②提高查询（boosting-query）" class="headerlink" title="②提高查询（boosting query）"></a>②提高查询（boosting query）</h6><blockquote><p>boosting查询中一个子查询条件不满足，则是减低数据显示的权重（score），如</p><p>name&#x3D;”tom” and age&#x3D;1,条件age不匹配，数据还是会显示，只是降低权重（scope）</p></blockquote><img src="/2023/03/24/ElasticSearch/5.png" class="" title="ElasticSearch"><h6 id="③固定分数查询（constant-scope）"><a href="#③固定分数查询（constant-scope）" class="headerlink" title="③固定分数查询（constant_scope）"></a>③固定分数查询（constant_scope）</h6><blockquote><p>查询某个条件时，返回固定的scope，我们可以利用filter过滤，返回scope，不需要计算scope，filter是忽略scope的</p></blockquote><img src="/2023/03/24/ElasticSearch/6.png" class="" title="ElasticSearch"><h6 id="④最佳匹配查询（dis-max）"><a href="#④最佳匹配查询（dis-max）" class="headerlink" title="④最佳匹配查询（dis_max）"></a>④最佳匹配查询（dis_max）</h6><blockquote><p>将与任一匹配的文档返回，但只返回结果最佳的评分 作为查询的评分返回</p><p>在使用多个match匹配时，<u>匹配度最高的不一定是最佳结果</u>，因为match匹配时，会将title，body中match匹配结果的评分进行累加，最终返回，下面计算评分:</p><ol><li>通过title 匹配 brown fox ，id&#x3D;1匹配到(第一个match)</li></ol><p>id&#x3D;1分数：0.6931472</p><p>id&#x3D;2分数：0</p><img src="/2023/03/24/ElasticSearch/7.png" class="" title="ElasticSearch"><p>2.body 匹配 brown fox（第二个match）</p><p>id&#x3D;1分数：0.2111090919</p><p>id&#x3D;2分数：0.77041256</p><img src="/2023/03/24/ElasticSearch/8.png" class="" title="ElasticSearch"><p>3.整体查询的结果分数&#x3D;第一个match分数+第二个match分数</p><p>id为1的分数&#x3D;0.6931472+0.2111090919&#x3D;0.90425634</p><p>id为2的分数&#x3D;0+0.77041256&#x3D;0.77041256</p><img src="/2023/03/24/ElasticSearch/9.png" class="" title="ElasticSearch"><p>使用dis_max,   分数 &#x3D; 第一个匹配条件分数 + tie_breaker * 第二个匹配的条件的分数 </p><img src="/2023/03/24/ElasticSearch/10.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤函数查询（function-score）"><a href="#⑤函数查询（function-score）" class="headerlink" title="⑤函数查询（function_score）"></a>⑤函数查询（function_score）</h6><blockquote><p>使用自定义的函数计算评分值</p><ul><li>script_score 使用自定义的脚本来完全控制分值计算逻辑。如果你需要以上预定义函数之外的功能，可以根据需要通过脚本进行实现。</li></ul><img src="/2023/03/24/ElasticSearch/11.png" class="" title="ElasticSearch"><ul><li>weight 对每份文档适用一个简单的提升，且该提升不会被归约：当weight为2时，结果为2 * score。</li><li>random_score 使用一致性随机分值计算来对每个用户采用不同的结果排序方式，对相同用户仍然使用相同的排序方式。</li></ul><img src="/2023/03/24/ElasticSearch/12.png" class="" title="ElasticSearch"><ul><li>field_value_factor 使用文档中某个字段的值来改变_score，比如将受欢迎程度或者投票数量考虑在内。</li></ul><img src="/2023/03/24/ElasticSearch/13.png" class="" title="ElasticSearch"><ul><li>衰减函数(Decay Function) - linear，exp，gauss</li></ul></blockquote><h4 id="（2）全文搜索"><a href="#（2）全文搜索" class="headerlink" title="（2）全文搜索"></a>（2）全文搜索</h4><h6 id="①match查询"><a href="#①match查询" class="headerlink" title="①match查询"></a>①match查询</h6><blockquote><p><strong>单词匹配</strong></p><p>（1）检查查询字段类型，字段为string类型，则match匹配的词要进行分词；</p><p>（2）分析查询字符串，下图中quick只有一个单词，分词后结果为quic，所以match执行的是当个term查询</p><p>（3）term通过倒排索引。，查询到id为 【1，3】</p><p>（4）为每个查询结果进行评分</p><img src="/2023/03/24/ElasticSearch/14.png" class="" title="ElasticSearch"></blockquote><blockquote><p><strong>多词匹配</strong></p><p>多个单词，实际上是执行多个单词term匹配，然后合并结果</p><img src="/2023/03/24/ElasticSearch/15.png" class="" title="ElasticSearch"><p>上方查询与下方bool查询等价</p><img src="/2023/03/24/ElasticSearch/16.png" class="" title="ElasticSearch"><p>match多词匹配中，有个operator属性，默认值为or，结果与上面等价</p><img src="/2023/03/24/ElasticSearch/17.png" class="" title="ElasticSearch"><p>match支持参数minimum_should_match来控制匹配单词数，可以是分数，也可以直接指定匹配单词数</p><img src="/2023/03/24/ElasticSearch/18.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/19.png" class="" title="ElasticSearch"></blockquote><h6 id="②match-phrase查询"><a href="#②match-phrase查询" class="headerlink" title="②match_phrase查询"></a>②match_phrase查询</h6><blockquote><p>本质是连续的term查询（必须满足所有单词匹配），遇到数据中没有的词，就会查询不到，同时搜索单词的顺序需要和数据中单词顺寻保持一致，否则查询不到；如下：</p><img src="/2023/03/24/ElasticSearch/20.png" class="" title="ElasticSearch"><p>下面匹配单词和上图一样，但是顺寻不一样，匹配结果不同</p><img src="/2023/03/24/ElasticSearch/21.png" class="" title="ElasticSearch"></blockquote><h6 id="③match-pharse-prefix"><a href="#③match-pharse-prefix" class="headerlink" title="③match_pharse_prefix"></a>③match_pharse_prefix</h6><blockquote><p>该匹配是最后一个词是前缀匹配，前面的单词和match_pharse匹配一致，如：</p><p>【brown quick f】需要匹配到单词brown、quick，且以f为前缀的单词，同时顺序需要保持一致；</p><img src="/2023/03/24/ElasticSearch/22.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/23.png" class="" title="ElasticSearch"></blockquote><h6 id="④match-bool-prefix"><a href="#④match-bool-prefix" class="headerlink" title="④match_bool_prefix"></a>④match_bool_prefix</h6><blockquote><p>也是连续的term匹配，最后一个单词前缀匹配即可，需要匹配所有单词，但顺序可以不一致，如下图：</p><img src="/2023/03/24/ElasticSearch/24.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤multi-match"><a href="#⑤multi-match" class="headerlink" title="⑤multi_match"></a>⑤multi_match</h6><blockquote><p>查询单词，满足其中一个字段即可，不用所有单词都匹配</p><img src="/2023/03/24/ElasticSearch/25.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/26.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥query-string"><a href="#⑥query-string" class="headerlink" title="⑥query_string"></a>⑥query_string</h6><blockquote><p>根据运算符来来提供查询字符串，查询前，拆分每一个文本</p><img src="/2023/03/24/ElasticSearch/27.png" class="" title="ElasticSearch"></blockquote><h6 id="⑦simple-query-string"><a href="#⑦simple-query-string" class="headerlink" title="⑦simple_query_string"></a>⑦simple_query_string</h6><blockquote><p>查询时，会自动将搜索词中无效的文本忽略</p><img src="/2023/03/24/ElasticSearch/28.png" class="" title="ElasticSearch"></blockquote><h6 id="⑧interval"><a href="#⑧interval" class="headerlink" title="⑧interval"></a>⑧interval</h6><blockquote><p>单词都要匹配，且按照匹配条件顺序进行匹配</p><img src="/2023/03/24/ElasticSearch/29.png" class="" title="ElasticSearch"></blockquote><h4 id="（3）Term查询"><a href="#（3）Term查询" class="headerlink" title="（3）Term查询"></a>（3）Term查询</h4><h6 id="①exist查询"><a href="#①exist查询" class="headerlink" title="①exist查询"></a>①exist查询</h6><blockquote><p>查询指定字段存在的数据，字段索引值不存在的原因：JSON数据为null、index设置为false、字段长度超过映射长度、字段数据类型错误</p><img src="/2023/03/24/ElasticSearch/30.png" class="" title="ElasticSearch"></blockquote><h6 id="②id查询"><a href="#②id查询" class="headerlink" title="②id查询"></a>②id查询</h6><blockquote><p>查询指定id的数据</p><img src="/2023/03/24/ElasticSearch/31.png" class="" title="ElasticSearch"></blockquote><h6 id="③prefix前缀查询"><a href="#③prefix前缀查询" class="headerlink" title="③prefix前缀查询"></a>③prefix前缀查询</h6><blockquote><p>查找指定字段的前缀值相同的数据</p><img src="/2023/03/24/ElasticSearch/32.png" class="" title="ElasticSearch"></blockquote><h6 id="④term分词查询"><a href="#④term分词查询" class="headerlink" title="④term分词查询"></a>④term分词查询</h6><blockquote><p>根据分词查询数据，查询词需要和value值完全一样才会匹配</p><img src="/2023/03/24/ElasticSearch/33.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤terms多分词查询"><a href="#⑤terms多分词查询" class="headerlink" title="⑤terms多分词查询"></a>⑤terms多分词查询</h6><blockquote><p>根据多个分词查询数据</p><img src="/2023/03/24/ElasticSearch/34.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥term-set查询"><a href="#⑥term-set查询" class="headerlink" title="⑥term_set查询"></a>⑥term_set查询</h6><blockquote><p>指定term需要匹配词的数量</p><img src="/2023/03/24/ElasticSearch/35.png" class="" title="ElasticSearch"></blockquote><h6 id="⑦wildcard查询"><a href="#⑦wildcard查询" class="headerlink" title="⑦wildcard查询"></a>⑦wildcard查询</h6><blockquote><p>通配符查询，如*可以匹配任意多个随意在字符</p><img src="/2023/03/24/ElasticSearch/36.png" class="" title="ElasticSearch"></blockquote><h6 id="⑧range查询"><a href="#⑧range查询" class="headerlink" title="⑧range查询"></a>⑧range查询</h6><blockquote><p>范围匹配查询</p><img src="/2023/03/24/ElasticSearch/37.png" class="" title="ElasticSearch"></blockquote><h6 id="⑩fuzzy模糊查询"><a href="#⑩fuzzy模糊查询" class="headerlink" title="⑩fuzzy模糊查询"></a>⑩fuzzy模糊查询</h6><blockquote><p>模糊查询，可以进行匹配词的增删改，如增：sic-&gt;sick 、改：box-&gt;fox、删：black-&gt;lack、换:act-&gt;cat</p><p>（只能更改一个字符）</p><img src="/2023/03/24/ElasticSearch/38.png" class="" title="ElasticSearch"><img src="/2023/03/24/ElasticSearch/39.png" class="" title="ElasticSearch"></blockquote><h3 id="4、聚合查询"><a href="#4、聚合查询" class="headerlink" title="4、聚合查询"></a>4、聚合查询</h3><h5 id="（1）桶（Bucket）聚合"><a href="#（1）桶（Bucket）聚合" class="headerlink" title="（1）桶（Bucket）聚合"></a>（1）桶（Bucket）聚合</h5><blockquote><ol><li><p>桶：类似于MySQL中的groud by查询后的分组，是存放满足特定条件文档的集合；</p></li><li><p>指标：对桶中的文档进行计算，类似于MySQL中的count（），avg（）函数</p><img src="/2023/03/24/ElasticSearch/40.png" class="" title="ElasticSearch"></li></ol></blockquote><blockquote><p>数据准备</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /car/_bulk<br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">10000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-10-28&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-11-05&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">30000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;green&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ford&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-05-18&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">15000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toyota&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-07-02&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">12000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;green&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toyota&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-08-19&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;honda&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-11-05&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">80000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bmw&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-01-01&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;price&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">25000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;color&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;blue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;make&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ford&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;sold&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-02-12&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h6 id="①普通的聚合查询"><a href="#①普通的聚合查询" class="headerlink" title="①普通的聚合查询"></a>①普通的聚合查询</h6><blockquote><p>以汽车中的颜色进行分组聚合，doc_count：表示组数据的数量，每个桶的数量代表改颜色文档数量</p><img src="/2023/03/24/ElasticSearch/41.png" class="" title="ElasticSearch"></blockquote><h6 id="②嵌套聚合查询"><a href="#②嵌套聚合查询" class="headerlink" title="②嵌套聚合查询"></a>②嵌套聚合查询</h6><blockquote><p>在一个聚合查询到数据，再进行聚合，如下面先以color属性聚合数据，然后在每个桶中再聚合price数据求平均值，如下图：</p><img src="/2023/03/24/ElasticSearch/42.png" class="" title="ElasticSearch"></blockquote><h6 id="③filter过滤"><a href="#③filter过滤" class="headerlink" title="③filter过滤"></a>③filter过滤</h6><blockquote><p>filter过滤条件，查询指定的数据进行聚合，如下</p><img src="/2023/03/24/ElasticSearch/43.png" class="" title="ElasticSearch"></blockquote><blockquote><p>filters:对filter进行分组聚合，filters中条件进行过滤，将过滤后相同的数据聚合</p><img src="/2023/03/24/ElasticSearch/44.png" class="" title="ElasticSearch"></blockquote><h6 id="④range聚合"><a href="#④range聚合" class="headerlink" title="④range聚合"></a>④range聚合</h6><blockquote><p>对number类型进行聚合，根据范围值进行聚合，to不包括值。from包括值</p><img src="/2023/03/24/ElasticSearch/45.png" class="" title="ElasticSearch"></blockquote><h6 id="⑤Date-Range聚合"><a href="#⑤Date-Range聚合" class="headerlink" title="⑤Date Range聚合"></a>⑤Date Range聚合</h6><blockquote><p>对日期进行聚合,from和to后面的参数需要按照我们指定的format格式进行输入</p><img src="/2023/03/24/ElasticSearch/46.png" class="" title="ElasticSearch"></blockquote><h6 id="⑥Histogram聚合"><a href="#⑥Histogram聚合" class="headerlink" title="⑥Histogram聚合"></a>⑥Histogram聚合</h6><blockquote><ol><li><p>histogram 桶要求两个参数：一个数值字段以、一个定义桶大小间隔。</p></li><li><p>可以使用各种嵌套聚合，来计算对应区间数据</p><img src="/2023/03/24/ElasticSearch/47.png" class="" title="ElasticSearch"></li></ol></blockquote><h5 id="（2）metrics聚合"><a href="#（2）metrics聚合" class="headerlink" title="（2）metrics聚合"></a>（2）metrics聚合</h5><h6 id="①单值分析：stat类型"><a href="#①单值分析：stat类型" class="headerlink" title="①单值分析：stat类型"></a>①单值分析：stat类型</h6><blockquote><ul><li><p>avg：求指定字段平均值</p><img src="/2023/03/24/ElasticSearch/48.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>max：求指定字段最大值，min：求指定字段最小值</p><img src="/2023/03/24/ElasticSearch/49.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>sum：求指定字段总和</p><img src="/2023/03/24/ElasticSearch/50.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>value_count：求所有统计数量</p><img src="/2023/03/24/ElasticSearch/51.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="②单值分析：其他类型"><a href="#②单值分析：其他类型" class="headerlink" title="②单值分析：其他类型"></a>②单值分析：其他类型</h6><blockquote><ul><li><p>weighted_avg：带权重，求平均值，如：a权重为0.3,b权重为0.7，求平均值：（0.3<em>a+0.7</em>b）&#x2F; 2</p><img src="/2023/03/24/ElasticSearch/52.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>cardinality：指定字段，根据字段值去重</p><img src="/2023/03/24/ElasticSearch/53.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>median_absolute_deviation：指定字段求中位数</p><img src="/2023/03/24/ElasticSearch/54.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="③非单值分析：stats"><a href="#③非单值分析：stats" class="headerlink" title="③非单值分析：stats"></a>③非单值分析：stats</h6><blockquote><ul><li><p>stats包括max、min、avg、sum</p><img src="/2023/03/24/ElasticSearch/55.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>matrix_stats：描述字段之间的关系，针对矩阵模型，count：统计数量，mean：平均值</p><img src="/2023/03/24/ElasticSearch/56.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>extended_stat：指定字段，汇总该字段的所有信息</p><img src="/2023/03/24/ElasticSearch/57.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="④非单值分析：百分型"><a href="#④非单值分析：百分型" class="headerlink" title="④非单值分析：百分型"></a>④非单值分析：百分型</h6><blockquote><ul><li><p>percentiles：根据指定字段计算百分比</p><img src="/2023/03/24/ElasticSearch/58.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>percentile_ranks：指定字段和值，统计该值内数值在总体占比，如下：</p><img src="/2023/03/24/ElasticSearch/59.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="⑤非单值分析：地理位置型"><a href="#⑤非单值分析：地理位置型" class="headerlink" title="⑤非单值分析：地理位置型"></a>⑤非单值分析：地理位置型</h6><blockquote><ul><li><p>geo_bounds：查找指定位置的坐标范围</p><img src="/2023/03/24/ElasticSearch/60.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（3）Pipeline聚合"><a href="#（3）Pipeline聚合" class="headerlink" title="（3）Pipeline聚合"></a>（3）Pipeline聚合</h5><blockquote><p>上一步的·聚合结果成为下一个聚合的输入</p></blockquote><h6 id="①Average聚合"><a href="#①Average聚合" class="headerlink" title="①Average聚合"></a>①Average聚合</h6><blockquote><p>在上一个bucket聚合的结果作为输入，输入到metrics聚合中求平均值</p><img src="/2023/03/24/ElasticSearch/61.png" class="" title="ElasticSearch"></blockquote><h3 id="5、原理分析"><a href="#5、原理分析" class="headerlink" title="5、原理分析"></a>5、原理分析</h3><blockquote><ul><li><p>一个ElasticSearch集群下，有多个node节点组成；</p></li><li><p>每个node节点上有多个分片，分为主分片和复制分片，主分片会将数据同步给复制分片；</p></li><li><p>一个分片对应一个Lucence Index索引结构；</p></li><li><p>一个Lucence Index上有多个Segment（即倒排索引），每个Segment存储文件即为文档数据；</p><img src="/2023/03/24/ElasticSearch/62.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（1）Lucence"><a href="#（1）Lucence" class="headerlink" title="（1）Lucence"></a>（1）Lucence</h5><h6 id="①Segment"><a href="#①Segment" class="headerlink" title="①Segment"></a>①Segment</h6><blockquote><ul><li>Shard&#x3D;Lucene Index</li><li>Lucene Index的Segment存放多种数据结构：<ol><li>Inverted Index（倒排索引）：分为两部分：一个有序的数据字典（单词term和出现频率）和与term对应的Posting列表（存放单词的文件），如：查询hello world时，将其分为hello和world两个单词，组成倒排索引（如下表）</li><li>自动补全：如果要查找以‘c’开头的词，会进行二分查找；</li><li>全表查找：查找包含‘our’字母的单词，会进行全表查询；</li><li>Document Values：列式存储，大大提升访问速度</li></ol></li></ul></blockquote><table><thead><tr><th>Dictionary</th><th>Posting List</th><th></th></tr></thead><tbody><tr><td>term</td><td>freq</td><td>documents</td></tr><tr><td>choice</td><td>1</td><td>2，3，4</td></tr><tr><td>come</td><td>4</td><td>3，5，6</td></tr><tr><td>hello</td><td>2</td><td>6，7，8</td></tr><tr><td>ours</td><td>3</td><td>4，7，8</td></tr></tbody></table><h6 id="②搜索中"><a href="#②搜索中" class="headerlink" title="②搜索中"></a>②搜索中</h6><blockquote><ol><li><p>搜索每一个segament，然后合并搜索结果；</p></li><li><p>Segment是不可变的，删除时，数据依旧保存在文件中，只是标记为删除；更新时，先删除，然后重新索引</p></li><li><p>Lucence会对存储数据进行压缩；</p></li><li><p>lecence会缓存所有数据，提高查询效率；</p><img src="/2023/03/24/ElasticSearch/63.png" class="" title="ElasticSearch"></li></ol></blockquote><h6 id="③缓存"><a href="#③缓存" class="headerlink" title="③缓存"></a>③缓存</h6><blockquote><ol><li>索引文件时，会对文件建立缓存，并定期刷新数据；</li><li>随着数据的增多，会产生大量segment，增加索引文件时，会将segment合并，删除</li></ol></blockquote><h5 id="（2）Shard"><a href="#（2）Shard" class="headerlink" title="（2）Shard"></a>（2）Shard</h5><blockquote><ol><li>Shard可能分布在不同的节点机器上，搜索返回结果会在网络中传输；</li><li>每个节点都会存储一份路由表，记录节点上shard信息等，请求到任何节点，都可以转发到对应的shard上的node节点；</li></ol></blockquote><h5 id="（3）Es分析器"><a href="#（3）Es分析器" class="headerlink" title="（3）Es分析器"></a>（3）Es分析器</h5><blockquote><p>①分为三部分：</p><ul><li>字符串过滤器：字符串分词前，将HTML标签去掉，替换&amp;为and；</li><li>分词器：将字符串分为一个个单词，简单的分词器，遇到空格或标点符号就会分词；</li><li>Token过滤器：将分好的词按顺序进入过滤，可能会改变词，如：小写化，删除无用词条，增加同义词条</li></ul><p>②内置分词器：</p><p>例子：Hello world （5）</p><ul><li>标准分析器：es默认分词器，根据Unicode定义的单词边界划分文本，去除大部分标点符号，最后词条小写，如【hello，world，5】；</li><li>简单分析器：任何不是字母的地方进行分词，最后词条小写，如【hello，world】；</li><li>空格分析器：以空格划分文本，如【Hello，world，（5）】；</li><li>语言分析器：会将无用单词删除，同时提取英语的词干，如</li></ul><p>I am watching TV and doing homework–&gt;【I，am，watch，TV，do，homework】</p></blockquote><h5 id="（4）索引原理"><a href="#（4）索引原理" class="headerlink" title="（4）索引原理"></a>（4）索引原理</h5><h6 id="①文档索引创建流程"><a href="#①文档索引创建流程" class="headerlink" title="①文档索引创建流程"></a>①文档索引创建流程</h6><blockquote><ul><li><p>客户端发送创建索引请求转发到node1节点；</p></li><li><p>根据文档id确定文档分片属于p2，请求转发到Node3；</p></li><li><p>Node3索引数据创建成功，请求转发到Node1，Node2副分片节点上，所有节点创建成功，Node3向协调节点报告成功，协调节点向客户端报告成功；</p><img src="/2023/03/24/ElasticSearch/64.png" class="" title="ElasticSearch"></li></ul></blockquote><h6 id="②索引流程"><a href="#②索引流程" class="headerlink" title="②索引流程"></a>②索引流程</h6><blockquote><ul><li>协调节点通过文档id，计算请求对应的分片，请求转发到对应的节点分片上；</li><li>分片接收到请求后，会将请求数据写入到Memory Buffer中，每隔一秒更新到FileSystem缓存中；</li><li>缓存中的数据可能会丢失，所以每次请求会写入进Transaction日志中（保证可靠性），当缓存数据写入磁盘时，会清除transaction日志；</li><li>transaction日志flush过程中，会将数据刷新到磁盘，同时内容写入一个新的transaction日志中，删除原来的日志，flush每30分钟执行一次，或日志文件大小超过512M时也会触发；</li></ul><p>transLog日志，对未提交的数据，保证对未提交的数据可以通过id实时访问到</p><img src="/2023/03/24/ElasticSearch/65.png" class="" title="ElasticSearch"></blockquote><h6 id="③数据持久化过程"><a href="#③数据持久化过程" class="headerlink" title="③数据持久化过程"></a>③数据持久化过程</h6><blockquote><p>主要步骤：write—refresh—flush—merge</p><ul><li>write：一个新文档会被写入到内存缓冲区中，同时也会写入transLog日志中，此时文档还未写入Segment中，所以是搜索不到新文档的，需要refresh后才能搜索到，Commit point记录所有segment元信息</li><li><img src="/2023/03/24/ElasticSearch/66.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>refresh：每隔一秒执行一次刷新，将数据写入到segment中，segment存储在内存中，且可以在segment中搜索到数据，刷新后，清空内存缓冲区数据；该阶段可能会发送数据丢失</p><img src="/2023/03/24/ElasticSearch/67.png" class="" title="ElasticSearch"></li></ul></blockquote><blockquote><ul><li><p>flush：每隔30分钟或translog日志文件过大时，就会刷新，创建新的translog日志，删除旧日志；</p></li><li><ul><li><p>所有内存缓冲区的数据被写入Segment中；</p></li><li><p>内存缓冲区被清空；</p></li><li><p>将commit point中所有数据写入到磁盘中；</p></li><li><p>此时索引数据已经写入磁盘，已经持久化，因此不需要原日志数据保证数据安全，清除原translog日志；</p><img src="/2023/03/24/ElasticSearch/68.png" class="" title="ElasticSearch"></li></ul></li></ul></blockquote><blockquote><ul><li><p>Merge：每秒刷新会创建大量segment，而搜索时会必须轮询每一个段，段越多，搜索效率越差。es后台会将小段合并，大段合并到更大的段，refresh时，会创建新的段，从已有段选取大小合适的段，与新段合并，然后删除旧的段；</p><img src="/2023/03/24/ElasticSearch/69.png" class="" title="ElasticSearch"></li></ul></blockquote><h5 id="（5）读取文档流程"><a href="#（5）读取文档流程" class="headerlink" title="（5）读取文档流程"></a>（5）读取文档流程</h5><blockquote><ul><li><p>初始查询阶段，查询会广播道每一个分片，每一个分片在本地执行搜索，并构建一个匹配文档大小的from+size队列（文档查询是在FileSystem Cache中查询，可能存在Memory Buffer有数据未刷新到FileSystem Cache中，所以是近实时查询）；</p></li><li><p>每一个分片返回各自的队列，队列中存储文档id，协调节点的队列合并这些分片返回的队列，生成一个全局排序的队列；</p></li><li><p>协调节点分辨出那个文档要取回阶段，根据文档id获取文档完整数据，返回给客户端；</p><img src="/2023/03/24/ElasticSearch/70.png" class="" title="ElasticSearch"></li></ul></blockquote><h3 id="6、索引优化"><a href="#6、索引优化" class="headerlink" title="6、索引优化"></a>6、索引优化</h3><blockquote><ol><li>大量数据提交的时候，采用批量提交（bulk），一次批量提交的请求不超过几十MB，太大会使用过多内存；出现EsRejectExceuttionException异常时，说明es索引已经到极限，应减少数据收集。</li><li>es写入数据采用的是延迟写入数据，每1秒会将Memory Buffer数据刷新（refresh）到Segment中，segment会进行合并，这样数据才能检索到，是近实时的，可以通过延长refresh的时间间隔，减少segment合并压力，提高索引速度（index_refresh_interval）。</li><li>通过设置index_buffer_size大小，调整分配内存大小给索引进程，默认为10%，即该数值内存分配到不同的分片上。</li><li>调整index.translog.sync_interval参数，调整日志刷新到磁盘的大小（默认5秒）,从而减少I&#x2F;O操作，index.translog.flush_threashold_size参数，当达到threshold大小时，才会flush刷新到Lucene索引文件中。</li><li>_id使用es生成的id，避免自定义生成id，以避免对id的版本管理。</li><li>_all包含了所有索引字段，便于全文检索，业务不需要时可以关闭，_source存储了原始文档，如果没有需求获取原始数据，可以通过includes、excludes属性判断数据是否放入_source字段。可以减少数据取回阶段发送的请求。</li><li>es默认副本数量为3，虽然可以提高集群可用性，但会影响写入效率，数据写入后，同时要更新到副节点上，等副节点文档生效后，才会返回。</li></ol></blockquote><h3 id="7、查询优化"><a href="#7、查询优化" class="headerlink" title="7、查询优化"></a>7、查询优化</h3><blockquote><ul><li>路由优化：</li></ul><ol><li><ol><li>不带路由：请求发送到协调节点上，协调节点将请求分发到每一个分片，将每一个分片返回的结果进行排序汇聚，之后返回给用户；</li><li>带routing查询：查询时，根据路由分发到对应的分片上，不用查询所有分片，经过协调节点排序返回，routing设置为用户id，效率会提升；</li></ol></li></ol><ul><li>尽量使用filter替代query，filter对插叙只需回答是或不是，不会计算相关性评分，效率比query高，同时filter可以进行缓存。</li><li>避免大分页，正常分页from到size，是要每个分片查询from+size条数据，即n*（from+size），返回给协调节点进行排序，若数据量过大，会耗费大量CPU资源；可以通过设置文档id为偏移量，将其作为分页条件。</li><li>Cache设置：</li></ul><ol><li><ol><li>QueryCache：filter查询结果后会进行缓存，可以通过设置indicis.queries.cache,size参数，调整缓存大小；</li><li>FieldDataCache：聚类和排序下，可以设置字段数据缓存大小；</li><li>ShardRequestCache：分片查询结果缓存，不会缓存hits内容</li></ol></li></ol><ul><li>避免查询过多数据，避免过深的聚合查询，层级过深的聚合查询，会耗费大量CPU资源；</li></ul></blockquote><h3 id="8、数据结构优化"><a href="#8、数据结构优化" class="headerlink" title="8、数据结构优化"></a>8、数据结构优化</h3><blockquote><ol><li>减少不需要的字段，不需要用于搜索的字段，不要存储到ES中，提高效率，节约空间；</li><li>避免动态映射，动态映射带来不可控制的数据类型，可能导致查询异常；</li><li>document模型设计时，考虑好关联查询等情况，避免在es使用关联查询或更加复杂的操作；</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java遗传算法组卷</title>
    <link href="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/"/>
    <url>/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、遗传算法介绍"><a href="#一、遗传算法介绍" class="headerlink" title="一、遗传算法介绍"></a>一、遗传算法介绍</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote><p>遗传算法是模拟达尔文的生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种随机搜索全局最优解的方法。它模拟自然选择和遗传中发生的<u><strong>复制、交叉、变异</strong></u>等现象。一个种群通过随机选择、变异。交叉。复制，不断产生适应度更大的个体（适应度越大，被选择的概率越大），最终得到一群最适应环境的个体。</p></blockquote><h4 id="2、执行流程"><a href="#2、执行流程" class="headerlink" title="2、执行流程"></a>2、执行流程</h4><h5 id="（1）编码"><a href="#（1）编码" class="headerlink" title="（1）编码"></a>（1）编码</h5><blockquote><p>遗传算法里，优化问题的解被称为个体，基因串代表一个个体。基因串一般被表达为简单的字符串或数字符串，不过也有其他的依赖于特殊问题的表示方法适用；一个基因串可表示如下：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/1.png" class="" title="遗传算法"></blockquote><h5 id="（2）初始胡种群"><a href="#（2）初始胡种群" class="headerlink" title="（2）初始胡种群"></a>（2）初始胡种群</h5><blockquote><p>种群可以看作是个体的集合。初始化种群主要是随机生成一定数量的个体组合为种群；这个初始化的过程我们可以进行干预，以提高初始化种群的质量。每个个体对应一个适应度数值。种群如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/2.png" class="" title="遗传算法"></blockquote><h5 id="（3）进化"><a href="#（3）进化" class="headerlink" title="（3）进化"></a>（3）进化</h5><blockquote><p>进化流程包括：评估适应性函数，根据适应度选择个体，并进行交叉，变异，复制。如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/3.png" class="" title="遗传算法"></blockquote><h3 id="二、遗传算法组卷"><a href="#二、遗传算法组卷" class="headerlink" title="二、遗传算法组卷"></a>二、遗传算法组卷</h3><h4 id="1、试卷编码"><a href="#1、试卷编码" class="headerlink" title="1、试卷编码"></a>1、试卷编码</h4><blockquote><p>（1）题库组卷中，一份试卷代表一个个体，多份试卷组合为一个种群，在种群中，不断进化获取最优解，最终获取适应度最高的试卷，即为最优解；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/5.png" class="" title="遗传算法"><p>（2）个体由基因型表示，试卷主要包括单选题（8道），多选题（2道），判断题（2道），大题（2道），我们以题目的题号（主键id）当做基因型的编号，如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/4.png" class="" title="遗传算法"></blockquote><h4 id="2、初始化种群"><a href="#2、初始化种群" class="headerlink" title="2、初始化种群"></a>2、初始化种群</h4><blockquote><p>（1）试卷难度我们分为简单，中等，难（数据库中题目难度分为三个等级1，2，3）。在题库中选择题目时，按照我们规定的题型比例选取题目。在初始化时，我们进行干预，适当提高种群的适应度。</p><p>（2）用户选择简单，初始化种群时，选择难度&#x3D;1的题目进行组合；用户选择中等，选择难度&#x3D;1或难度&#x3D;2的题目进行组合；用户选择困难，选择难度&#x3D;2的题目进行组合，如下图:</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/6.png" class="" title="遗传算法"></blockquote><h4 id="3、终止条件"><a href="#3、终止条件" class="headerlink" title="3、终止条件"></a>3、终止条件</h4><blockquote><p>（1）题库组卷中，根据用户选择的难度，对应不同的期望度（目标值），试卷的适应度不断趋近这个期望度。</p><p>（2）当试卷适应度&gt;&#x3D;目标期望值，终止寻找，找到最优解；当进化的代数超过我们指定的最大进化数，终止寻找；当试卷适应度已经达到最大适应度，终止寻找</p></blockquote><h4 id="4、适应度函数计算"><a href="#4、适应度函数计算" class="headerlink" title="4、适应度函数计算"></a>4、适应度函数计算</h4><blockquote><p>（1）试卷难度计算公式：题目分值*难度 &#x2F; 总分；</p><p>（2）试卷知识点覆盖率：不同知识点数 &#x2F; 题目总数；</p><p>（3）试卷的适应度，需要考虑到整体试卷的难度以及试卷知识点的覆盖率，N知识点分布权重，M为难度系数所占权重，公式如下：</p><p>适应度&#x3D;不同知识点数 &#x2F; 题目总数<em>N+题目分值</em>难度 &#x2F; 总分*M</p></blockquote><h4 id="5、交叉"><a href="#5、交叉" class="headerlink" title="5、交叉"></a>5、交叉</h4><blockquote><p>（1）在种群中，随机选择两个适应度较高的个体进行交叉（不一定选择到适应度最高的个体），进行基因交换，获取新个体。</p><p>（2）个体选择采用轮盘赌算法，适应度越大的个体，被选中的概率越大（但也不一定被选中），轮盘赌算法如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/7.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/8.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/9.png" class="" title="遗传算法"><p>（3）两个个体进行交叉，利用随机函数产生交叉点，选取父个体边界点左边的编号，选取母个体边界点右边的编号，组合成新的基因，同时要判断是否有重复题型，重复题型则到题库中选取类型，难度一致的题目进行替换</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/10.png" class="" title="遗传算法"></blockquote><h4 id="6、变异"><a href="#6、变异" class="headerlink" title="6、变异"></a>6、变异</h4><blockquote><p>（1）变异是随机的，按照我们指定的变异率，随机选取个体进行变异，变异后的编号若重复，则重新查找；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/11.png" class="" title="遗传算法"><p>（2）题库选题去重，遇到重复题库，先删除，放到删除题库中，等操作完再添加1回去，如下图：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/12.png" class="" title="遗传算法"><p>（3）在种群进化中，按照我们规定的代数n，进化代数达到n，变异率变大2倍，最终不超过我们指定的最大变异率（一般为10%），如：进化代数：n&#x3D;5</p><p>若变异率m&#x3D;0.01，当进化到第五代时，m&#x3D;m*2&#x3D;0.01；当进化到第十代时，m&#x3D;0.04。</p><p>若变异率m&#x3D;0.1，当进化到第五代时，m&#x3D;0.1，当进化到第十代时，m&#x3D;0.1</p></blockquote><h4 id="7、复制"><a href="#7、复制" class="headerlink" title="7、复制"></a>7、复制</h4><blockquote><p>根据个体的适应度进行快速排序（从小到大），然后按照复制的数量，从后往前进行个体复制</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/13.png" class="" title="遗传算法"><p>快排思路：</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/14.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/15.png" class="" title="遗传算法"></blockquote><h4 id="8、修正"><a href="#8、修正" class="headerlink" title="8、修正"></a>8、修正</h4><blockquote><p>（1）在进化时，我们会指定一个m，n和种群最佳适应度s，每一次进化后，会计算种群适应度，大于最佳适应度，更新最佳适应度；m则是种群达不到最佳适应度的最大进化数；n则是实际种群达不到最佳适应度的进化数。</p><p>（2）当进化时，种群的总体适应度达不到最佳适应度，n++，当n&gt;&#x3D;m时，需要进行种群修正，也就是变异，随机选取个体进行变异；</p><p>（3）重新计算种群适应度，更新最佳适应度，将n置0。</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/16.png" class="" title="遗传算法"><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/17.png" class="" title="遗传算法"></blockquote><h4 id="9、整体业务流程"><a href="#9、整体业务流程" class="headerlink" title="9、整体业务流程"></a>9、整体业务流程</h4><blockquote><p>（1）从数据库中查询所有题目，按题型分类存放；</p><p>（2）创建配置类（进化算法需要的参数类），同时处理用户输入过来的参数；</p><p>（3）初始化一个种群（个体编码，组合种群）；</p><p>（4）种群进化，计算适应度，交叉，变异，复制，修正；</p><p>（5）选取种群适应度最高个体，返回结果；</p><img src="/2023/03/18/java%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%84%E5%8D%B7/18.png" class="" title="遗传算法"></blockquote><h4 id="10、github链接"><a href="#10、github链接" class="headerlink" title="10、github链接"></a>10、github链接</h4><blockquote><p><a href="https://github.com/swttws/java-PlateForm-app">https://github.com/swttws/java-PlateForm-app</a></p><p>在src&#x2F;main&#x2F;java&#x2F;com&#x2F;su&#x2F;ga包下</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/17/hello-world/"/>
    <url>/2023/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h4 id="1、进程："><a href="#1、进程：" class="headerlink" title="1、进程："></a>1、进程：</h4><p>（1）运行的程序，例如使用QQ，就启动一个进程，操作系统为该进程分配内存空间；<br>（2）进程是程序的一次执行过程，是动态过程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.jpeg" class="" title="java线程"><h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><p>（1）线程有进程创建，是进程实体；<br>（2）一个进程可以拥有多个线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.jpeg" class="" title="java线程"><h4 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h4><p>同一时刻，多个任务交替执行，单核CPU实现任务就是并发；</p><h4 id="4、并行"><a href="#4、并行" class="headerlink" title="4、并行"></a>4、并行</h4><p>同一时刻，多个任务同时执行，多核CPU可以实现并行；</p><h4 id="5、线程执行机制"><a href="#5、线程执行机制" class="headerlink" title="5、线程执行机制"></a>5、线程执行机制</h4><p>（1）主线程结束，其他子线程还在运行，进程就会继续存活；<br>（2）所有线程挂掉，进程才会挂掉；<br>（3）run()方法为一个普通方法，并不会真正启动线程，会等run执行完毕后才会继续执行下面代码；<br>（4）start（）方法才会启动线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.jpeg" class="" title="java线程"><h4 id="6、线程启动"><a href="#6、线程启动" class="headerlink" title="6、线程启动"></a>6、线程启动</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.jpeg" class="" title="java线程"><p>（1）执行start（）方法<br>同时执行两个线程，一个执行start的线程，一个执行run的线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png" class="" title="java线程"><p>（2）本地方法，JVM调用，底层为c&#x2F;c++实现，真正实现多线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png" class="" title="java线程"><h4 id="7、线程终止唤醒阻塞状态线程"><a href="#7、线程终止唤醒阻塞状态线程" class="headerlink" title="7、线程终止唤醒阻塞状态线程"></a>7、线程终止唤醒阻塞状态线程</h4><p>（1）interrupt：设置共享变量为true，唤醒阻塞线程</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.jpeg" class="" title="java线程"><h4 id="8、join方法"><a href="#8、join方法" class="headerlink" title="8、join方法"></a>8、join方法</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/9.jpeg" class="" title="java线程"><h2 id="二、Thread线程常用方法"><a href="#二、Thread线程常用方法" class="headerlink" title="二、Thread线程常用方法"></a>二、Thread线程常用方法</h2><p>1、join（）方法：线程插队，线程一旦插队成功，肯定先执行完插入的线程的所有任务；<br>2、yield：让出CPU，让其他1线程执行，礼让时间不确定，不一定礼让成功<br>3、守护线程：当所有的用户线程结束，守护线程就会结束；<br>例：垃圾回收机制</p><h2 id="三、线程状态"><a href="#三、线程状态" class="headerlink" title="三、线程状态"></a>三、线程状态</h2><p>（1）java线程中有6种状态；<br>（2）操作系统中有5种状态；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.jpeg" class="" title="java线程"><h2 id="四、线程同步与锁"><a href="#四、线程同步与锁" class="headerlink" title="四、线程同步与锁"></a>四、线程同步与锁</h2><p>1、线程同步机制：使用同步机制保证数据在任何同一时刻，最多只有一个线程访问，以保证数据完整；<br>2、Synchronized同步原理：</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/11.jpeg" class="" title="java线程"><p>3、互斥锁：<br>（1）每个对象都有一个可称为“互斥锁”的标记，这个标记只能保证任意时刻只有一个线程访问该对象；<br>（2）影响程序执行效率；<br>（3）同步方法（非静态的）的锁可以是this对象，也可以是其他对象；<br>（4）同步方法（静态的）的锁为当前类本身；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/12.png" class="" title="java线程"><p>4、线程死锁：多个线程占用对方资源，不肯相让，导致形成死锁；<br>5、释放锁：<br>（1）线程同步方法，同步代码块执行结束；<br>（2）线程同步方法、同步代码块遇到break、return；<br>（3）出现未处理的error或Exception，导致异常结束；<br>（4）执行线程中wait（）方法，线程暂停，释放锁<br>sleep（），yield（），suspend（)不会释放锁</p><hr><h2 id="1、Object-wait"><a href="#1、Object-wait" class="headerlink" title="1、Object.wait()"></a>1、Object.wait()</h2><p>（1）一定要持有到调wait方法那个对象的锁，wait代码段放在synchronized块中；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/13.png" class="" title="java线程"><p>（2）持有该对象锁的线程，执行notify或notifyAll方法可以唤醒等待线程；<br>（3）调用wait后，会将该对象锁释放，进入等待状态，线程加入waitSet集合，waitSet底层是双向链表；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/14.png" class="" title="java线程"><p>（4)该线程被唤醒后，会与其他线程公平竞争该对象锁，只有该线程获取到对象锁后，才会继续往下执行；</p><hr><h2 id="2、Object-notify-、notifyAll（）"><a href="#2、Object-notify-、notifyAll（）" class="headerlink" title="2、Object.notify()、notifyAll（）"></a>2、Object.notify()、notifyAll（）</h2><p>（1）当调用对象notify方法时，会随机唤醒等待集合中一个线程，唤醒线程与其他线程公平竞争锁；<br>  从WaitSet集合中选出一个线程，加入到EntryLsit集合中<br>（2）当调用notifyAll方法时，唤醒等待集合所有线程；<br>（3）在某一时刻，只有唯一线程可以获取对象锁；</p><hr><h2 id="3、synchronized关键字"><a href="#3、synchronized关键字" class="headerlink" title="3、synchronized关键字"></a>3、synchronized关键字</h2><p>（1）同一个对象，多个synchronized方法，多个线程某一个时刻同时访问，只能先执行一个方法；（锁为对创建的对象锁）<br>（2）synchronized修饰的静态方法，多个对象中，多个线程只能访问一个线程去访问（对该对象的Class对象加锁）；<br>（3）synchroinzed修饰代码块，通过 monitorenter和monitorexit来获取锁和释放锁；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/15.png" class="" title="java线程"><p>（4）JVM同步基于进入与退出监视器对象（Monitor）来实现，每个对象实例·会有个Monitor对象，monitor对象和java对象一并创建并销毁，monitor由c++创建；<br>（5）多个线程访问一段同步代码块，获取不到锁的线程会放入Entrylist集合，处于阻塞的线程会被放入该集合中，当线程获取到Monitor对象时，monitor对象依赖于底层操作系统的mutex_lock（互斥锁），线程获取成功后，会持有mutex，其他线程无法获取mutex；<br>（6）基于底层操作系统的mutex_Lock来实现，每次锁的获取与释放都会带来用户态与内核态的切换，并发量高时，synchronized锁性能非常差；<br>（7）调用wait方法的线程会进入waitset集合，处于阻塞状态的线程会进入EntryList集合中，waitset中的线程被notify唤醒后，若争抢不到锁，线程会加入EntryList集合，进而进入内核状态；<br>解决上述方法：自旋，其原理：发生岁monitor的争用时，若Owner能够很短时间内释放该锁，则那些正在争用的线程可以自旋，在Owner释放锁后，会立即获取到锁，从而避免阻塞，争用一段时间后若无法获取锁，则进入阻塞状态。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/16.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/17.png" class="" title="java线程"><p>（8)互斥锁属性<br>【1】P_THREAD_MUTEX_TMIED_NP：普通锁，当一个线程加锁后，其余线程进入等待队列，并且在解锁后按照优先级获取锁，从而确保资源分配的公平性；<br>【2】P_THREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并通过unlock进行解锁，如果是不同新城请求，可通过加锁线程解锁后重新进行竞争；<br>【3】P_THREAD_MUTEX_ERRORCHECK_NP：检错锁，一个线程请求同一个锁，则返回EDEADLK，否则与【1】锁一样，不允许多次加锁时不会出现死锁；<br>【4】P_THREAD_MUTEX_ADAPTIVE_NP：适应锁，仅仅等待解锁后重新竞争；</p><hr><h2 id="4、锁"><a href="#4、锁" class="headerlink" title="4、锁"></a>4、锁</h2><p>（1）对于锁的访问与java对象头相关，java对象头包括Mark Word、指向类指针、数组长度；<br>（2）Mark Word记录了对象、锁及垃圾回收相关信息，包括如下组成部分：<br>【1】无锁标记<br>【2】偏向锁标记<br>【3】轻量级锁标记<br>【4】重量级锁标记：synchroinzed标记<br>【5】GC标记<br>（3）锁演化阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<br>（4）偏向锁：<br>对于一个线程，主要作用是优化同一个线程多次获取同一个一个锁的情况，如果一个synchroinzed方法被一个线程访问，synchroinzed方法所在对象就会在起Mark Word中将偏向锁标记，同时还有一个字段存储线程id，，当这个线程继续访问同一个synchroinzed方法时，他会检查这个对象的Mark Word偏向锁标记以及是否指向该id：(建议关闭偏向锁)<br>【1】如果是同一个线程，线程无须进入内核态，而是直接进入方法中；<br>【2】如果是另外一个线程访问synchroinzed方法，偏向锁取消；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/18.png" class="" title="java线程"><p>（5）轻量级锁：（适合两个线程轮流访问），如自旋锁<br>若第一个线程已经获取到当前对象锁，这时第二个线程尝试争抢该对象锁，由于该对象的锁已经被第一个线程获取到，因此他是偏向锁。第二个线程在争抢时，会发现对象头中的Mark Word已经是偏向锁标记，，但里面存储的id并不是自己，则会进行CAS，从而获取到锁。两种情况：<br>【1】获取锁成功：会将Mark Word里的线程id由第一个线程变成自己的，这样对象依旧保持偏向锁状态；<br>【2】获取失败：则表示这可能有多个线程争抢对象锁，那么偏向锁升级，升级为轻量锁；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/19.png" class="" title="java线程"><p>（6）重量级锁<br>若自旋失败，锁会转换为重量级锁，无法获取到锁的对象都会进入Monitor（内核态)；自旋可以避免线程从用户态进入内核态；</p><hr><h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>（1）死锁线程1等待线程2互斥持有的资源，线程2等待线程1互斥持有的资源，两个线程无法继续执行；<br>（2）活锁：线程持续重试一个总是失败的操作，导致无法继续操作；<br>（3）饿死：线程一直被调度器延迟访问其可执行的资源，调度器先于优先级低的线程而执行高优先级线程，则总是执行高优先级线程，导致该线程一直无法执行；</p><hr><h2 id="6、Lock锁机制"><a href="#6、Lock锁机制" class="headerlink" title="6、Lock锁机制"></a>6、Lock锁机制</h2><p>（1）lock与synchroinzed区别：<br>【1】锁释放：lock必须通过unlock方法在finally中手动释放，synchroinzed通过jvm释放，synchroinzed锁的释放是按照加锁时的相反顺序释放，如加A锁，再加B锁，先释放B锁，再释放A锁，Lock锁的释放可以以任意顺序释放；<br>【2】锁获取：lock通过代码手工获取锁，synchroinzed通过jvm获取锁，无需开发者干预；<br>【3】具体实现方式：lock通过java代码实现，synchroinzed通过jvm底层实现；<br>【4】锁类型：lock提供多种，如公平锁，非公平锁，synchroinzed与lock均提供可重入锁；<br>（2）tryLock（）方法：获取到锁会返回true，获取不到则会放回false</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/20.png" class="" title="java线程"><p>（3）ReentrantLock 可重入锁：一个线程可以重复获取同一个锁，即使锁没有释放；</p><hr><h2 id="7、Condition"><a href="#7、Condition" class="headerlink" title="7、Condition"></a>7、Condition</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/21.png" class="" title="java线程"><p>（1）await</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/22.png" class="" title="java线程"><p>（2）condition.signal()<br>①原tail结点是CANCELLED状态；<br>②condition的结点transfer到AQS队列之后，通过lock.unlock()去唤醒；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/23.png" class="" title="java线程"><p>（3）传统可以通过synchroinzed+wait+notify&#x2F;notigyAll来实现多个线程之间的通信，整个过程由JVM实现，开发者无需了解底层实现细节；<br>（4）从jdk1.5后，并发包提供lock和Condition（await与signal&#x2F;signalAll）来实现多个线程之间通信，整个过程由开发者控制；<br>（5）Conditidion支持一个对象拥有多个waitset等待集合，而传统方式只允许有一个waitset集合；<br>（6）Condition必须关联一个lock,一个lock可以生成多个condition对象；<br>（7）await（）方法为避免被假唤醒，应当放入while循环中，调用await后会释放锁，需要signal（)方法唤醒才能继续执行；</p><hr><h2 id="8、volatile关键字（保证可见性）"><a href="#8、volatile关键字（保证可见性）" class="headerlink" title="8、volatile关键字（保证可见性）"></a>8、volatile关键字（保证可见性）</h2><p>（1）实现long&#x2F;double类型变量的原子操作，变量不会从寄存器获取变量，而是从内存（高速缓存）中获取；要实现原子性，等号右侧的赋值变量中不能出现被多线程所共享的变量，即使这个变量被volatile修饰也不行；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/24.png" class="" title="java线程"><p>（2）指令重排序</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/25.png" class="" title="java线程"><p>（3)内存屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<span class="hljs-comment">//volatile会自动生成屏障</span><br><br>CPU0&#123;<br>a=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//storeMemoryBarrier()写屏障，写入到内存中</span><br>b=<span class="hljs-number">1</span>;<br>&#125;<br><br>CPU1&#123;<br><span class="hljs-keyword">while</span>(b==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//true</span><br>        <span class="hljs-comment">//loadMemoryBarrier();读屏障</span><br>        <span class="hljs-keyword">assert</span>(a==<span class="hljs-number">1</span>)<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/26.png" class="" title="java线程"><p>（4）防止指令重排序，实现变量的可见性的手段：内存屏障</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/27.png" class="" title="java线程"><hr><h2 id="9、java内存模型（JMM）"><a href="#9、java内存模型（JMM）" class="headerlink" title="9、java内存模型（JMM）"></a>9、java内存模型（JMM）</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/28.png" class="" title="java线程"><p>（1）顺序执行（限定在当个线程之上）:该线程的每个动作都happen-before它的后面动作；<br>（2）隐式锁（monitor）规则：unlock happen-before lock，之前的线程对于同步代码块的所有执行结果对于后序获取锁的线程来说都是可见的；<br>（3）volatile读写规则：对于一个volatile变量的写操作一定会happen-before后续对该变量的读操作；<br>（4）多线程启动规则：Thread对象的start方法happen-before该线程run方法中的任何一个动作，包括其中启动的任何子线程；<br>（5）多线程的终止规则：一个线程启动一个子线程，并且调用子线程join方法等待其结束那么当子线程结束后，父线程接下来的所有操作都可以看到子线程run方法中的执行结果；<br>（6)线程中断规则:可以用interrupt方法来中断线程，这个调用happen-before对该线程中断的检查；</p><hr><h2 id="10、CountDownLatch"><a href="#10、CountDownLatch" class="headerlink" title="10、CountDownLatch"></a>10、CountDownLatch</h2><p>（1）countDown（）方法：计数器不为0，计数器值减减，计数器最小值为0；<br>（2）await（）方法：调用该方法的线程，判断计数器是否为0，不为0，则阻塞，为0，直接继续执行线程；<br>（3）计数器为一次性的；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/29.png" class="" title="java线程"><p>（4)唤醒线程源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>   <span class="hljs-comment">//s为null，并行操作中，添加时，可能还没有执行next=线程，导致head.next=null</span><br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>           s = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//往尾结点找head.next</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                   s = t;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>           LockSupport.unpark(s.thread);<br>   &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="11、CyclicBarrier"><a href="#11、CyclicBarrier" class="headerlink" title="11、CyclicBarrier"></a>11、CyclicBarrier</h2><p>（1）await（int count）方法，等待线程达到指定数量count，才能继续执行；<br>（2）计数器可以重用，计数器值为0后，值置为初始值；<br>（3）CyclicBarrier(int parties, Runnable barrierAction)，barrierAction在最后一个线程抵达屏障后，会执行；<br>（4）会出现并发情况；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/30.png" class="" title="java线程"><p>（4）底层执行流程：<br>【1】初始化各种成员变量，包括parties，count以及Runable；<br>【2】调用await方法时，底层会先检查是否已经归0，如果是，执行可选的Runable，接下来进行下一个generation；<br>【3】在下一个分代中，将会重置count为parties，并且创建新的Generation实例；<br>【4】接下来signalAll方法，唤醒所有在屏障前面等待线程，让其继续开始执行；<br>【5】计数器没有归0，调用线程将会通过Condition的await方法在屏障前等待；<br>【6】执行过程在lock锁内，不会出现并发情况；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/31.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/32.png" class="" title="java线程"><hr><p><strong>12、CAS（Compare And Swap）</strong><br>（1）synchronized关键字与lock锁等锁机制都是悲观锁：无论任何操作，首先要获取锁，再执行后续操作，从而确保所有操作都是由当前这个线程来执行的；<br>（2）乐观锁：线程操做之前不会做任何预先处理，而是直接执行，当在最后执行变量更新的时候，当前线程需要由一种机制确保当前被操作的变量没有被其他线程修改；<br>（3）CAS为乐观锁的一种实现方式，比较与交换，不断循环，直到变量被成功修改为止，CAS本身通过硬件指令来提供支持，硬件通过一个指令来实现交换与比较，因此CAS可以确保变量操作的原子性；<br>（4）CAS操作数涉及如下：<br>【1】需要被操作的内存值V；<br>【2】需要进行比较的值A；<br>【3】需要进行写入的值B；<br>【4】只有当V&#x3D;&#x3D;A时，CAS才会通过原子操作的手段来将V的值更新为B；<br>（5）问题：<br>【1】循环开销问题：并发量大的情况下会导致线程一直自旋；<br>【2】只能保证一个变量的原子操作：可以通过AtomicReference来实现对多个变量的原子操作；<br>【3】ABA问题：1-&gt;3-&gt;1</p><hr><h2 id="13、CompletableFuture"><a href="#13、CompletableFuture" class="headerlink" title="13、CompletableFuture"></a>13、CompletableFuture</h2><p>异步执行，whenComplete（）等待任务执行返回结果，不会阻塞主线程的执行</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/33.png" class="" title="java线程"><hr><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><p>（1）本质上·，ThreadLocal是通过空间换取时间，从而实现每一个线程中间都会有一个变量的副本，这样每个线程都会操作该变量副本，从而避免多线程并发问题；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/34.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/35.png" class="" title="java线程"><p>（2）ThreadLocl与该运行的线程相绑定，每个线程对应不同ThreadLocal；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/36.png" class="" title="java线程"><p>（3）java四种类型引用<br>【1】强引用：new一个实例，GC不会回收new出来实例对象；<br>【2】软引用：如果GC内存空间回收时，空间不够，会清除软引用，空间够，则不会清楚；<br>【3】弱引用：下一次GC回收，会被清理；<br>【4】虚引用：指向队列的元素被清理时，会收到通知<br>（4）Entry使用弱引用为了避免内存泄漏<br>【1】若Entry中使用强引用，当栈中ThreadLocal引用销毁时，Entry中的kv一直存在，导致Entry的kv一直增加，导致内存泄漏；<br>【2】使用弱引用可以保证，当堆中的ThreadLocal对象只被弱引用所指向，会被GC回收，Entry中的Key置为null；<br>【3】当调用ThreadLocal的set和get方法时，会清除键为null的Entry对象；也可以通过调用remove方法删除指定key的Entry对象</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/37.png" class="" title="java线程"><hr><h2 id="15、AQS（AbstractQueuedSynchronizer）"><a href="#15、AQS（AbstractQueuedSynchronizer）" class="headerlink" title="15、AQS（AbstractQueuedSynchronizer）"></a>15、AQS（AbstractQueuedSynchronizer）</h2><h4 id="（1）组成"><a href="#（1）组成" class="headerlink" title="（1）组成"></a>（1）组成</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/38.png" class="" title="java线程"><h4 id="（2）可重入锁（ReentrantLock）源码分析"><a href="#（2）可重入锁（ReentrantLock）源码分析" class="headerlink" title="（2）可重入锁（ReentrantLock）源码分析"></a>（2）可重入锁（ReentrantLock）源码分析</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/39.png" class="" title="java线程"><p>【1】尝试获取对象锁，获取不到（其他线程已经持有锁，并且尚未释放）,该线程会进入AQS阻塞队列中；<br>【2】如果获取到锁，那么根据是公平锁还是非公平锁进行不同处理：<br>①如果是公平锁，线程直接放入AQS队列尾部；<br>②如果是非公平锁，线程会先进行CAS计算，，如果成功直接获取锁，如果失败，则与公锁一致，被放入阻塞队列末尾；<br>③当锁被释放（调用unlock），那么会调用release方法对static成员变量值一直减一操作，如果减一后，state为0，那么relaease执行完毕，并且调用LockSupport的unpark方法唤醒该线程后的等待队列中的第一个后继线程，将其唤醒，使之获取到对象锁；锁可以重入，多次调用lock锁，导致每一次调用，state都会加1；<br>【3】本质上是对AQS的state成员变量操作，对该成员变量加1，表示上锁，减1，表示释放锁；<br>公平锁上锁</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/40.png" class="" title="java线程"><p>非公平锁上锁</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/41.png" class="" title="java线程"><h4 id="（3）可重入读写锁（ReentrantReadWriteLock）"><a href="#（3）可重入读写锁（ReentrantReadWriteLock）" class="headerlink" title="（3）可重入读写锁（ReentrantReadWriteLock）"></a>（3）可重入读写锁（ReentrantReadWriteLock）</h4><p>【1】读锁：获取读锁时，会尝试判断当前对象是否拥有写锁，如果已经拥有写锁，直接失败，如果没有写锁，则表示当前对象没有排他锁，则当前线程会尝试对象加锁，，如果当前线程已经拥有该对象的锁，直接将读锁数量加1；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/42.png" class="" title="java线程"><p>【2】写锁：获取写锁时，会尝试当前对象是否拥有锁（读锁与写锁），如果已拥有锁并且线程并非当前线程，直接失败；如果当前对象没有加锁，就会为当前对象上锁，并且将写锁数量加1，将当前对象的排他锁线程持有者设为自己；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/43.png" class="" title="java线程"><p>【3】读锁释放：</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/44.png" class="" title="java线程"><p>【4】写锁释放</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/45.png" class="" title="java线程"><h4 id="（4）条件队列与阻塞队列"><a href="#（4）条件队列与阻塞队列" class="headerlink" title="（4）条件队列与阻塞队列"></a>（4）条件队列与阻塞队列</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/46.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/47.png" class="" title="java线程"><h4 id="（5）阻塞队列（BlockingQueue）"><a href="#（5）阻塞队列（BlockingQueue）" class="headerlink" title="（5）阻塞队列（BlockingQueue）"></a>（5）阻塞队列（BlockingQueue）</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/48.png" class="" title="java线程"><h4 id="（5）AQS与synchronized关系"><a href="#（5）AQS与synchronized关系" class="headerlink" title="（5）AQS与synchronized关系"></a>（5）AQS与synchronized关系</h4><p>【1】synchronized在实现<br>①存在两个数据结构：waitset，EntryList，waitset中存放的是调用了Object的wait方法的线程对象，EntryList存放的陷入到阻塞状态，需要获取monitor线程对象<br>②当一个线程被notify后，线程会从waitset中移动到EntryList中，进入到EntryList后，该线程依旧需要与其他线程争抢monitor对象，如果争抢到，就获取到锁，可以执行；<br>【2】AQS实现<br>①存放两种数据结构：Conditiojn对象上的条件队列，以及AQS的阻塞队列，这两个对象每一个都是Node实例（封装线程对象）<br>②当位于condition条件队列的线程被其他线程signal后，该线程会被移动到阻塞队列中，位于AQS阻塞队列中的Node对象本质上由一个双向队列构成；<br>③在获取AQS锁中，这些进入阻塞队列的线程会按照队列顺序先后尝试获取；<br>④当AQS阻塞队列中线程获取到锁后表示该线程可以正常执行；<br>⑤陷入对等或阻塞状态的线程，依然需要进入操作系统内核态，进入阻塞（park方法实现）；</p><hr><h2 id="16、ConcurrentHashMap"><a href="#16、ConcurrentHashMap" class="headerlink" title="16、ConcurrentHashMap"></a>16、ConcurrentHashMap</h2><h3 id="（1）结构"><a href="#（1）结构" class="headerlink" title="（1）结构"></a>（1）结构</h3><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/49.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/50.png" class="" title="java线程"><h3 id="（2）put方法"><a href="#（2）put方法" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/51.png" class="" title="java线程"><h4 id="（1）初始化"><a href="#（1）初始化" class="headerlink" title="（1）初始化"></a>（1）初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<span class="hljs-comment">//初始化</span><br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//添加位置结点为空</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<span class="hljs-comment">//添加结点</span><br>                    <span class="hljs-keyword">break</span>;                  <br>              &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>       Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>        <span class="hljs-comment">//多个线程操作，需要不断自旋判断数组是否尾空</span><br>       <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>               Thread.<span class="hljs-keyword">yield</span>(); <br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//只有一个线程进入</span><br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<span class="hljs-comment">//默认长度16</span><br>                       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                       table = tab = nt;<br>                       sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<span class="hljs-comment">//扩容因子  16*0.75</span><br>                   &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                   sizeCtl = sc;<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> tab;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="（2）put阶段存在hash冲突"><a href="#（2）put阶段存在hash冲突" class="headerlink" title="（2）put阶段存在hash冲突"></a>（2）put阶段存在hash冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>        binCount = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录链表长度，用于后面判断是否需要树华</span><br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>            K ek;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                ((ek = e.key) == key ||<br>                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="hljs-comment">//key的值与存在结点的key一样，直接替换</span><br>                oldVal = e.val;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                    e.val = value;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Node&lt;K,V&gt; pred = e;<span class="hljs-comment">//记录前驱结点</span><br>            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//直到下一个结点为null，添加新结点到位部</span><br>                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                          value, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）元素个数统计与更新（addCount）"><a href="#（3）元素个数统计与更新（addCount）" class="headerlink" title="（3）元素个数统计与更新（addCount）"></a>（3）元素个数统计与更新（addCount）</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/52.png" class="" title="java线程"><h5 id="①初始化"><a href="#①初始化" class="headerlink" title="①初始化"></a>①初始化</h5><blockquote><p>private transient volatile long baseCount; 没有竞争情况下，通过CAS更新元素个数<br>private transient volatile CounterCell[] counterCells;  多线程竞争情况下，存储元素个数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterCell</span> &#123;<br>       <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>       CounterCell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>   &#125;<br><br><span class="hljs-comment">//求总和</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>       CounterCell[] as = counterCells; CounterCell a;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>       <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>               <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                   sum += a.value;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> sum;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>直接访问baseCount累加元素个数；</li><li>找到CounterCell[]随机下标位置，累加个数</li><li>如果前面失败，进入fullAddCount（）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> ||<br>     <span class="hljs-comment">//CAS修改元素个数，修改成功则不进入if</span><br>    !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>    CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>     <span class="hljs-comment">//counterCells数组为空</span><br>    <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>        (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>        <span class="hljs-comment">//CAS修改对应CounterCells，修改成功，不进入if</span><br>        !(uncontended =<br>          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>        fullAddCount(x, uncontended);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    s = sumCount();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②元素个数并发更新（fullAddCount）"><a href="#②元素个数并发更新（fullAddCount）" class="headerlink" title="②元素个数并发更新（fullAddCount）"></a>②元素个数并发更新（fullAddCount）</h5><blockquote><ol><li>CountCell为null</li><li>已经初始化，然后存在竞争，CAS进行更新-&gt;失败触发CounterCell扩容</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">CounterCell[] as; CounterCell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br><span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;            <br>            <span class="hljs-type">CounterCell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x); <br>            <span class="hljs-comment">//修改cellBusy为1，表示只有一个线程操作</span><br>            <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; <br>                U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                    CounterCell[] rs; <span class="hljs-type">int</span> m, j;<br>                    <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                        (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                        rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                        rs[j] = r;<br>                        created = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (created)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>            &#125;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>        wasUncontended = <span class="hljs-literal">true</span>;      <br>    <span class="hljs-comment">//存在，CAS修改</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>        collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>        collide = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//容量不够，需要扩容</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>             U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>                CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<span class="hljs-comment">//n为原本as的长度</span><br>                    rs[i] = as[i];<br>                counterCells = rs;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cellsBusy = <span class="hljs-number">0</span>;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>    &#125;<br>    h = ThreadLocalRandom.advanceProbe(h);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp; <span class="hljs-comment">//cellsBusy互斥变量</span><br>         U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//类似加锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                          <br>        <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<span class="hljs-comment">//x元素个数</span><br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<span class="hljs-comment">//释放</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, v = baseCount, v + x))<br>       <span class="hljs-keyword">break</span>;    <br></code></pre></td></tr></table></figure><h4 id="（4）扩容阶段"><a href="#（4）扩容阶段" class="headerlink" title="（4）扩容阶段"></a>（4）扩容阶段</h4><blockquote><ul><li>元素个数大于数组长度</li><li>此时正在扩容，扩容阶段进入的线程会协助扩容</li><li>数组长度大于64，链表长度大于等于8</li></ul></blockquote><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/53.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/54.png" class="" title="java线程"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>    Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>     <span class="hljs-comment">//添加元素大于阈值，需要扩容</span><br>    <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>           (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">    rs二进制：</span><br><span class="hljs-comment">    0000 0000 0000 0000  1000 0000 0001 1100</span><br><span class="hljs-comment">        rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2：</span><br><span class="hljs-comment">        1000 0000 0001 1100（扩容标记）  0000 0000 0000 0010（参与扩容线程数）</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>        <span class="hljs-comment">//表示已经有线程正在扩容</span><br>        <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//表示不需要协助扩容</span><br>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//需要协助扩容，sc记录参与扩容的线程数</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<span class="hljs-comment">//sc二进制运算</span><br>                transfer(tab, nt);<br>        &#125;<br>        <span class="hljs-comment">//没有线程在扩容，第一次扩容+2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                     (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<span class="hljs-comment">//左移16位，最高位为1</span><br>            transfer(tab, <span class="hljs-literal">null</span>);<span class="hljs-comment">//第一次扩容</span><br>        s = sumCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        nextTable = <span class="hljs-literal">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        finishing = advance = <span class="hljs-literal">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//tab获取数组下标</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br></code></pre></td></tr></table></figure><hr><h2 id="17、线程池"><a href="#17、线程池" class="headerlink" title="17、线程池"></a>17、线程池</h2><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/55.png" class="" title="java线程"><h4 id="（1）线程池构建（ThreadPoolExecutor）"><a href="#（1）线程池构建（ThreadPoolExecutor）" class="headerlink" title="（1）线程池构建（ThreadPoolExecutor）"></a>（1）线程池构建（ThreadPoolExecutor）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>【1】int corePoolSize：线程池中一直维护的线程数量，如果线程池处于任务空闲期间，该线程不会被回收调掉；<br>【2】int maximumPoolSize：线程池中所维护线程数的最大数量；<br>【3】long keepAlivePoolSize：临时线程存活时间，超过corePoolSize的线程在金经过KeepAliveTime时间后如果一直处于空闲状态，那么超过的线程将会被回收掉；<br>【4】TimeUnit unit： keepAlivePoolSize的时间单位；<br>【5】BlockingQueue<Runable> workQueue：向先池所提交的任务位于的阻塞队列，实现有多种；<br>【6】ThreadFactory threadFactory：线程工厂，用于创建新的线程并被线程池管理，默认线程工厂所创建的线程都是用户线程且优先级为正常优先级；<br>【7】RejectdExecutionHandler hadler：表示当前线程都在忙于执行任务，并且阻塞队列已满的情况下,新到来的任务该如何对待和处理（拒绝策略）；</p><h4 id="（2）拒绝策略："><a href="#（2）拒绝策略：" class="headerlink" title="（2）拒绝策略："></a>（2）拒绝策略：</h4><p>【1】AbortPolicy：直接抛出一个运行异常；<br>【2】DiscardPolicy：默默丢弃提交任务，不做任何处理，且不抛出异常<br>【3】DiscardOldestPolicy：丢弃阻塞队列中存放时间久的任务（队头元素），并且为当前所提交的任务留出一个队列空闲空间，将其放入队列；<br>【4】CallerRunsPolicy：直接由提交任务的线程来运行这个提交的任务（调用run方法）；</p><h4 id="（3）线程池总体策略"><a href="#（3）线程池总体策略" class="headerlink" title="（3）线程池总体策略"></a>（3）线程池总体策略</h4><p>【1】如果线程池正在执行的线程数&lt;corePoolSize，那么线程池就会优先选择新创建的线程来执行任务，而非将提交的任务加到阻塞队列中；<br>【2】如果线程中正在执行的线程数&gt;&#x3D;corePoolSize，那么线程池就会优先选择对提交的任务进行阻塞排队，而非创建新的线程；<br>【3】如果提交的任务无法加入到阻塞队列中，那么线程池就会创建新的线程，如果创建的线程数超过maximumPoolSize，那么拒绝策略起作用；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/56.png" class="" title="java线程"><h4 id="（4）线程池维护状态"><a href="#（4）线程池维护状态" class="headerlink" title="（4）线程池维护状态"></a>（4）线程池维护状态</h4><p>【1】线程池本身状态：ctl高三位来表示<br>【2】线程池中所运行线程数量：ctl其余29位表示；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/57.png" class="" title="java线程"><p>【3】RUNNING ：线程池可以接收新的任务提交，并且可以正常处理阻塞队列中的任务；<br>【4】SHUTDOWN ：不再接收新的任务提交，不过线程池可以正常处理阻塞队列中的任务；<br>【5】STOP ：不在接收新的任务，同时丢弃阻塞队列中的任务，中断正在处理中的任务；<br>【6】TIDYING ：所有任务都执行完毕后（包括阻塞队列中的任务），当前线程中的活动的线程数量降为0，调用terminated方法；<br>【7】TERMINATED ：线程终止状态，当terminated方法执行完毕后，线程池会处于该状态之下；<br>【8】RUNNING  -&gt;  SHUTDOWN :当调用线程池shutdown方法时，或者调用finalize方法后（该放啊内部调用shutdown方法）；<br>【9】RUNNING， SHUTDOWN  -&gt; STOP：当调用线程池shutdownNow方法；<br>【10】SHUTDOWN -&gt; TIDYING：在线程池与阻塞队列均为空时；<br>【11】STOP -&gt; TIDYING：线程池为空时；<br>【12】TIDYING -&gt; TERMINATED：在terminated方法执行完毕后。</p><h4 id="（5）线程池任务提交"><a href="#（5）线程池任务提交" class="headerlink" title="（5）线程池任务提交"></a>（5）线程池任务提交</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/58.png" class="" title="java线程"><p>【1】两种提交方式：submit和execute<br>【2】submit三种提交方式，无论哪种方式，最终将转换来的任务转换为一个Callable对象来处理；<br>【3】当Callable对象构造完毕后，最终会调用Executor接口声明的execute方法执行；<br>【4】execute方法源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//创建线程</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">//线程执行体添加到阻塞队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//线程没有running，移除任务成功</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//队列满，线程超过最大值，拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/59.png" class="" title="java线程"><p>【5】addWorker（)方法分析：创建线程并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">//增加线程数量</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">//判断线程是否处于终止状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<span class="hljs-comment">//获取线程数量</span><br>            <span class="hljs-comment">//判断线程数量是否超出</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//false表示阻塞队列满</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//修改线程数量</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//创建一个线程</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            <span class="hljs-comment">//加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123; <br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    <span class="hljs-comment">//hashSet存储工作线程</span><br>                    workers.add(w);<br>                    <span class="hljs-comment">//更新线程最大数量</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">//添加失败，删除线程</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/60.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/61.png" class="" title="java线程"><h4 id="（6）线程池任务的执行流程（Worker的run方法）"><a href="#（6）线程池任务的执行流程（Worker的run方法）" class="headerlink" title="（6）线程池任务的执行流程（Worker的run方法）"></a>（6）线程池任务的执行流程（Worker的run方法）</h4><p>getTask（）从阻塞队列获取队头任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 线程数量大于核心数量，返回null，回收线程</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-comment">//工作线程大于最大线程或核心线程数，工作线程减1</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//工作线程减一</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                <span class="hljs-comment">//阻塞队列为空，</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                <span class="hljs-comment">//获取不到数据，线程阻塞（工作线程数小于核心线程数）</span><br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runWorker（）执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//任务不为空，为空，线程结束（线程销毁）</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//任务执行，任务为实现Runable的run方法</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/62.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/63.png" class="" title="java线程"><h4 id="（7）线程池终止"><a href="#（7）线程池终止" class="headerlink" title="（7）线程池终止"></a>（7）线程池终止</h4><p>【1】shutdown（）方法：拒绝新任务提交，会继续执行完阻塞队列中的任务后，才会进入终止状态；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/64.png" class="" title="java线程"><p>interruptIdleWorkers()方法</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/65.png" class="" title="java线程"><p>tryTerminate()方法</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/66.png" class="" title="java线程"><p>【2】shutdownNow（）方法：拒绝新任务提交，停止所有正在执行任务的线程；</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/67.png" class="" title="java线程"><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/68.png" class="" title="java线程"><h4 id="（8）ForkJoinPool线程池"><a href="#（8）ForkJoinPool线程池" class="headerlink" title="（8）ForkJoinPool线程池"></a>（8）ForkJoinPool线程池</h4><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/69.png" class="" title="java线程"><h4 id="（9）CompletableFuture"><a href="#（9）CompletableFuture" class="headerlink" title="（9）CompletableFuture"></a>（9）CompletableFuture</h4><h5 id="①thenApply源码"><a href="#①thenApply源码" class="headerlink" title="①thenApply源码"></a>①thenApply源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">    Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">uniApplyStage</span><span class="hljs-params">(</span><br><span class="hljs-params">    Executor e, Function&lt;? <span class="hljs-built_in">super</span> T,? extends V&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;V&gt; d =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;V&gt;();<br>    <span class="hljs-comment">//e:一步调用直接执行</span><br>    <span class="hljs-comment">//uniApply任务执行失败，需要入栈</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniApply(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniApply&lt;T,V&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        <span class="hljs-comment">//尝试执行任务</span><br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> &lt;S&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniApply</span><span class="hljs-params">(CompletableFuture&lt;S&gt; a,</span><br><span class="hljs-params">                           Function&lt;? <span class="hljs-built_in">super</span> S,? extends T&gt; f,</span><br><span class="hljs-params">                           UniApply&lt;S,T&gt; c)</span> &#123;<br>    Object r; Throwable x;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || (r = a.result) == <span class="hljs-literal">null</span> || f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    tryComplete: <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> AltResult) &#123;<br>            <span class="hljs-keyword">if</span> ((x = ((AltResult)r).ex) != <span class="hljs-literal">null</span>) &#123;<br>                completeThrowable(x, r);<br>                <span class="hljs-keyword">break</span> tryComplete;<br>            &#125;<br>            r = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; !c.claim())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) r;<br>            <span class="hljs-comment">//执行任务，并将结果写入result</span><br>            completeValue(f.apply(s));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            completeThrowable(ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②thenAcceptAsync源码（异步执行）"><a href="#②thenAcceptAsync源码（异步执行）" class="headerlink" title="②thenAcceptAsync源码（异步执行）"></a>②thenAcceptAsync源码（异步执行）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">uniAcceptStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                               Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;Void&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;Void&gt;();<br>    <span class="hljs-comment">//异步调用，e不为null，执行压入栈顶</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> || !d.uniAccept(<span class="hljs-built_in">this</span>, f, <span class="hljs-literal">null</span>)) &#123;<br>        UniAccept&lt;T&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt;(e, d, <span class="hljs-built_in">this</span>, f);<br>        push(c);<br>        c.tryFire(SYNC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniAccept</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,Void&gt; &#123;<br>    Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn;<br>    UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,<br>              CompletableFuture&lt;T&gt; src, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; fn) &#123;<br>        <span class="hljs-built_in">super</span>(executor, dep, src); <span class="hljs-built_in">this</span>.fn = fn;<br>    &#125;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">tryFire</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span> &#123;<br>        CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;<br>         <span class="hljs-comment">//dep为null，任务已经执行过</span><br>        <span class="hljs-comment">//uniAccept为false表示任务可能已被其他线程执行</span><br>        <span class="hljs-keyword">if</span> ((d = dep) == <span class="hljs-literal">null</span> ||<br>            !d.uniAccept(a = src, fn, mode &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : <span class="hljs-built_in">this</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        dep = <span class="hljs-literal">null</span>; src = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//任务已经完成，继续执行前一个任务</span><br>        <span class="hljs-keyword">return</span> d.postFire(a, mode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">postFire</span><span class="hljs-params">(CompletableFuture&lt;?&gt; a, <span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; a.stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//前一个任务执行完毕</span><br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span> || a.result == <span class="hljs-literal">null</span>)<br>            a.cleanStack();<span class="hljs-comment">//任务出栈</span><br>        <span class="hljs-keyword">else</span><br>            a.postComplete();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; stack != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span><br>            postComplete();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③supplyAsync源码"><a href="#③supplyAsync源码" class="headerlink" title="③supplyAsync源码"></a>③supplyAsync源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">asyncSupplyStage</span><span class="hljs-params">(Executor e,</span><br><span class="hljs-params">                                                 Supplier&lt;U&gt; f)</span> &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture&lt;U&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;U&gt;();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span>&lt;U&gt;(d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncSupply</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, AsynchronousCompletionTask &#123;<br>        CompletableFuture&lt;T&gt; dep;<span class="hljs-comment">//</span><br>        Supplier&lt;T&gt; fn;<span class="hljs-comment">//执行逻辑</span><br>        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;<br>            <span class="hljs-built_in">this</span>.dep = dep; <span class="hljs-built_in">this</span>.fn = fn;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123; run(); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;<br>            <span class="hljs-keyword">if</span> ((d = dep) != <span class="hljs-literal">null</span> &amp;&amp; (f = fn) != <span class="hljs-literal">null</span>) &#123;<br>                dep = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//result为任务执行完后的结果，为null表示未完成结果</span><br>                <span class="hljs-keyword">if</span> (d.result == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        d.completeValue(f.get());<span class="hljs-comment">//等待任务结束并设置结果</span><br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                        d.completeThrowable(ex);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//任务执行完成，执行所有依赖改任务的所有任务</span><br>                d.postComplete();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postComplete</span><span class="hljs-params">()</span> &#123;<br>    CompletableFuture&lt;?&gt; f = <span class="hljs-built_in">this</span>; <br>    Completion h;<br>    <span class="hljs-keyword">while</span> ((h = f.stack) != <span class="hljs-literal">null</span> ||<br>           (f != <span class="hljs-built_in">this</span> &amp;&amp; (h = (f = <span class="hljs-built_in">this</span>).stack) != <span class="hljs-literal">null</span>)) &#123;<br>        CompletableFuture&lt;?&gt; d; <br>        Completion t;<span class="hljs-comment">//保存的是依靠当前CompletableFuture的任务</span><br>        <span class="hljs-keyword">if</span> (f.casStack(h, t = h.next)) &#123;<span class="hljs-comment">//获取栈中下一个Completion</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当前的CompletableFuture不是this的，将所有Completion加入当前栈中</span><br>                <span class="hljs-keyword">if</span> (f != <span class="hljs-built_in">this</span>) &#123;<br>                    pushStack(h);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                h.next = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 为当前CompletableFuture，解除联系</span><br>            &#125;<br>            f = (d = h.tryFire(NESTED)) == <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span> : d;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个CompletableFuture持有一个Completion栈stack, 每个Completion持有一个CompletableFuture， 如此递归循环下去，是层次很深的树形结构，所以想办法将其变成链表结构。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/70.png" class="" title="java线程"><p>首先取出头结点，下图中灰色Completion结点，它会返回一个CompletableFuture, 同样也拥有一个stack，策略是遍历这个CompletableFuture的stack的每个结点，依次压入到当前CompletableFuture的stack中，关系如下箭头所示，灰色结点指的是处理过的结点。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/71.png" class="" title="java线程"><p>第一个Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/72.png" class="" title="java线程"><p>后续的Completion结点返回的CompletableFuture, 将拥有的stack里面的所有结点都压入了当前CompletableFuture的stack里面，重新构成了一个链表结构，后续也按照前面的逻辑操作，如此反复，便会遍历完所有的CompletableFuture, 这些CompletableFuture(叶子结点)的stack为空，也是结束条件。</p><img src="/2022/06/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/73.png" class="" title="java线程">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h4><p>（1）处理方法：<br>①第一行记录原数组行总数，列总数，有多少个不同的值；<br>②第二行开始，存储对应值行，对应值列，对应值大小<br>（2）二维数组转换为稀疏数组<br>①遍历二位数组，得到有效数据个数sum；<br>②根据sum创建稀疏数组，int [sum+1][3];<br>③将二维数组有效数据存入到稀疏数组；<br>（3）稀疏数组转换为二维数组<br>①读取稀疏数组第一行，得到行数，列数，创建原始二维数组；<br>②再读取稀疏数组后几行数据，并赋给二维数组；</p><h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><p>（1）先进先出，后进后出<br>（2）队列图</p><p>（3）循环队列<br>①front指向队列第一个元素；<br>②rear指向最后一个元素的后一个位置，预留一个空间(实际存放长度为maxSize-1)；<br>③队列满时，条件是（rear+1）%maxSize&#x3D;front；<br>④队列为空，rear&#x3D;&#x3D;front<br>⑤队列有效数据个数：（rear+maxSize-front）%maxSize</p><h4 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h4><p>（1）单链表创建示意图</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" class="" title="java线程"><p>（2）双向链表</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" class="" title="java线程"><h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><h5 id="（1）数组模拟栈"><a href="#（1）数组模拟栈" class="headerlink" title="（1）数组模拟栈"></a>（1）数组模拟栈</h5><p>①top初始化为-1；<br>②有数据加入时，top++，stack[top]&#x3D;n;<br>③出栈时，int value&#x3D;stack[top]，top–；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" class="" title="java线程"><h5 id="（2）计算一个表达式"><a href="#（2）计算一个表达式" class="headerlink" title="（2）计算一个表达式"></a>（2）计算一个表达式</h5><p>①通过index值（字符串扫描索引）遍历表达式<br>②若index发现是一个数字，直接入数栈<br>③扫描到的是符号：<br>若符号栈为空，直接入栈；<br>若符号栈有操作符，进行比较，若单前操作符的优先级小于等于栈中操作符，需要从数栈弹出两个数，符号栈pop出一个符号，进行运算，将运算结果入数栈，然后当前符号值入栈；<br>若符号栈有操作符，进行比较，若单前操作符的优先级大于栈中操作符，当前符号入符号栈；<br>④当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应数和符号，并运算，最后数栈只有一个数字，就为表达式结果</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" class="" title="java线程"><h5 id="（3）前缀表达式（波兰表达式）"><a href="#（3）前缀表达式（波兰表达式）" class="headerlink" title="（3）前缀表达式（波兰表达式）"></a>（3）前缀表达式（波兰表达式）</h5><p>前缀表达式求值：从右往左扫描，遇到数字，数字入栈，遇到运算符，弹出栈顶两个元素运算，并将结果入栈<br>如：（3+4）*5-6对应的前缀表达式：- *+3 4 5 6</p><h5 id="（4）中缀表达式"><a href="#（4）中缀表达式" class="headerlink" title="（4）中缀表达式"></a>（4）中缀表达式</h5><p>如：（3+4）*5-6</p><h5 id="（5）后缀表达式（逆波兰表达式）"><a href="#（5）后缀表达式（逆波兰表达式）" class="headerlink" title="（5）后缀表达式（逆波兰表达式）"></a>（5）后缀表达式（逆波兰表达式）</h5><p>后缀表达式求值：从左向右扫描，遇到数字，数字入栈，遇到运算符，弹出栈顶两个元素运算，并将结果入栈<br>如：（3+4）* _5-6后缀表达式为：3 4 + 5 * _6 -</p><h5 id="（6）中缀表达式转后缀表达式思路："><a href="#（6）中缀表达式转后缀表达式思路：" class="headerlink" title="（6）中缀表达式转后缀表达式思路："></a>（6）中缀表达式转后缀表达式思路：</h5><p>①初始化两个栈，运算符栈和存储中间结果栈；<br>②从左至右扫描；<br>③遇到数，入结果栈s2；<br>④遇到运算符，与s1比较优先级：<br>    若s1为空，或栈顶运算符为（，直接入栈；<br>    若优先级比s1栈顶运算符高，运算符入栈；<br>    若优先级比s1栈顶运算符相等或低，先将s1栈顶弹出，压入s2栈，再与s1新栈顶比较；<br>⑤遇到括号：<br>   括号为（，直接入s1栈；<br>    括号为 ），依次弹出s1栈运算符，直到遇到左括号（为止；<br>⑥重复②到⑤步骤<br>⑦将s1剩余运算符弹出压入s2；<br>⑧，依次将s2弹出，并逆序，即为后缀表达式；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" class="" title="java线程"><h4 id="5、算法时间复杂度"><a href="#5、算法时间复杂度" class="headerlink" title="5、算法时间复杂度"></a>5、算法时间复杂度</h4><p>（1）时间频度：算法中语句执行次数；<br>（2）算法时间复杂度可以忽略常数项；<br>（3）算法时间复杂度可以忽略低次项；<br>（4）算法时间复杂度可以忽略系数；<br>（5）常数阶O（1）：无论代码多少行，只要无循环复杂结构，时间复杂度就是O（1）；<br>（6）对数阶O(log2n)：</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" class="" title="java线程"><p>（7）线性阶O(n)：单层循环；<br>（8）线性对数阶O(nlogN): </p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.png" class="" title="java线程"><h4 id="6、冒泡排序"><a href="#6、冒泡排序" class="headerlink" title="6、冒泡排序"></a>6、冒泡排序</h4><p>（1）从前往后依次比较相邻元素的值，若发现逆序交换，使值大的从前往后移；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.png" class="" title="java线程"><p>（2）优化：<br>①排序过程中若无进行交换，说明已经有序；<br>②每一趟排序次数逐渐减少；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png" class="" title="数据结构"><h4 id="7、选择排序"><a href="#7、选择排序" class="headerlink" title="7、选择排序"></a>7、选择排序</h4><p>（1）第一次从arr[0] 到arr[n-1] 中选取最小值与arr[0]交换，第二次从arr[1] 到arr[n-1] 中选取最小值与arr[1]交换……………….;</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png" class="" title="数据结构"><h4 id="8、插入排序"><a href="#8、插入排序" class="headerlink" title="8、插入排序"></a>8、插入排序</h4><p>（1）分为无序表和有序表，每次取无序表的第一个元素，插入有序表</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png" class="" title="数据结构"><h5 id="9、希尔排序"><a href="#9、希尔排序" class="headerlink" title="9、希尔排序"></a>9、希尔排序</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png" class="" title="数据结构"><h4 id="10、快速排序"><a href="#10、快速排序" class="headerlink" title="10、快速排序"></a>10、快速排序</h4><p>（1）对冒泡排序的改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (begin&gt;end)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=quickSort1(nums,begin,end);<br>    sort(nums,begin,mid-<span class="hljs-number">1</span>);<br>    sort(nums,mid+<span class="hljs-number">1</span>,end);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSort1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-type">int</span> i=begin+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j=end;<br>    <span class="hljs-type">int</span> temp=nums[begin];<br><br>    <span class="hljs-keyword">while</span> (i&lt;j)&#123;<br>        <span class="hljs-comment">//在后端找比temp小的值</span><br>        <span class="hljs-keyword">while</span> (i&lt;j&amp;&amp;nums[j]&gt;temp)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//在前面找比temp大的值</span><br>        <span class="hljs-keyword">while</span> (i&lt;j&amp;&amp;nums[i]&lt;temp)&#123;<br>            i++;<br>        &#125;<br>        swap(nums,i,j);<br>        i++;<br>        j--;<br>    &#125;<br>    swap(nums,begin,j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> temp=nums[i];<br>    nums[i]=nums[j];<br>    nums[j]=temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="11、归并排序"><a href="#11、归并排序" class="headerlink" title="11、归并排序"></a>11、归并排序</h4><p>（1）该排序采用分治策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>     <span class="hljs-keyword">if</span> (begin&lt;end)&#123;<br>         <span class="hljs-type">int</span> mid=(begin+end)/<span class="hljs-number">2</span>;<br>         merge(nums,begin,mid,temp);<br>         merge(nums,mid+<span class="hljs-number">1</span>,end,temp);<br>         mergeSort(nums,begin,end,temp);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>     <span class="hljs-type">int</span> i=begin;<br>     <span class="hljs-type">int</span> mid=(begin+end)/<span class="hljs-number">2</span>;<br>     <span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=end)&#123;<br>         temp[index++]=nums[i]&lt;=nums[j]?nums[i++]:nums[j++];<br>     &#125;<br>     <span class="hljs-comment">//右边还存在数据</span><br>     <span class="hljs-keyword">while</span> (i&lt;=mid)&#123;<br>         temp[index++]=nums[i++];<br>     &#125;<br>     <span class="hljs-comment">//左边存在数据</span><br>     <span class="hljs-keyword">while</span> (j&lt;=end)&#123;<br>         temp[index++]=nums[j++];<br>     &#125;<br>     <span class="hljs-comment">//数组拷贝</span><br>     <span class="hljs-type">int</span> numsInex=begin;<br>     <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (t&lt;index)&#123;<br>         nums[numsInex++]=temp[t++];<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="12、基数排序"><a href="#12、基数排序" class="headerlink" title="12、基数排序"></a>12、基数排序</h4><p>（1）基数排序属于稳定性排序，空间换时间算法</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png" class="" title="数据结构"><p>（2）将带比较的值统一为同样长度，数位较短值前面补零，然后从最低位开始，依次进行排序；<br>  注：比较次数取决于最大数的位数</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/16.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/17.png" class="" title="数据结构"><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/18.png" class="" title="数据结构"><h4 id="13、插值查找"><a href="#13、插值查找" class="headerlink" title="13、插值查找"></a>13、插值查找</h4><p>(1)mid&#x3D;left+(right-left)*(target-arr[left])&#x2F;(arr[right]-arr[left])；<br>(2)数字分布均匀查找效率高；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png" class="" title="数据结构"><h4 id="14、斐波那契查找"><a href="#14、斐波那契查找" class="headerlink" title="14、斐波那契查找"></a>14、斐波那契查找</h4><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.png" class="" title="数据结构"><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//获取斐波那契数列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] fib()&#123;<br>    <span class="hljs-keyword">int</span>[] f=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxSize];<br>    f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; f.length; i++) &#123;<br>        f[i]=f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-comment">//斐波那契查找</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> low=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high=arr.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示斐波那契分割数值的下标</span><br>    <span class="hljs-keyword">int</span> mid=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] f=fib();<span class="hljs-comment">//获取斐波那契数列</span><br>    <span class="hljs-comment">//获取斐波那契分割下标</span><br>    <span class="hljs-keyword">while</span> (high&gt;f[k]<span class="hljs-number">-1</span>)&#123;<br>        k++;<br>    &#125;<br>    <span class="hljs-comment">//f[k]可能大于a的长度，因此需要构造一个新数组，并指向a[]</span><br>    <span class="hljs-keyword">int</span>[] temp= Arrays.copyOf(arr,f[k]);<br>    <span class="hljs-comment">//使用a数组最后的数填充temp</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = high+<span class="hljs-number">1</span>; i &lt; temp.length; i++) &#123;<br>        temp[i]=arr[high];<br>    &#125;<br>    <span class="hljs-comment">//使用while循环处理，找到数target</span><br>    <span class="hljs-keyword">while</span> (low&lt;=high)&#123;<br>        mid=low+f[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span>&lt;temp[mid])&#123;<br>            high=mid<span class="hljs-number">-1</span>;<br>            k--;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span>&gt;temp[mid])</span></span>&#123;<br>            low=mid+<span class="hljs-number">1</span>;<br>            k-=<span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mid&lt;=high)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> high;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15、哈希表"><a href="#15、哈希表" class="headerlink" title="15、哈希表"></a>15、哈希表</h4><p>（1）根据关键字映射到表中一个位置来访问记录，数组为散列表；</p><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/21.png" class="" title="数据结构"><h4 id="16、二叉树"><a href="#16、二叉树" class="headerlink" title="16、二叉树"></a>16、二叉树</h4><h5 id="（1）前中后遍历"><a href="#（1）前中后遍历" class="headerlink" title="（1）前中后遍历"></a>（1）前中后遍历</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/22.png" class="" title="数据结构"><h5 id="（2）前序、中序、后序查找"><a href="#（2）前序、中序、后序查找" class="headerlink" title="（2）前序、中序、后序查找"></a>（2）前序、中序、后序查找</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/23.png" class="" title="数据结构"><h5 id="（3）删除节点"><a href="#（3）删除节点" class="headerlink" title="（3）删除节点"></a>（3）删除节点</h5><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/24.png" class="" title="数据结构"><h5 id="（4）线索二叉树"><a href="#（4）线索二叉树" class="headerlink" title="（4）线索二叉树"></a>（4）线索二叉树</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">① <span class="hljs-built_in">n</span>个节点的二叉链表中含有（<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>）个空指针域，利用空指针域，存放指向该节点某种（前序，中序，后序）遍历下的前驱或后继节点的指针；<br> ②<span class="hljs-built_in">left</span>可能指向左子树或前驱节点；<br> ③<span class="hljs-built_in">right</span>可能指向右子树或后继节点；<br> ④线索二叉树不能使用原来的遍历方式遍历<br></code></pre></td></tr></table></figure><img src="/2022/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/25.png" class="" title="数据结构"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedNodes</span><span class="hljs-params">(HeroNode1 node)</span>&#123;<br>        <span class="hljs-comment">//如果node为null，不能线索化</span><br>        <span class="hljs-keyword">if</span> (node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        threadedNodes(node.getLeft());<br><br>        <span class="hljs-comment">//线索化当前节点</span><br>        <span class="hljs-comment">//先处理前驱节点</span><br>        <span class="hljs-keyword">if</span> (node.getLeft()==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//让当前节点的左指针指向前驱节点</span><br>            node.setLeft(pre);<br>            <span class="hljs-comment">//修改当前左指针的类型</span><br>            node.setLeftType(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//处理后继节点</span><br>        <span class="hljs-keyword">if</span> (pre!=<span class="hljs-literal">null</span>&amp;&amp;pre.getRight()==<span class="hljs-literal">null</span>)&#123;<br>            pre.setRight(node);<br>            pre.setRightType(<span class="hljs-number">1</span>);<br>        &#125;<br>        pre=node;<br>        threadedNodes(node.getRight());<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadedList</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//定义变量记录当前遍历节点</span><br>      HeroNode1 node1=root;<br>      <span class="hljs-keyword">while</span> (node1!=<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-comment">//循环找到leftType=1的节点</span><br>          <span class="hljs-keyword">while</span> (node1.getLeftType()==<span class="hljs-number">0</span>)&#123;<br>              node1=node1.getLeft();<br>          &#125;<br>          System.out.println(node1);<br>          <span class="hljs-keyword">while</span> (node1.getRightType()==<span class="hljs-number">1</span>)&#123;<br>              node1=node1.getRight();<br>              System.out.println(node1);<br>          &#125;<br>          node1=node1.getRight();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="（5）堆排序"><a href="#（5）堆排序" class="headerlink" title="（5）堆排序"></a>（5）堆排序</h5><p>①大顶堆：每个节点的值大于或等于子节点的值；<br>②小顶堆：每个节点的值小于或等于子节点的值；<br>③升序采用大顶堆，降序采用小顶堆；<br>④堆排序思路：<br>A、从最左最下的非叶子节点开始，开始构造大顶堆（最后一个非叶子节点下标为n&#x2F;2-1）；<br>B、将根节点与每一次数组的后面值交换，根据根节点调整大顶堆<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665633465370-75bb9a07-c4db-438a-a128-3be0da822f64.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">headSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-comment">//将无序序列构造成大顶堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            adjustHeap(arr,i, arr.length);<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">//将堆顶元素压入数组末端</span><br>        <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>; i &gt;<span class="hljs-number">0</span> ; i--) &#123;<br>            temp=arr[i];<br>            arr[i]=arr[<span class="hljs-number">0</span>];<br>            arr[<span class="hljs-number">0</span>]=temp;<br>            adjustHeap(arr,<span class="hljs-number">0</span>,i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将数组构造成大顶堆</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    完成对i非叶子节点的树调整成大顶堆</span><br><span class="hljs-comment">    i表示非叶子节点在数组中的索引，</span><br><span class="hljs-comment">    len表示对多少个元素进行调整</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> length)</span>&#123;<br>        <span class="hljs-type">int</span> temp=arr[i];<br>        <span class="hljs-comment">//左子节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; j &lt; length ; j=j*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;length&amp;&amp;arr[j]&lt;arr[j+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//左子节点值小于右子节点</span><br>                j++;<span class="hljs-comment">//j指向右子节点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;temp)&#123;<span class="hljs-comment">//子节点大于父节点</span><br>                arr[i]=arr[j];<br>                i=j;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//已经将以i为父节点的树的最大值放在顶点</span><br>        arr[i]=temp;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="17、哈夫曼树"><a href="#17、哈夫曼树" class="headerlink" title="17、哈夫曼树"></a>17、哈夫曼树</h4><p>（1）节点的权：树节点的值；<br>（2）带权路径长度：从根节点到该节点之间的路径长度与该节点的权的乘积；<br>（3）树的带全路径长度（wpl）：所有叶子节点的带权路径长度；wpl最小就是哈夫曼树<br>（4）构造哈夫曼树思路：<br>①数组从小到大排序；<br>②取出权值最小的两个树，组合成一颗新的二叉树，形成新的根节点；<br>③以根节点的权值大小再次排序，重复上述步骤<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665639906644-aab33d51-cbfc-400e-b9d9-954ea5b3abf6.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">createHuffman</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>       <span class="hljs-comment">//遍历arr数组，arr构建成node，node放入ArrayList</span><br>       List&lt;Node&gt; nodes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>           nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value));<br>       &#125;<br><br>       <span class="hljs-keyword">while</span> (nodes.size()&gt;<span class="hljs-number">1</span>)&#123;<br>           Collections.sort(nodes);<br>           <span class="hljs-comment">//取出值最小两个节点</span><br>           Node leftNode=nodes.get(<span class="hljs-number">0</span>);<br>           Node rightNode=nodes.get(<span class="hljs-number">1</span>);<br>           <span class="hljs-comment">//构建一颗新的二叉树</span><br>           Node parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(leftNode.value+rightNode.value);<br>           parent.left=leftNode;<br>           parent.right=rightNode;<br><br>           <span class="hljs-comment">//删除从list中取出的两个jiedian</span><br>           nodes.remove(leftNode);<br>           nodes.remove(rightNode);<br>           <span class="hljs-comment">//添加parent</span><br>           nodes.add(parent);<br>       &#125;<br>       <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//返回头节点</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>（5）哈夫曼编码<br>①哈夫曼树是无损压缩；<br>②原理图<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665644862747-f3e78fb3-582f-445c-a8a3-e0f1070f2957.jpeg"><br>③压缩字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建哈夫曼树</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Nodes <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(List&lt;Nodes&gt; nodes)</span>&#123;<br>      <span class="hljs-keyword">while</span> (nodes.size()&gt;<span class="hljs-number">1</span>)&#123;<br>          Collections.sort(nodes);<br>          Nodes leftNode=nodes.get(<span class="hljs-number">0</span>);<br>          Nodes rightNode=nodes.get(<span class="hljs-number">1</span>);<br>          Nodes parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Nodes</span>(<span class="hljs-literal">null</span>,leftNode.weight+rightNode.weight);<br>          parent.left=leftNode;<br>          parent.right=rightNode;<br><br>          nodes.remove(leftNode);<br>          nodes.remove(rightNode);<br>          nodes.add(parent);<br>      &#125;<br>      <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//接收一个字节数组，返回list</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Nodes&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span>&#123;<br>      List&lt;Nodes&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      Map&lt;Byte,Integer&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : bytes) &#123;<br>          Integer count=map.get(b);<br>          <span class="hljs-keyword">if</span> (count==<span class="hljs-literal">null</span>)&#123;<br>              map.put(b,<span class="hljs-number">1</span>);<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              map.put(b,count+<span class="hljs-number">1</span>);<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//每一个键值对转换为node对象</span><br>      <span class="hljs-keyword">for</span> (Byte b : map.keySet()) &#123;<br>          list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Nodes</span>(b,map.get(b)));<br>      &#125;<br>      <span class="hljs-keyword">return</span> list;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成哈夫曼树编码表</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将哈夫曼树存放在Map&lt;byte,String&gt;中，如32--01，97--100，100--11000 .......</span><br><span class="hljs-comment">StringBuilder存储叶子节点路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">static</span> Map&lt;Byte,String&gt; huffmanCode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//存放编码</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将传入nodes的所有叶子节点，获取哈夫曼编码，放入集合中;</span><br><span class="hljs-comment">code:左子节点是0，右子节点为1</span><br><span class="hljs-comment">stringBuilder用户拼接路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">(Nodes nodes,String code,StringBuilder s)</span>&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>    <span class="hljs-comment">//将传入code加入stringBuilder</span><br>    stringBuilder2.append(code);<br>    <span class="hljs-keyword">if</span> (nodes!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//判断当前nodes是叶子节点，还是非叶子节点</span><br>        <span class="hljs-keyword">if</span> (nodes.data==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//非叶子节点</span><br>            getCode(nodes.left,<span class="hljs-string">&quot;0&quot;</span>,stringBuilder2);<span class="hljs-comment">//向左</span><br>            getCode(nodes.right,<span class="hljs-string">&quot;1&quot;</span>,stringBuilder2);<span class="hljs-comment">//向右</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            huffmanCode.put(nodes.data,stringBuilder2.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>压缩时lastLength记录最后一位字节的长度，便于后面解压时对最后一位的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个方法，将字符串对应的byte【】数组，通过哈夫曼编码表，返回一个哈夫曼处理后（压缩后）的字节数组</span><br>   <span class="hljs-comment">//str=&gt;1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastLength=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录最后一位数的长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] zip(<span class="hljs-type">byte</span>[] bytes,Map&lt;Byte,String&gt; huffmanCodes)&#123;<br>       <span class="hljs-comment">//利用哈夫编码编码表，将字符串字节数组转换为哈夫曼编码对应的字符串</span><br>       <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : bytes) &#123;<br>           stringBuilder.append(huffmanCodes.get(b));<br>       &#125;<br>       <span class="hljs-comment">//将字符串准换为byte数组</span><br>       <span class="hljs-comment">//统计返回huffmanCodeBytes 长度</span><br>       <span class="hljs-type">int</span> len;<br>       <span class="hljs-keyword">if</span> (stringBuilder.length()%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>)&#123;<br>           len=stringBuilder.length()/<span class="hljs-number">8</span>;<br>           lastLength=<span class="hljs-number">8</span>;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           len=stringBuilder.length()/<span class="hljs-number">8</span>+<span class="hljs-number">1</span>;<br>           lastLength=stringBuilder.length()%<span class="hljs-number">8</span>;<span class="hljs-comment">//记录最后一位数的长度</span><br>       &#125;<br>       <span class="hljs-comment">//创建存储压缩后的byte数组</span><br>       <span class="hljs-type">byte</span>[] huffmanCodeBytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>       <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); i+=<span class="hljs-number">8</span>) &#123;<span class="hljs-comment">//每8位对应一个byte</span><br>           String strBytes;<br>           <span class="hljs-keyword">if</span> (i+<span class="hljs-number">8</span>&gt;stringBuilder.length())&#123;<br>               strBytes=stringBuilder.substring(i);<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               strBytes=stringBuilder.substring(i,i+<span class="hljs-number">8</span>);<br>           &#125;<br>           huffmanCodeBytes[temp++]= (<span class="hljs-type">byte</span>) Integer.parseInt(strBytes,<span class="hljs-number">2</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> huffmanCodeBytes;<br>   &#125;<br></code></pre></td></tr></table></figure><p>④解压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将每一个字节转换位二进制字符串</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">byteToString</span><span class="hljs-params">(<span class="hljs-type">byte</span> b,<span class="hljs-type">boolean</span> flag)</span>&#123;<br>      <span class="hljs-type">int</span> temp=b;<br>      <span class="hljs-keyword">if</span> (flag)&#123;<span class="hljs-comment">//true表示不是最后一位</span><br>          temp |=<span class="hljs-number">256</span>;<span class="hljs-comment">//正数补高位</span><br>      &#125;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Integer.toBinaryString(temp);<br>      <span class="hljs-keyword">if</span> (flag)&#123;<br>          <span class="hljs-keyword">return</span> str.substring(str.length()-<span class="hljs-number">8</span>);<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> str.substring(str.length()-lastLength);<span class="hljs-comment">//最后一位返回对应长度</span><br>      &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//解压</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] unzip(<span class="hljs-type">byte</span>[] huffmanBytes,Map&lt;Byte,String&gt; huffmanCodes)&#123;<br>      <span class="hljs-comment">//将压缩的字节数组转换为二进制字符串</span><br>      StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; huffmanBytes.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (i!=huffmanBytes.length-<span class="hljs-number">1</span>)&#123;<br>              stringBuilder.append(byteToString(huffmanBytes[i],<span class="hljs-literal">true</span>));<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              stringBuilder.append(byteToString(huffmanBytes[i],<span class="hljs-literal">false</span>));<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//将哈夫曼编码表的键值对顺序调换</span><br>      Map&lt;String,Byte&gt; unHuffmanCode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (Byte b : huffmanCodes.keySet()) &#123;<br>          unHuffmanCode.put(huffmanCodes.get(b),b);<br>      &#125;<br>      <span class="hljs-comment">//将二进制字符串编码，根据哈夫曼编码表反向编码</span><br>      List&lt;Byte&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); ) &#123;<br>          String str=stringBuilder.substring(i,count);<br>          Byte b= unHuffmanCode.get(str);<br>          <span class="hljs-comment">//反向编码表未找到，count++</span><br>          <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">null</span>)&#123;<br>              count++;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              result.add(b);<br>              i=count;<br>          &#125;<br>      &#125;<br>      <span class="hljs-comment">//result集合转换未字节数组</span><br>      <span class="hljs-type">byte</span>[] unzip=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[result.size()];<br>      <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (Byte b : result) &#123;<br>          unzip[index++]=b;<br>      &#125;<br>      <span class="hljs-keyword">return</span> unzip;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="18、二叉排序树（BST）"><a href="#18、二叉排序树（BST）" class="headerlink" title="18、二叉排序树（BST）"></a>18、二叉排序树（BST）</h4><p>（1）左子节点小于根节点，右子节点大于根节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加节点</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node2 node)</span>&#123;<br>      <span class="hljs-keyword">if</span> (node==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//判断传入节点的和当前子树的根节点的值的关系</span><br>      <span class="hljs-keyword">if</span>(node.value&lt;<span class="hljs-built_in">this</span>.value)&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.left==<span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-built_in">this</span>.left=node;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">this</span>.left.add(node);<br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.right==<span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-built_in">this</span>.right=node;<br>          &#125;<span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-built_in">this</span>.right.add(node);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>（2）删除节点思路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665731466521-09b6df75-e59a-4eef-97e3-06226d0b4406.jpeg"></p><h4 id="19、平衡二叉树（AVL树）"><a href="#19、平衡二叉树（AVL树）" class="headerlink" title="19、平衡二叉树（AVL树）"></a>19、平衡二叉树（AVL树）</h4><p>（1）左右两个个子树的高度差绝对值不超过1，并且左右两个都是平衡二叉树；<br>（2）左旋转：右子树高左旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665798378294-6d1d9a0e-8663-4d46-9e79-d823539fd403.jpeg"><br>（3）右旋转：左子树高右旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665801266953-f587f7b2-cf50-4c9a-9c48-c4e57776a0ee.jpeg"><br>（4）双旋转<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665802551185-3859f49b-f842-468b-98ac-4b11e580d0b6.jpeg"></p><h4 id="20、B树"><a href="#20、B树" class="headerlink" title="20、B树"></a>20、B树</h4><p>（1）2-3树<br>①所有叶子节点都在同一层；<br>②有两个子节点的节点为二节点，二节点要么没有子节点，要么有两个子节点；<br>③有三个子节点的节点为三节点，三节点要么没有节点，要么有三个子节点；<br>④由二节点和三节点构成；<br>（2）说明<br>①B树阶：节点的最多子节点数，如2-3数的阶是3；<br>③关键字分布在整颗树中，叶子和非叶子都存储数据<br>（3）B+树·<br>①所有数据存放在叶子节点的链表中，链表中数据是有序的；<br>②非叶子节点只存储索引；</p><h4 id="21、图"><a href="#21、图" class="headerlink" title="21、图"></a>21、图</h4><p>（1）图的深度优先遍历（DFS）<br>①从初始访问节点出发，访问第一个邻接结点，然后以这个被访问的邻接结点作为初始结点，继续访问该初始结点的第一个邻接结点；<br>②步骤：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665887153552-302f201d-61a0-4e64-bfb8-c813e75a666c.jpeg"><br>（2）图的广度优先遍历（BFS）<br>①需要使用一个队列保持访问过结点的顺序，以便按照这个顺序来访问邻接结点；<br>②步骤<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1665900274868-7bf0d067-3a9d-4f52-8000-3431c22931f9.jpeg"></p><h4 id="22、动态规划——背包问题"><a href="#22、动态规划——背包问题" class="headerlink" title="22、动态规划——背包问题"></a>22、动态规划——背包问题</h4><p>（1）01背包</p><table><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>1500</td></tr><tr><td>物品1</td><td>4</td><td>3000</td></tr><tr><td>物品2</td><td>3</td><td>2000</td></tr></tbody></table><p>背包填表（二维数组）过程<br>①第二行，假设只有物品0存在，对应最大价值1500；<br>②第三行，假设物品0和物品1存在，对应最大价值3000；<br>③第四行，假设物品0，1，2存在，对应最大价值3500，即最终背包最大价值。</p><table><thead><tr><th>物品</th><th>0磅</th><th>1磅</th><th>2磅</th><th>3磅</th><th>4磅</th></tr></thead></table><p>|<br> | 0 | 0 | 0 | 0 | 0 |<br>| 物品0 | 0 | 1500 | 1500 | 1500 | 1500 |<br>| 物品1 | 0 | 1500 | 1500 | 1500 | 3000 |<br>| 物品2 | 0 | 1500 | 1500 | 2000 | 2000+1500 |</p><p>④当j&lt;w[i]时，v[i][j]&#x3D;v[i-1][j]:<br>准备加入的物品的重量大于当前背包的中量，就直接使用上面的装入策略<br>⑤当j&gt;&#x3D;w[i],v[i][j]&#x3D;Math.max(v[i-1][j]，v[i-1][j-w[i]]+v[i])：<br>准备加入的物品重量小于当前背包重量；<br>v[i-1][j]:上一个单元格装入的最大值；<br>v[i]:当前商品价值；<br>v[i-1][j-w[i]]:装入i-1个商品，到剩余空间j-w[i]的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bag</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] w=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//物品重量</span><br>        <span class="hljs-type">int</span>[] v=&#123;<span class="hljs-number">1500</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">2000</span>&#125;;<span class="hljs-comment">//物品价值</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-number">4</span>;<span class="hljs-comment">//背包容量</span><br>        <span class="hljs-type">int</span> n=v.length;<span class="hljs-comment">//物品个数</span><br>        <span class="hljs-type">int</span>[][] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;bag.length ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; bag[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (w[i-<span class="hljs-number">1</span>]&gt;j)&#123;<span class="hljs-comment">//物品重量大于当前背包重量,因为物品下标从0开始，而遍历从1开始，所以要w[i-1]</span><br>                    bag[i][j]=bag[i-<span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    bag[i][j]=Math.max(bag[i-<span class="hljs-number">1</span>][j],bag[i-<span class="hljs-number">1</span>][j-w[i-<span class="hljs-number">1</span>]]+v[i-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(bag[n][m]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bag2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w,<span class="hljs-type">int</span>[] v,<span class="hljs-type">int</span> size)</span>&#123;<br>       <span class="hljs-type">int</span>[] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size+<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; w.length; i++) &#123;<span class="hljs-comment">//遍历物品</span><br>           <span class="hljs-comment">//遍历背包，必须从后往前遍历，从前往后遍历会重复放入同一个物品</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bag.length-<span class="hljs-number">1</span>; j &gt;=w[i]; j--) &#123;<br>               bag[j]=Math.max(bag[j],v[i]+bag[j-w[i]]);<br>           &#125;<br>       &#125;<br>       System.out.println(bag[bag.length-<span class="hljs-number">1</span>]);<br>   &#125;<br></code></pre></td></tr></table></figure><p>（2）完全背包：可以重复放入同一个物品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bag3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w,<span class="hljs-type">int</span>[] v,<span class="hljs-type">int</span> size)</span>&#123;<br>       <span class="hljs-type">int</span>[] bag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size+<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; w.length; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> w[i]; j &lt; bag.length; j++) &#123;<br>               bag[j]=Math.max(bag[j],v[i]+bag[j-w[i]]);<br>           &#125;<br>       &#125;<br>       System.out.println(bag[size]);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="23、KMP算法"><a href="#23、KMP算法" class="headerlink" title="23、KMP算法"></a>23、KMP算法</h4><p>（1）部分匹配值：前缀和后缀最长的共有元素长度，<br>①前缀：bread前缀：b、br、bre、brea、<br>②后缀：bread后缀：read、ead、ad、d<br>如：ABCDA：前缀A、AB、ABC、ABCD，后缀BCDA、CDA、DA、A，共有元素为A，长度为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取一个字符串的部分匹配值</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] kmpNext(String dest)&#123;<br>       <span class="hljs-type">int</span>[] next=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dest.length()];<br>       next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//如果字符串长度为1，部分匹配值就是0</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>; i &lt; next.length; i++) &#123;<br>           <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;dest.charAt(i)!=dest.charAt(j))&#123;<br>               j=next[j-<span class="hljs-number">1</span>];<br>           &#125;<br>           <span class="hljs-comment">//部分匹配值+1</span><br>           <span class="hljs-keyword">if</span> (dest.charAt(i)==dest.charAt(j))&#123;<br>               j++;<br>           &#125;<br>           next[i]=j;<br>       &#125;<br>       <span class="hljs-keyword">return</span> next;<br>   &#125;<br><br>   <span class="hljs-comment">//KMP算法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(String str1,String str2,<span class="hljs-type">int</span>[] next)</span>&#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;<br>           <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;str1.charAt(i)!=str2.charAt(j))&#123;<br>               j=next[j-<span class="hljs-number">1</span>];<br>           &#125;<br>           <span class="hljs-keyword">if</span> (str1.charAt(i)==str2.charAt(j))&#123;<br>               j++;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (j==str2.length())&#123;<br>               <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h4 id="24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）"><a href="#24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）" class="headerlink" title="24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）"></a>24、普里姆算法（Prim）和克鲁斯卡尔算法（Kruskal）</h4><p>（1）普里姆算法：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666017664904-50f92163-0947-47e8-92e1-c43c3b1dad5f.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Prim算法,得到最小生成树</span><br>    <span class="hljs-comment">//v表示从哪一个顶点开始</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] prim(MGraph graph,<span class="hljs-type">int</span> v)&#123;<br>        <span class="hljs-type">int</span>[][] route=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.vertex][graph.vertex];<br>        <span class="hljs-type">int</span> minWay=<span class="hljs-number">10000</span>;<span class="hljs-comment">//记录最小路径</span><br>        <span class="hljs-type">int</span> x=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> y=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[graph.vertex];<span class="hljs-comment">//记录顶点是否被访问</span><br>        visited[v]=<span class="hljs-number">1</span>;<span class="hljs-comment">//v记录已经被访问</span><br><br>        <span class="hljs-comment">//n个顶点的边未n-1个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; graph.vertex - <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-comment">//寻找已经访问顶点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.vertex; i++) &#123;<br>                <span class="hljs-comment">//遍历已访问顶点的邻接顶点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; graph.vertex; j++) &#123;<br>                    <span class="hljs-comment">//顶点已经被访问，顶点i的邻接顶点j未被访问</span><br>                    <span class="hljs-keyword">if</span> (visited[i]==<span class="hljs-number">1</span>&amp;&amp;visited[j]==<span class="hljs-number">0</span>&amp;&amp;graph.weight[i][j]&lt;minWay)&#123;<br>                        minWay=graph.weight[i][j];<br>                        x=i;<br>                        y=j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;路劲&quot;</span>+x+<span class="hljs-string">&quot;-&gt;&quot;</span>+y+<span class="hljs-string">&quot;:&quot;</span>+minWay);<br>            <span class="hljs-comment">//记录最小路径</span><br>            route[x][y]=minWay;<br>            <span class="hljs-comment">//y节点标记未已经访问</span><br>            visited[y]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//minWay重新初始化</span><br>            minWay=<span class="hljs-number">10000</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> route;<br>    &#125;<br></code></pre></td></tr></table></figure><p>（2）克鲁斯卡尔算法<br>①所有边的权值从小到大排序；<br>②依次从边中选取最小边值加入到最小生成树中，并判断是否有回路存在；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666060310804-a6578624-76d5-42d3-95a5-db4dfd7aaaaa.jpeg"><br>③判断是否有回路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666061043459-817da6d0-66a9-4dbe-9f1a-3e1f61e1b0f2.jpeg"></p><h4 id="25、迪杰斯特拉算法（Dijkstra）和-弗洛伊德算法（Floyd）"><a href="#25、迪杰斯特拉算法（Dijkstra）和-弗洛伊德算法（Floyd）" class="headerlink" title="25、迪杰斯特拉算法（Dijkstra）和 弗洛伊德算法（Floyd）"></a>25、迪杰斯特拉算法（Dijkstra）和 弗洛伊德算法（Floyd）</h4><p>（1）迪杰斯特拉算法：<br>用于计算一个节点到其他节点的最短路径（广度优先的思想）<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666099671713-02d0d2cd-7ef2-4e0d-aba9-dbbc46aa7812.jpeg"><br>dis数组，记录顶点v到其他顶点的最短路径<br>dis更新规则：比较初始顶点v到V集合的距离，与v通过前驱节点到V集合中顶点距离，保留较小值</p><table><thead><tr><th>dis</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>65535</td><td>2</td><td>2</td></tr><tr><td><strong>B</strong></td><td>65535</td><td>3</td><td>3</td></tr><tr><td>C</td><td>65535</td><td>65535</td><td>9</td></tr><tr><td>D</td><td>65535</td><td>65535</td><td>65535</td></tr><tr><td>E</td><td>65535</td><td>4</td><td>4</td></tr><tr><td>F</td><td>65535</td><td>6</td><td>6</td></tr><tr><td>G</td><td>0</td><td>65535</td><td>4</td></tr></tbody></table><p>pre数组，记录每一个节点的前一个节点的下标</p><table><thead><tr><th>pre</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td><strong>B</strong></td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td>C</td><td>-1</td><td>-1</td><td>0  A</td></tr><tr><td>D</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>E</td><td>-1</td><td>6   G</td><td>6  G</td></tr><tr><td>F</td><td>-1</td><td>6   G</td><td>6 G</td></tr><tr><td>G</td><td>-1</td><td>-1</td><td>-1</td></tr></tbody></table><p>vistied数组记录节点是否被访问，1表示被访问</p><table><thead><tr><th>pre</th><th>初始值</th><th>第一次</th><th>第二次</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>0</td><td>1</td></tr><tr><td><strong>B</strong></td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td></tr><tr><td>E</td><td>0</td><td>0</td><td>0</td></tr><tr><td>F</td><td>0</td><td>0</td><td>0</td></tr><tr><td>G</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迪杰斯特拉算法，index表示起始顶点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-comment">//初始化记录数组</span><br>        visitedVertex=<span class="hljs-keyword">new</span> <span class="hljs-title class_">VisitedVertex</span>(vertex.length,index);<br>        <span class="hljs-comment">//获取到记录数组</span><br>        <span class="hljs-type">int</span>[] dis = visitedVertex.dis;<br>        <span class="hljs-type">int</span>[] visited = visitedVertex.visited;<br>        <span class="hljs-type">int</span>[] pre = visitedVertex.pre;<br>        <span class="hljs-comment">//标记起始顶点为已经访问</span><br>        visited[index]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//更新dis数组和前驱数组，第一趟</span><br>        update(index);<br>        <span class="hljs-comment">//开始查找起始顶点，经过中间节点，到目标节点的距离  与原最短距离比较</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> searchNext(index);<br>            <span class="hljs-comment">//标记next为已经访问节点</span><br>            visited[next]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//更新最短距离</span><br>            update(next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//更新起始顶点经过index顶点到其他顶点的最短路径，并且更新前驱节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>            <span class="hljs-comment">//起始顶点到index顶点，再到i点的距离</span><br>            len=visitedVertex.dis[index]+matrix[index][i];<br>            <span class="hljs-keyword">if</span> (visitedVertex.visited[index]!=<span class="hljs-number">0</span>&amp;&amp;<br>                    visitedVertex.dis[i]&gt;len)&#123;<br>                visitedVertex.dis[i]=len;<br>                visitedVertex.pre[i]=index;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//查找一个距离index顶点最近的点返回，且该点是未访问过</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> min=<span class="hljs-number">65535</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visitedVertex.visited[i]!=<span class="hljs-number">1</span>&amp;&amp;min&gt;visitedVertex.dis[i])&#123;<br>                min=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历最短路径</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>          System.out.print(<span class="hljs-string">&quot;顶点&quot;</span>+vertex[index]);<br>          print(i);<br>          System.out.println();<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>      <span class="hljs-keyword">if</span> (visitedVertex.pre[index]==-<span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      print(visitedVertex.pre[index]);<br>      System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[index]);<br>  &#125;<br></code></pre></td></tr></table></figure><p>（2）弗洛伊德算法<br>①计算图中各个顶点的最短路径，每一个顶点都是起始顶点，求每一个起始顶点到其他顶点的最短路径；（迪杰斯特拉则是选定一个顶点为起始顶点，求其到其他顶点的最短路径）<br>②思路<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1666150127439-a7d252d0-eeaf-4170-8572-c8fa39e90c51.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] vertex;<span class="hljs-comment">//顶点数组</span><br>    <span class="hljs-type">int</span>[][] dis;<span class="hljs-comment">//保存从各个顶点出发，到其他顶点距离</span><br>    <span class="hljs-type">int</span>[][] pre;<span class="hljs-comment">//保存到目标结点的中间结点</span><br><br><span class="hljs-comment">//弗洛伊德算法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//中间顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; vertex.length; k++) &#123;<br>            <span class="hljs-comment">//起始顶点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vertex.length; i++) &#123;<br>                <span class="hljs-comment">//终点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; vertex.length; j++) &#123;<br>                    <span class="hljs-type">int</span> len=dis[i][k]+ dis[k][j];<span class="hljs-comment">//起始顶点，经过k，再到终点j</span><br>                    <span class="hljs-keyword">if</span> (len&lt; dis[i][j])&#123;<br>                        dis[i][j]=len;<span class="hljs-comment">//更新最短距离</span><br>                        pre[i][j]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历i到j最短距离</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;顶点&quot;</span>+vertex[i]+<span class="hljs-string">&quot;到顶点&quot;</span>+vertex[j]+<span class="hljs-string">&quot;的最短路径:&quot;</span>+vertex[i]);<br>    goDeap(i,j);<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[j]);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goDeap</span><span class="hljs-params">(<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[begin][end]==-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span>+vertex[pre[begin][end]]);<br>    goDeap(pre[begin][end],end);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="26、字典树（Trie）"><a href="#26、字典树（Trie）" class="headerlink" title="26、字典树（Trie）"></a>26、字典树（Trie）</h4><p>（1）结点本身不存储完整单词；<br>（2）从根结点到某一结点，路径上经过的字符连接起来，为该结点的字符串；<br>（3）每个结点的所有子结点路径代表的字符都不相同；<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670332166896-5d03a137-5e01-43fe-ac4a-351e1665edb4.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] dict;<span class="hljs-comment">//存储字字符</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<span class="hljs-comment">//true表示是字符串最后一个字符，及最后一层</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        dict=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd=<span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//插入字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-comment">//当前结点</span><br>        Trie node=<span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">//遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> ch=word.charAt(i);<br>            <span class="hljs-comment">//存储下标</span><br>            <span class="hljs-type">int</span> index=ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//判断该字符是否出现过</span><br>            <span class="hljs-keyword">if</span> (node.dict[index]==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//存储该字符</span><br>                node.dict[index]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            <span class="hljs-comment">//进入子节点</span><br>            node=node.dict[index];<br>        &#125;<br>        <span class="hljs-comment">//标记最后一个字符为最后位置</span><br>        node.isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//查找字符串是否存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> trie!=<span class="hljs-literal">null</span>&amp;&amp;trie.isEnd;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> searchPrefix(prefix);<br>        <span class="hljs-keyword">return</span> trie!=<span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断字符前缀是否存在</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String word)</span>&#123;<br>        Trie node=<span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">//遍历字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> ch=word.charAt(i);<br>            <span class="hljs-comment">//获取下标位置</span><br>            <span class="hljs-type">int</span> index=ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//该字符不存在</span><br>            <span class="hljs-keyword">if</span> (node.dict[index]==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//进入下一个结点</span><br>            node=node.dict[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="27、并查集"><a href="#27、并查集" class="headerlink" title="27、并查集"></a>27、并查集</h4><h5 id="（1）普通并查集"><a href="#（1）普通并查集" class="headerlink" title="（1）普通并查集"></a>（1）普通并查集</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1670500482203-dfd3eae6-5acb-43d6-bfc9-bc660aa9a860.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        count=n;<br>        parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i]=i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-keyword">while</span> (p!=parent[p])&#123;<br>            parent[p]=parent[parent[p]];<br>            p=parent[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> rootP=find(p);<br>        <span class="hljs-type">int</span> rootQ=find(q);<br>        <span class="hljs-keyword">if</span> (rootQ==rootP)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        parent[rootP]=rootQ;<br>        count--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）带权并查集"><a href="#（2）带权并查集" class="headerlink" title="（2）带权并查集"></a>（2）带权并查集</h5><h6 id="①寻找父节点（路径压缩）"><a href="#①寻找父节点（路径压缩）" class="headerlink" title="①寻找父节点（路径压缩）"></a>①寻找父节点（路径压缩）</h6><p>寻找父节点时，同时更新权值<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1680706918139-cd6a4f0c-f415-4997-b5a1-63730f52eae6.jpeg"></p><h6 id="②合并"><a href="#②合并" class="headerlink" title="②合并"></a>②合并</h6><p>小节点指向大节点<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/29496365/1680707366906-d809ad4d-56f0-4077-9685-50d8ed687a2d.jpeg"></p><h5 id="（3）代码"><a href="#（3）代码" class="headerlink" title="（3）代码"></a>（3）代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Value</span> &#123;<br>    <span class="hljs-type">int</span>[] parent;<span class="hljs-comment">//父节点</span><br>    <span class="hljs-type">int</span>[] value;<span class="hljs-comment">//权值</span><br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Union_Value</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        value=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i]=i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//寻找父节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        <span class="hljs-comment">//当前节点为根节点</span><br>        <span class="hljs-keyword">if</span> (node==parent[node])&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-comment">//记录当前节点的父节点</span><br>        <span class="hljs-type">int</span> temp=parent[node];<br>        <span class="hljs-comment">//寻找根节点</span><br>        parent[node]=findParent(parent[node]);<br>        <span class="hljs-comment">//更新当前节点的权值</span><br>        value[node]+=value[temp];<br>        <span class="hljs-keyword">return</span> parent[node];<br>    &#125;<br><br>    <span class="hljs-comment">//合并节点值,weight为节点x与y之间的权值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> weight)</span>&#123;<br>        <span class="hljs-type">int</span> xRoot=findParent(x);<br>        <span class="hljs-type">int</span> yRoot=findParent(y);<br>        <span class="hljs-keyword">if</span> (xRoot==yRoot)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//小节点指向大节点</span><br>        parent[xRoot]=yRoot;<br>        value[xRoot]=value[y]+weight-value[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="28、红黑树"><a href="#28、红黑树" class="headerlink" title="28、红黑树"></a>28、红黑树</h4><p>（1）每个结点要么是红色，要么是黑色；<br>（2）根结点是黑色；<br>（3）每个叶子结点（NULL结点）是黑色的；<br>（4）不能相邻两个红色结点；<br>（5）从任一结点到其他每个叶子的所有路径都包含相同数目的黑色结点；<br>（6）任何一个结点的左右子树的高度差小于两倍;</p><h4 id="29、布隆过滤器"><a href="#29、布隆过滤器" class="headerlink" title="29、布隆过滤器"></a>29、布隆过滤器</h4><p>查找不到的元素一定不存在，查找到的元素可能存在<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1671885966092-4db90117-0ab6-40a1-b24c-c64d4c4f1b35.jpeg"></p><h4 id="30、LRU缓存"><a href="#30、LRU缓存" class="headerlink" title="30、LRU缓存"></a>30、LRU缓存</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29496365/1671887081323-73d147ca-175a-4a53-a9e8-d083375ecdb0.jpeg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/04/18/Spring/"/>
    <url>/2022/04/18/Spring/</url>
    
    <content type="html"><![CDATA[<h3 id="1、IOC"><a href="#1、IOC" class="headerlink" title="1、IOC"></a>1、IOC</h3><h4 id="（1）控制反转"><a href="#（1）控制反转" class="headerlink" title="（1）控制反转"></a>（1）控制反转</h4><blockquote><ul><li><p>传统的业务开发中，A对象需要B对象，是由A对象去new创建B对象，并管理者B对象的生命周期；</p></li><li><p>使用IOC后，对象的管理权交给ioc，A对象需要B对象时，直接从IOC容器中注入B对象到A中，A无需知道B对象是怎么创建的，也不用管理B对象的生命周期；</p><img src="/2022/04/18/Spring/1.jpg" class="" title="spring"></li></ul></blockquote><h4 id="（2）IOC优点"><a href="#（2）IOC优点" class="headerlink" title="（2）IOC优点"></a>（2）IOC优点</h4><blockquote><ul><li><p>降低对象之间的依赖程度；</p></li><li><p>可以很好实现单例bean；</p></li><li><p>在传统开发中，UserServiceImpl中，需要应用UserDao实现类，需要new一个实现类UserDaoImpl，当dao实现类需要修改为另外一个时，service中依赖该dao的new代码，都需要修改（如果由100个service类依赖该dao，就要修改100次），代码耦合度过高；</p><img src="/2022/04/18/Spring/2.jpg" class="" title="spring"></li></ul></blockquote><blockquote><ul><li>对象交给SpringIOC控制后，代码的依赖性大大降低，在修改dao实现类时，由于dao对象已经交由ioc容器管理，service层代码不需要修改任何代码，直接和IOC容器要即可；</li></ul><img src="/2022/04/18/Spring/3.jpg" class="" title="spring"></blockquote><h3 id="2、AOP"><a href="#2、AOP" class="headerlink" title="2、AOP"></a>2、AOP</h3><blockquote><ol><li>SpringAOP是依赖于动态代理模式实现的，有使用接口则是JDK动态代理，没有使用接口的则是CGLib代理；</li><li>SpringAOP依赖于IOC容器来管理；</li><li>他只能作用于容器中的Bean；</li></ol></blockquote><h4 id="（1）AOP解决的问题"><a href="#（1）AOP解决的问题" class="headerlink" title="（1）AOP解决的问题"></a>（1）AOP解决的问题</h4><blockquote><ul><li><p>在OOP编程中，可以解决大部分纵向垂直代码的重复问题，但无法解决父类多个方法中，同一个位置出现重复代码的问题；</p></li><li><p>如下实例，Student类和Teacher类继承Person类，可以自动获得父类Person中的方法，这样可以减少重复代码的出现；但是Person多个方法中出现多个同样逻辑，oop无法解决代码重复问题</p><img src="/2022/04/18/Spring/4.jpg" class="" title="spring"><img src="/2022/04/18/Spring/5.jpg" class="" title="spring"></li></ul></blockquote><blockquote><ul><li><p>AOP将与业务无关的代码，与业务代码分离出来。在不改变原有业务逻辑的情况下，将增强逻辑代码织入到业务代码中，从而减少大量重复代码；</p><img src="/2022/04/18/Spring/6.jpg" class="" title="spring"></li></ul></blockquote><h4 id="（2）AOP术语"><a href="#（2）AOP术语" class="headerlink" title="（2）AOP术语"></a>（2）AOP术语</h4><blockquote><ul><li>@Aspect：使用该注解的bean会被当作用于实现AOP的配置类；</li><li>@Pointcut：指定那些方法需要被增强或拦截；</li><li><ul><li>within：指定某个类或包下方法，如@Pointcut（”within（com.service.impl.*）”）</li><li>annotation：方法上具有特定注解，标识需要被增强，如：@Pointcut（”@annotation(注解名)”）</li><li>bean：匹配bean的名字，@Pointcut（”bean（beanName）”）</li></ul></li><li>JoinPoint：获取原业务逻辑方法参数，对于@Around注解，使用的是子类ProceedingJoinPoint，他有proceed方法（用于执行原业务逻辑）。</li><li>Advice：增强的逻辑代码，即拦截连接点后需要做的事；</li><li>Aspect（切面）：拦截点（JoinPoint）+通知（Advice）</li></ul></blockquote><h4 id="（3）AOP拦截链（示例）"><a href="#（3）AOP拦截链（示例）" class="headerlink" title="（3）AOP拦截链（示例）"></a>（3）AOP拦截链（示例）</h4><blockquote><ul><li><p>MethodInvocation接口：封装被代理方法的相关信息，包括方法参数、方法本身，被代理对象等；</p></li><li><p>MethodInterceptor接口：作为拦截器的实现接口，里面有invoke方法（拦截器执行增强逻辑）；</p></li><li><p>AopInterceptorChain：拦截器链，addInterceptor实现添加拦截器，，executeChain方法依次执行拦截器链中的拦截器；</p></li><li><p>InvocationWrapper：拦截器链的递归调用，proceed方法执行目标方法；</p><img src="/2022/04/18/Spring/7.jpg" class="" title="spring"><img src="/2022/04/18/Spring/8.jpg" class="" title="spring"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//封装被代理类信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInvocation</span> &#123;<br>    Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable;<br>    Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span>;<br>    Object[] getArgs();<br>    Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br><br><br><span class="hljs-comment">//封装拦截链和MethodInvocation</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvocationWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInvocation</span>&#123;<br><br>    <span class="hljs-keyword">private</span> AopInterceptorChain chain;<br>    <span class="hljs-keyword">private</span> MethodInvocation invocation;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InvocationWrapper</span><span class="hljs-params">(AopInterceptorChain chain,MethodInvocation invocation)</span>&#123;<br>        <span class="hljs-built_in">this</span>.chain=chain;<br>        <span class="hljs-built_in">this</span>.invocation=invocation;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//递归调用拦截器</span><br>        <span class="hljs-keyword">return</span> chain.executeChain(invocation);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> invocation.getMethod();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object[] getArgs() &#123;<br>        <span class="hljs-keyword">return</span> invocation.getArgs();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> invocation.getThis();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//拦截链</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopInterceptorChain</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;MethodInterceptor&gt; chain=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptor</span><span class="hljs-params">(MethodInterceptor interceptor)</span>&#123;<br>        chain.add(interceptor);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">executeChain</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (chain.isEmpty())&#123;<br>            <span class="hljs-comment">//执行业务逻辑</span><br>            <span class="hljs-keyword">return</span> invocation.proceed();<br>        &#125;<br>        <span class="hljs-comment">//获取代理链</span><br>        <span class="hljs-type">MethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> chain.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//执行拦截器逻辑，并将拦截链和invocation封装到  InvocationWrapper</span><br>        <span class="hljs-keyword">return</span> interceptor.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationWrapper</span>(<span class="hljs-built_in">this</span>,invocation));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟日志拦截器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;日志打印前记录时间&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;日志打印后，记录时间&quot;</span>);<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//也无代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;日志打印&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AopInterceptorChain</span> <span class="hljs-variable">aopInterceptorChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopInterceptorChain</span>();<br>        <span class="hljs-comment">//添加拦截器</span><br>        aopInterceptorChain.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>());<br>        aopInterceptorChain.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>());<br><br>        UserService userService=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        MethodInvocation methodInvocation=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInvocation</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                userService.log();<span class="hljs-comment">//执行真正的业务逻辑</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> MethodUtils.getAccessibleMethod(UserService.class,<span class="hljs-string">&quot;log&quot;</span>,<br>                                                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object[] getArgs() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//开始执行拦截链方法</span><br>            aopInterceptorChain.executeChain(methodInvocation);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            throwable.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、DI"><a href="#3、DI" class="headerlink" title="3、DI"></a>3、DI</h3><blockquote><ol><li>组件之间的依赖关系由容器运行期决定的，即由容器动态的将某个依赖对应关系注入到组件中；通过依赖注入，我们只需通过简单的配置文件，而无需代码就可以指定目标需要的资源，完成自身逻辑，不需要关心具体的资源来自何处；</li><li>谁依赖谁：应用程序依赖于ioc容器；</li><li>为什么需要依赖：应用程序需要ioc容器来提供对象需要的外部资源；</li><li>谁注入谁：ioc容器注入应用程序某个对象，应用程序依赖的对象；</li><li>注入什么：注入对象所需的外部资源（对象，资源，常量数据）；</li></ol></blockquote><h3 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h3><h4 id="（1）事务基本使用"><a href="#（1）事务基本使用" class="headerlink" title="（1）事务基本使用"></a>（1）事务基本使用</h4><blockquote><ul><li>事务四大特性：原子性（要么都做，要么都不做）、隔离性（事务之间相互不影响）、持久性（一个事务提交，在数据库中他的数据改变是永久的）、一致性（执行事务前后，数据保持一致）；</li><li>编程式事务管理：手动管理事务；</li><li>声明式事务管理：通过aop实现，代码侵入性最低；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<br>    count++;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//抛出异常，事务回滚</span><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>PlatformTransactionManager事务管理器，为接口，提供了获取事务，提交事务，事务回滚的接口方法；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> &#123;<br>    <span class="hljs-comment">//获得事务，TransactionDefinition为事务的属性，即一些配置属性</span><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）事务传播"><a href="#（2）事务传播" class="headerlink" title="（2）事务传播"></a>（2）事务传播</h4><blockquote><p>事务传播：当事务方法被另外一个事务方法调用时，必须指定事务传播类型；</p><p>事务A的方法调用事务B：</p><p>事务传播参数（Propagation）：</p><ol><li>REQUIRED：默认使用事务，当前如果没有事务，则创建一个新的事务，有事务存在，则加入当前事务，只要其中一个事务回滚，整个事务都会回滚；</li><li>REQUIRES_NEW：不管外面的方法是否有事务开启，内部方法都会创建一个新的事务，若外部事务A回滚，B事务不会回滚，若事务B抛出异常回滚，事务A也会回滚；</li><li>NESTED：外部有事务方法，内部开启一个新的事务，作为嵌套事务存在，如：A回滚，B会回滚。B回滚，A不会回滚；</li><li>MANDATORY：当前有事务，加入事务，无事务，抛出异常</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    B b;<br>    <span class="hljs-meta">@Transactional</span>（(propagation = Propagation.xxx）<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>        b.b();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-meta">@Transactional</span>（(propagation = Propagation.xxx）<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）事务隔离级别"><a href="#（3）事务隔离级别" class="headerlink" title="（3）事务隔离级别"></a>（3）事务隔离级别</h4><blockquote><ul><li><p>ISOLATION_READ_UNCOMMITTED：读未提交，允许读取事务未提交的数据，可能会造成脏读，不可重复读，幻读；</p></li><li><p>ISOLATION_READ_COMMITTED：读提交，允许读取事务提交的数据，可能会造成不可重复读，幻读；</p></li><li><p>ISOLATION_REPEATABLE_READ：可重复读，对数据读取结果都是一致的，除非被本事务修改，可能会造成幻读，MYSQL默认隔离级别；</p></li><li><ul><li>该事务级别，每次会生成一份快照数据（所有已提交事务已修改但未提交的数据），当数据量大时会影响性能；</li><li>减小事务范围，减少生成快照量；</li><li>使用压缩算法，压缩生成的快照数据；</li><li>使用增量快照：只生成最近有一次生成快照修改的数据，减少快照数据量的生成；</li><li>根据应用需求，考虑更低的隔离级别，如读提交级别；</li></ul></li><li><p>ISOLATION_SERIALIZABLE：串行化，所有事务依次执行，性能差，不建议使用；</p></li></ul></blockquote><h4 id="（4）Transation事务失效"><a href="#（4）Transation事务失效" class="headerlink" title="（4）Transation事务失效"></a>（4）Transation事务失效</h4><blockquote><ul><li><p>作用于静态方法上会失效：springIOC管理的是对象，而静态方法是属于类方法，不由ioc管理，事务是通过aop来进行代理实现的，springAOP只能依赖于SpringIOC容器；</p></li><li><p>异常被处理或吞噬：@Transaction作用的方法抛出异常，异常被捕获吞噬了，spring无法检测到该异常，导致事务失效；如下面代码：</p></li><li><ul><li>若是事务可以正常处理，结果要么为23，要么回滚为22，因为事务失效，出现22结果；</li><li>可以使用**TransactionAspectSupport.currentTransactionStatus()**，标记事务回滚（需要激活事务管理器才可以使用该方法）；</li><li>若想自定义异常回滚，可以使用如下：@Transactional(rollbackFor&#x3D; MyException.class)</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<span class="hljs-comment">//传入20</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//模拟异常</span><br>    <span class="hljs-comment">//由于上面出现错误，不会执行此处</span><br>        count++;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;捕获异常，不处理&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//上面出现错误，按道理，spring捕获异常，事务回滚，不会执行下面这句</span><br><span class="hljs-comment">//由于异常被捕获，spring无法检测到，事务不会回滚，还是会执行以下语句</span><br>    count+=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> count;<span class="hljs-comment">//最终结果为22，</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>作用在非public方法会失效，SpringAOP代理只会代理public方法，非public方法无法实现代理；</li><li>同一个类中，没有Transaction注解的方法调用 有Transaction注解的方法，有Transaction的方法会导致事务失效，如下代码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span>&#123;<br>    <span class="hljs-meta">@Transaction</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span>&#123;<br>        A();<span class="hljs-comment">//A事务失效</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、MVC"><a href="#5、MVC" class="headerlink" title="5、MVC"></a>5、MVC</h3><h4 id="（1）执行流程"><a href="#（1）执行流程" class="headerlink" title="（1）执行流程"></a>（1）执行流程</h4><blockquote><ol><li><p>用户请求–&gt;DispatchServlet：前端控制器收到请求后，委托给统一控制器进行处理，作为统一访问点，进行全局流程控制；</p></li><li><p>DispatchServlet–&gt;HandlerMapping：HandlerMapping将请求映射为HandlerExecutionChain对象，即将url和controller进行映射；</p></li><li><p>DispatchServlet–&gt;HandlerAdapter：HandlerAdapter会把处理器包装为适配器，从而支持多种类型的处理器；</p></li><li><p>HandlerAdapter–&gt;处理器方法调用：HandlerAdapter会根据请求的url选择合适的handler，进行真正业务逻辑处理，返回ModelAndView；</p></li><li><p>ModelAndView–&gt;ViewResolver：将逻辑视图解析为具体的View；</p></li><li><p>View–&gt;渲染：根据model数据获取渲染的View；</p></li><li><p>返回DispatchServlet，由DispatchServlet将数据展示给用户；</p><img src="/2022/04/18/Spring/9.jpg" class="" title="spring"></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
